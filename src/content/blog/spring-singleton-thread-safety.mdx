---
title: "Springå•ä¾‹æ¨¡å¼ä¸å¤šçº¿ç¨‹å®‰å…¨ï¼šæ·±å…¥ç†è§£å®¹å™¨çº§å•ä¾‹çš„çº¿ç¨‹å®‰å…¨æœºåˆ¶"
description: "æ·±å…¥è§£æSpringå•ä¾‹æ¨¡å¼çš„å®ç°åŸç†ï¼Œæ¢è®¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„å˜é‡å®‰å…¨é—®é¢˜ã€‚ä»Springå®¹å™¨çš„å•ä¾‹ç®¡ç†åˆ°çº¿ç¨‹å®‰å…¨çš„æœ€ä½³å®è·µï¼Œæä¾›å®Œæ•´çš„è§£å†³æ–¹æ¡ˆå’Œä»£ç ç¤ºä¾‹ï¼Œå¸®åŠ©å¼€å‘è€…æ­£ç¡®å¤„ç†Springåº”ç”¨ä¸­çš„å¹¶å‘é—®é¢˜ã€‚"
pubDate: 2025-06-28
updatedDate: 2025-06-28
tags: ["spring", "singleton", "thread-safety", "concurrency", "java", "dependency-injection", "best-practices", "interview"]
categories: ["java-core"]
subject: "å¹¶å‘ç¼–ç¨‹"
draft: false
featured: true
author: "Gerrad Zhang"
location: "æ­¦æ±‰ï¼Œä¸­å›½"
---

## ğŸ¤” é—®é¢˜èƒŒæ™¯ä¸æŠ€æœ¯æ¼”è¿›

### æˆ‘ä»¬è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

åœ¨Springæ¡†æ¶çš„ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œå¼€å‘è€…ç»å¸¸ä¼šé‡åˆ°è¿™æ ·çš„å›°æƒ‘ï¼š

- **Springè¯´Beanæ˜¯å•ä¾‹çš„**ï¼šæ‰€æœ‰æ³¨å…¥çš„åœ°æ–¹éƒ½æ˜¯åŒä¸€ä¸ªå¯¹è±¡
- **å¤šçº¿ç¨‹è®¿é—®é—®é¢˜**ï¼šå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å•ä¾‹Beanä¸­çš„å˜é‡ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- **å˜é‡å®‰å…¨æ€§**ï¼šå¦‚ä½•ä¿è¯`int a = 1`è¿™æ ·çš„å˜é‡åœ¨ä¸åŒçº¿ç¨‹ä¸­çš„ä¿®æ”¹ä¸è¢«å¹²æ‰°ï¼Ÿ
- **æ€§èƒ½ä¸å®‰å…¨å¹³è¡¡**ï¼šå¦‚ä½•åœ¨ä¿è¯çº¿ç¨‹å®‰å…¨çš„åŒæ—¶ç»´æŒè‰¯å¥½çš„æ€§èƒ½ï¼Ÿ

```java
// è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„Springå•ä¾‹Bean
@Service
public class CounterService {
    private int counter = 0;  // è¿™ä¸ªå˜é‡å®‰å…¨å—ï¼Ÿ
    
    public void increment() {
        counter++;  // å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
    }
    
    public int getCounter() {
        return counter;  // èƒ½è·å–åˆ°æœŸæœ›çš„å€¼å—ï¼Ÿ
    }
}
```

### æ²¡æœ‰è¿™ä¸ªæŠ€æœ¯æ—¶æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ

åœ¨Springæ¡†æ¶å‡ºç°ä¹‹å‰ï¼ŒJavaå¼€å‘è€…éœ€è¦æ‰‹åŠ¨ç®¡ç†å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸå’Œå•ä¾‹æ¨¡å¼ï¼š

**1. ä¼ ç»Ÿå•ä¾‹æ¨¡å¼çš„å®ç°**
```java
// é¥¿æ±‰å¼å•ä¾‹ - çº¿ç¨‹å®‰å…¨ä½†æµªè´¹å†…å­˜
public class EagerSingleton {
    private static final EagerSingleton INSTANCE = new EagerSingleton();
    
    private EagerSingleton() {}
    
    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
}

// æ‡’æ±‰å¼å•ä¾‹ - éœ€è¦æ‰‹åŠ¨å¤„ç†çº¿ç¨‹å®‰å…¨
public class LazySingleton {
    private static volatile LazySingleton instance;
    
    private LazySingleton() {}
    
    public static LazySingleton getInstance() {
        if (instance == null) {
            synchronized (LazySingleton.class) {
                if (instance == null) {
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}
```

**2. æ‰‹åŠ¨ä¾èµ–ç®¡ç†**
```java
// éœ€è¦æ‰‹åŠ¨åˆ›å»ºå’Œç®¡ç†å¯¹è±¡ä¾èµ–å…³ç³»
public class ManualDependencyManagement {
    private UserService userService;
    private OrderService orderService;
    
    public ManualDependencyManagement() {
        // æ‰‹åŠ¨åˆ›å»ºä¾èµ–
        this.userService = new UserService();
        this.orderService = new OrderService(userService);
    }
    
    // éœ€è¦æ‰‹åŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
    public void cleanup() {
        userService.cleanup();
        orderService.cleanup();
    }
}
```

**3. çº¿ç¨‹å®‰å…¨çš„æ‰‹åŠ¨å¤„ç†**
```java
// æ¯ä¸ªç±»éƒ½éœ€è¦è‡ªå·±å¤„ç†çº¿ç¨‹å®‰å…¨
public class ThreadSafeCounter {
    private int counter = 0;
    private final Object lock = new Object();
    
    public void increment() {
        synchronized (lock) {
            counter++;
        }
    }
    
    public int getCounter() {
        synchronized (lock) {
            return counter;
        }
    }
}
```

### æŠ€æœ¯æ¼”è¿›çš„å†å²è„‰ç»œ

**EJBæ—¶ä»£ (1998-2004)**ï¼šä¼ä¸šçº§Beanå®¹å™¨
- æä¾›äº†å®¹å™¨ç®¡ç†çš„å•ä¾‹æ¦‚å¿µ
- ä½†é…ç½®å¤æ‚ï¼Œæ€§èƒ½è¾ƒå·®
- éœ€è¦å¤§é‡çš„XMLé…ç½®å’Œæ¥å£å®ç°

**Springæ¡†æ¶è¯ç”Ÿ (2003)**ï¼šè½»é‡çº§å®¹å™¨é©å‘½
- å¼•å…¥äº†IoCï¼ˆæ§åˆ¶åè½¬ï¼‰å®¹å™¨
- ç®€åŒ–äº†å•ä¾‹Beançš„ç®¡ç†
- æä¾›äº†å£°æ˜å¼çš„ä¾èµ–æ³¨å…¥

**Spring 2.0+ (2006)**ï¼šæ³¨è§£é©±åŠ¨å¼€å‘
- å¼•å…¥`@Component`ã€`@Service`ç­‰æ³¨è§£
- ç®€åŒ–äº†Beançš„å£°æ˜å’Œé…ç½®
- é»˜è®¤å•ä¾‹ä½œç”¨åŸŸæˆä¸ºæ ‡å‡†

**Spring Bootæ—¶ä»£ (2014)**ï¼šçº¦å®šä¼˜äºé…ç½®
- è‡ªåŠ¨é…ç½®å¤§é‡å•ä¾‹Bean
- å¼€å‘è€…æ›´å°‘å…³æ³¨Beançš„ç”Ÿå‘½å‘¨æœŸ
- ä½†çº¿ç¨‹å®‰å…¨é—®é¢˜å˜å¾—æ›´åŠ éšè”½

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µä¸åŸç†

### Springå•ä¾‹æ¨¡å¼çš„æœ¬è´¨

Springçš„å•ä¾‹æ¨¡å¼ä¸ä¼ ç»Ÿçš„Singletonè®¾è®¡æ¨¡å¼æœ‰æœ¬è´¨åŒºåˆ«ï¼š

```java
/**
 * Springå®¹å™¨çº§å•ä¾‹çš„å®ç°åŸç†
 */
public class SpringSingletonPrinciple {
    
    /**
     * Springå®¹å™¨çš„ç®€åŒ–å®ç°
     */
    public class SimplifiedApplicationContext {
        // å•ä¾‹Beanç¼“å­˜æ±  - Springå•ä¾‹çš„æ ¸å¿ƒ
        private final ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>();
        private final Map<String, BeanDefinition> beanDefinitions = new HashMap<>();
        
        /**
         * è·å–Beanå®ä¾‹ - å®¹å™¨çº§å•ä¾‹çš„æ ¸å¿ƒé€»è¾‘
         */
        public Object getBean(String beanName) {
            // 1. å…ˆä»å•ä¾‹ç¼“å­˜ä¸­æŸ¥æ‰¾
            Object singleton = singletonObjects.get(beanName);
            
            if (singleton == null) {
                synchronized (this.singletonObjects) {
                    // 2. åŒé‡æ£€æŸ¥é”å®š
                    singleton = singletonObjects.get(beanName);
                    if (singleton == null) {
                        // 3. åˆ›å»ºæ–°çš„Beanå®ä¾‹
                        singleton = createBean(beanName);
                        // 4. æ”¾å…¥å•ä¾‹ç¼“å­˜
                        singletonObjects.put(beanName, singleton);
                    }
                }
            }
            
            return singleton;
        }
        
        private Object createBean(String beanName) {
            BeanDefinition definition = beanDefinitions.get(beanName);
            try {
                // ç®€åŒ–çš„Beanåˆ›å»ºé€»è¾‘
                Object instance = definition.getBeanClass().newInstance();
                // ä¾èµ–æ³¨å…¥
                injectDependencies(instance);
                return instance;
            } catch (Exception e) {
                throw new RuntimeException("åˆ›å»ºBeanå¤±è´¥: " + beanName, e);
            }
        }
        
        private void injectDependencies(Object instance) {
            // ç®€åŒ–çš„ä¾èµ–æ³¨å…¥é€»è¾‘
            // å®é™…Springä¼šå¤„ç†@Autowiredã€@Resourceç­‰æ³¨è§£
        }
    }
    
    /**
     * Beanå®šä¹‰ä¿¡æ¯
     */
    static class BeanDefinition {
        private Class<?> beanClass;
        private String scope = "singleton";  // é»˜è®¤å•ä¾‹
        
        // getters and setters
        public Class<?> getBeanClass() { return beanClass; }
        public void setBeanClass(Class<?> beanClass) { this.beanClass = beanClass; }
        public String getScope() { return scope; }
        public void setScope(String scope) { this.scope = scope; }
    }
}
```

### Springå•ä¾‹çš„ç‰¹ç‚¹

**1. å®¹å™¨çº§åˆ«çš„å•ä¾‹**
```java
@Component
public class UserService {
    // åœ¨æ•´ä¸ªSpringå®¹å™¨ä¸­åªæœ‰ä¸€ä¸ªå®ä¾‹
    // ä½†åœ¨ä¸åŒçš„JVMæˆ–ä¸åŒçš„ApplicationContextä¸­å¯ä»¥æœ‰å¤šä¸ªå®ä¾‹
}

/**
 * éªŒè¯Springå•ä¾‹ç‰¹æ€§
 */
@RestController
public class SingletonTestController {
    
    @Autowired
    private UserService userService1;
    
    @Autowired
    private UserService userService2;
    
    @GetMapping("/test-singleton")
    public String testSingleton() {
        // éªŒè¯æ˜¯å¦ä¸ºåŒä¸€ä¸ªå®ä¾‹
        boolean isSame = (userService1 == userService2);
        return "æ˜¯å¦ä¸ºåŒä¸€ä¸ªå®ä¾‹: " + isSame;  // è¾“å‡º: true
    }
}
```

**2. çº¿ç¨‹å…±äº«ç‰¹æ€§**
```java
@Service
public class SharedStateService {
    private int requestCount = 0;  // æ‰€æœ‰çº¿ç¨‹å…±äº«è¿™ä¸ªå˜é‡
    private String lastUser = "";  // æ‰€æœ‰çº¿ç¨‹å…±äº«è¿™ä¸ªå˜é‡
    
    public void processRequest(String username) {
        // å¤šä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œè¿™ä¸ªæ–¹æ³•æ—¶
        // éƒ½åœ¨æ“ä½œåŒä¸€ä¸ªrequestCountå’ŒlastUserå˜é‡
        requestCount++;  // çº¿ç¨‹ä¸å®‰å…¨ï¼
        lastUser = username;  // çº¿ç¨‹ä¸å®‰å…¨ï¼
    }
}
```

## ğŸ”§ å¤šçº¿ç¨‹å®‰å…¨é—®é¢˜åˆ†æ

### é—®é¢˜åœºæ™¯æ¼”ç¤º

```java
/**
 * Springå•ä¾‹Beanä¸­çš„çº¿ç¨‹å®‰å…¨é—®é¢˜æ¼”ç¤º
 */
@Service
public class UnsafeCounterService {
    
    private int counter = 0;  // å®ä¾‹å˜é‡ - å¤šçº¿ç¨‹å…±äº«
    
    /**
     * çº¿ç¨‹ä¸å®‰å…¨çš„é€’å¢æ“ä½œ
     */
    public void increment() {
        counter++;  // è¿™ä¸æ˜¯åŸå­æ“ä½œï¼
        /*
         * counter++ å®é™…åŒ…å«ä¸‰ä¸ªæ­¥éª¤ï¼š
         * 1. è¯»å–counterçš„å½“å‰å€¼ (read)
         * 2. å°†å€¼åŠ 1 (modify)  
         * 3. å°†ç»“æœå†™å›counter (write)
         * 
         * å¤šçº¿ç¨‹æ‰§è¡Œæ—¶å¯èƒ½çš„äº¤é”™æƒ…å†µï¼š
         * 
         * æ—¶é—´ | çº¿ç¨‹A | çº¿ç¨‹B | counterå€¼
         * -----|-------|-------|----------
         * T1   | è¯»å–0 |       | 0
         * T2   |       | è¯»å–0 | 0  
         * T3   | è®¡ç®—1 |       | 0
         * T4   |       | è®¡ç®—1 | 0
         * T5   | å†™å…¥1 |       | 1
         * T6   |       | å†™å…¥1 | 1
         * 
         * ç»“æœï¼šæœŸæœ›å€¼æ˜¯2ï¼Œå®é™…å€¼æ˜¯1
         */
    }
    
    public int getCounter() {
        return counter;  // è¯»å–æ“ä½œä¹Ÿå¯èƒ½ä¸ä¸€è‡´
    }
    
    /**
     * æ¼”ç¤ºæ›´å¤æ‚çš„çº¿ç¨‹å®‰å…¨é—®é¢˜
     */
    private String lastOperation = "";
    private long lastTimestamp = 0;
    
    public void recordOperation(String operation) {
        // å¤šä¸ªå­—æ®µçš„æ›´æ–°ä¸æ˜¯åŸå­çš„
        lastOperation = operation;    // æ­¥éª¤1
        // å¦‚æœåœ¨è¿™é‡Œå‘ç”Ÿçº¿ç¨‹åˆ‡æ¢...
        lastTimestamp = System.currentTimeMillis();  // æ­¥éª¤2
        
        // å…¶ä»–çº¿ç¨‹å¯èƒ½çœ‹åˆ°ä¸ä¸€è‡´çš„çŠ¶æ€ï¼š
        // lastOperationæ˜¯æ–°å€¼ï¼Œä½†lastTimestampè¿˜æ˜¯æ—§å€¼
    }
}
```

### å¹¶å‘æµ‹è¯•éªŒè¯

```java
/**
 * çº¿ç¨‹å®‰å…¨é—®é¢˜çš„æµ‹è¯•éªŒè¯
 */
@Component
public class ThreadSafetyTester {
    
    @Autowired
    private UnsafeCounterService counterService;
    
    /**
     * å¹¶å‘æµ‹è¯•æ–¹æ³•
     */
    public void testConcurrency() throws InterruptedException {
        int threadCount = 100;
        int incrementsPerThread = 1000;
        CountDownLatch latch = new CountDownLatch(threadCount);
        
        // åˆ›å»ºå¤šä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œincrementæ“ä½œ
        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < incrementsPerThread; j++) {
                        counterService.increment();
                    }
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        latch.await();
        
        int expectedValue = threadCount * incrementsPerThread;  // æœŸæœ›å€¼: 100,000
        int actualValue = counterService.getCounter();          // å®é™…å€¼: é€šå¸¸å°äº100,000
        
        System.out.printf("æœŸæœ›å€¼: %d, å®é™…å€¼: %d, æ•°æ®ä¸¢å¤±: %d%n", 
                         expectedValue, actualValue, expectedValue - actualValue);
    }
}
```

## ğŸ› ï¸ çº¿ç¨‹å®‰å…¨è§£å†³æ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€ï¼šsynchronizedå…³é”®å­—

```java
/**
 * ä½¿ç”¨synchronizedç¡®ä¿çº¿ç¨‹å®‰å…¨
 */
@Service
public class SynchronizedCounterService {
    
    private int counter = 0;
    
    /**
     * æ–¹æ³•çº§synchronized
     */
    public synchronized void increment() {
        counter++;  // ç°åœ¨æ˜¯çº¿ç¨‹å®‰å…¨çš„
    }
    
    public synchronized int getCounter() {
        return counter;
    }
    
    /**
     * ä»£ç å—çº§synchronized - æ›´ç»†ç²’åº¦çš„æ§åˆ¶
     */
    private final Object lock = new Object();
    
    public void incrementWithBlock() {
        synchronized (lock) {
            counter++;
        }
    }
    
    /**
     * ä¸åŒé”å¯¹è±¡çš„ä½¿ç”¨
     */
    private int readCount = 0;
    private int writeCount = 0;
    private final Object readLock = new Object();
    private final Object writeLock = new Object();
    
    public void incrementReadCount() {
        synchronized (readLock) {
            readCount++;
        }
    }
    
    public void incrementWriteCount() {
        synchronized (writeLock) {
            writeCount++;
        }
    }
}
```

**synchronizedçš„ä¼˜ç¼ºç‚¹åˆ†æï¼š**

âœ… **ä¼˜ç‚¹ï¼š**
- ç®€å•æ˜“ç”¨ï¼ŒJVMä¿è¯åŸå­æ€§
- è‡ªåŠ¨é‡Šæ”¾é”ï¼Œé¿å…æ­»é”
- å¯è§æ€§å’Œæœ‰åºæ€§éƒ½æœ‰ä¿éšœ

âŒ **ç¼ºç‚¹ï¼š**
- æ€§èƒ½å¼€é”€è¾ƒå¤§
- é˜»å¡å¼é”ï¼Œå¯èƒ½å¯¼è‡´çº¿ç¨‹é¥¥é¥¿
- æ— æ³•ä¸­æ–­ç­‰å¾…ä¸­çš„çº¿ç¨‹

### æ–¹æ¡ˆäºŒï¼šåŸå­ç±» (æ¨è)

```java
/**
 * ä½¿ç”¨åŸå­ç±»å®ç°é«˜æ€§èƒ½çº¿ç¨‹å®‰å…¨
 */
@Service
public class AtomicCounterService {
    
    // åŸå­æ•´æ•°
    private final AtomicInteger counter = new AtomicInteger(0);
    
    // åŸå­é•¿æ•´æ•°
    private final AtomicLong totalRequests = new AtomicLong(0);
    
    // åŸå­å¼•ç”¨
    private final AtomicReference<String> lastUser = new AtomicReference<>("");
    
    /**
     * åŸå­é€’å¢æ“ä½œ
     */
    public int increment() {
        return counter.incrementAndGet();  // åŸå­æ“ä½œï¼Œé«˜æ€§èƒ½
    }
    
    public int getCounter() {
        return counter.get();
    }
    
    /**
     * åŸå­çš„æ¯”è¾ƒå¹¶äº¤æ¢æ“ä½œ
     */
    public boolean updateLastUser(String expectedUser, String newUser) {
        return lastUser.compareAndSet(expectedUser, newUser);
    }
    
    /**
     * å¤æ‚çš„åŸå­æ“ä½œ
     */
    public void recordRequest(String username) {
        // åŸå­é€’å¢è¯·æ±‚è®¡æ•°
        totalRequests.incrementAndGet();
        
        // åŸå­æ›´æ–°æœ€åç”¨æˆ·
        lastUser.set(username);
    }
    
    /**
     * è‡ªå®šä¹‰åŸå­æ“ä½œ
     */
    public int addAndGetSquare(int delta) {
        return counter.updateAndGet(current -> {
            int newValue = current + delta;
            return newValue * newValue;  // è¿”å›å¹³æ–¹å€¼
        });
    }
    
    /**
     * åŸå­æ“ä½œçš„æ€§èƒ½æµ‹è¯•
     */
    public void performanceTest() throws InterruptedException {
        int threadCount = 100;
        int operationsPerThread = 10000;
        CountDownLatch latch = new CountDownLatch(threadCount);
        
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < operationsPerThread; j++) {
                        counter.incrementAndGet();
                    }
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        latch.await();
        long endTime = System.currentTimeMillis();
        
        System.out.printf("åŸå­æ“ä½œæµ‹è¯• - è€—æ—¶: %d ms, æœ€ç»ˆå€¼: %d%n", 
                         endTime - startTime, counter.get());
    }
}
```

### æ–¹æ¡ˆä¸‰ï¼šThreadLocal (çº¿ç¨‹éš”ç¦»)

```java
/**
 * ä½¿ç”¨ThreadLocalå®ç°çº¿ç¨‹éš”ç¦»
 */
@Service
public class ThreadLocalService {
    
    // æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„counterå‰¯æœ¬
    private final ThreadLocal<Integer> threadLocalCounter = new ThreadLocal<Integer>() {
        @Override
        protected Integer initialValue() {
            return 0;  // åˆå§‹å€¼
        }
    };
    
    // ä½¿ç”¨ThreadLocalå­˜å‚¨ç”¨æˆ·ä¸Šä¸‹æ–‡
    private final ThreadLocal<UserContext> userContextHolder = new ThreadLocal<>();
    
    /**
     * çº¿ç¨‹å®‰å…¨çš„é€’å¢æ“ä½œ - æ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹è®¡æ•°
     */
    public void increment() {
        Integer current = threadLocalCounter.get();
        threadLocalCounter.set(current + 1);
    }
    
    public int getCounter() {
        return threadLocalCounter.get();
    }
    
    /**
     * ç”¨æˆ·ä¸Šä¸‹æ–‡ç®¡ç†
     */
    public void setUserContext(String userId, String username) {
        UserContext context = new UserContext(userId, username);
        userContextHolder.set(context);
    }
    
    public UserContext getCurrentUserContext() {
        return userContextHolder.get();
    }
    
    /**
     * é‡è¦ï¼šæ¸…ç†ThreadLocalé˜²æ­¢å†…å­˜æ³„æ¼
     */
    public void clearContext() {
        threadLocalCounter.remove();
        userContextHolder.remove();
    }
    
    /**
     * ç”¨æˆ·ä¸Šä¸‹æ–‡ç±»
     */
    static class UserContext {
        private final String userId;
        private final String username;
        
        public UserContext(String userId, String username) {
            this.userId = userId;
            this.username = username;
        }
        
        // getters
        public String getUserId() { return userId; }
        public String getUsername() { return username; }
    }
    
    /**
     * Webè¯·æ±‚ä¸­çš„ThreadLocalä½¿ç”¨ç¤ºä¾‹
     */
    @Component
    public static class UserContextFilter implements Filter {
        
        @Autowired
        private ThreadLocalService threadLocalService;
        
        @Override
        public void doFilter(ServletRequest request, ServletResponse response, 
                           FilterChain chain) throws IOException, ServletException {
            try {
                // ä»è¯·æ±‚ä¸­æå–ç”¨æˆ·ä¿¡æ¯
                String userId = request.getParameter("userId");
                String username = request.getParameter("username");
                
                // è®¾ç½®åˆ°ThreadLocalä¸­
                if (userId != null && username != null) {
                    threadLocalService.setUserContext(userId, username);
                }
                
                // ç»§ç»­å¤„ç†è¯·æ±‚
                chain.doFilter(request, response);
                
            } finally {
                // è¯·æ±‚ç»“æŸåæ¸…ç†ThreadLocal
                threadLocalService.clearContext();
            }
        }
    }
}
```

### æ–¹æ¡ˆå››ï¼švolatileå…³é”®å­— (æœ‰é™åœºæ™¯)

```java
/**
 * volatileçš„æ­£ç¡®ä½¿ç”¨åœºæ™¯
 */
@Service
public class VolatileService {
    
    // volatileé€‚ç”¨äºç®€å•çš„æ ‡å¿—ä½
    private volatile boolean initialized = false;
    private volatile boolean shutdown = false;
    
    // volatileä¸é€‚ç”¨äºå¤åˆæ“ä½œ
    private volatile int counter = 0;  // ä¸å®‰å…¨ï¼counter++ä¸æ˜¯åŸå­æ“ä½œ
    
    /**
     * æ­£ç¡®ä½¿ç”¨volatileçš„åœºæ™¯ï¼šçŠ¶æ€æ ‡å¿—
     */
    public void initialize() {
        // æ‰§è¡Œåˆå§‹åŒ–é€»è¾‘
        performInitialization();
        
        // è®¾ç½®æ ‡å¿—ä½ - å¯¹æ‰€æœ‰çº¿ç¨‹ç«‹å³å¯è§
        initialized = true;
    }
    
    public boolean isInitialized() {
        return initialized;  // è¯»å–æœ€æ–°å€¼
    }
    
    /**
     * é”™è¯¯ä½¿ç”¨volatileçš„åœºæ™¯ï¼šå¤åˆæ“ä½œ
     */
    public void unsafeIncrement() {
        counter++;  // ä»ç„¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼
        // volatileåªä¿è¯å¯è§æ€§ï¼Œä¸ä¿è¯åŸå­æ€§
    }
    
    /**
     * æ­£ç¡®çš„åšæ³•ï¼šç»“åˆCASæ“ä½œ
     */
    private final AtomicInteger atomicCounter = new AtomicInteger(0);
    
    public int safeIncrement() {
        return atomicCounter.incrementAndGet();
    }
    
    private void performInitialization() {
        // æ¨¡æ‹Ÿåˆå§‹åŒ–è¿‡ç¨‹
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

## ğŸ“‹ æœ€ä½³å®è·µä¸è®¾è®¡åŸåˆ™

### 1. æ— çŠ¶æ€è®¾è®¡ (é¦–é€‰æ–¹æ¡ˆ)

```java
/**
 * æ— çŠ¶æ€Serviceè®¾è®¡ - æœ€ä½³å®è·µ
 */
@Service
public class StatelessUserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    /**
     * æ— çŠ¶æ€æ–¹æ³• - å¤©ç„¶çº¿ç¨‹å®‰å…¨
     * æ‰€æœ‰æ•°æ®é€šè¿‡å‚æ•°ä¼ å…¥ï¼Œé€šè¿‡è¿”å›å€¼ä¼ å‡º
     */
    public UserDTO createUser(CreateUserRequest request) {
        // 1. éªŒè¯è¾“å…¥å‚æ•°
        validateUserRequest(request);
        
        // 2. åˆ›å»ºç”¨æˆ·å®ä½“
        User user = new User();
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        user.setCreatedTime(LocalDateTime.now());
        
        // 3. ä¿å­˜åˆ°æ•°æ®åº“
        User savedUser = userRepository.save(user);
        
        // 4. å‘é€æ¬¢è¿é‚®ä»¶
        emailService.sendWelcomeEmail(savedUser.getEmail());
        
        // 5. è¿”å›DTO
        return convertToDTO(savedUser);
    }
    
    /**
     * æŸ¥è¯¢æ–¹æ³• - æ— çŠ¶æ€
     */
    public List<UserDTO> findUsersByDepartment(String department) {
        List<User> users = userRepository.findByDepartment(department);
        return users.stream()
                   .map(this::convertToDTO)
                   .collect(Collectors.toList());
    }
    
    private void validateUserRequest(CreateUserRequest request) {
        if (request.getUsername() == null || request.getUsername().trim().isEmpty()) {
            throw new IllegalArgumentException("ç”¨æˆ·åä¸èƒ½ä¸ºç©º");
        }
        // å…¶ä»–éªŒè¯é€»è¾‘...
    }
    
    private UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());
        return dto;
    }
}
```

### 2. ä¸å¯å˜å¯¹è±¡è®¾è®¡

```java
/**
 * ä¸å¯å˜å¯¹è±¡ - å¤©ç„¶çº¿ç¨‹å®‰å…¨
 */
public final class ImmutableUserInfo {
    private final String userId;
    private final String username;
    private final String email;
    private final LocalDateTime createdTime;
    private final List<String> roles;
    
    public ImmutableUserInfo(String userId, String username, String email, 
                           LocalDateTime createdTime, List<String> roles) {
        this.userId = userId;
        this.username = username;
        this.email = email;
        this.createdTime = createdTime;
        // é˜²å¾¡æ€§æ‹·è´
        this.roles = Collections.unmodifiableList(new ArrayList<>(roles));
    }
    
    // åªæä¾›getteræ–¹æ³•ï¼Œæ²¡æœ‰setter
    public String getUserId() { return userId; }
    public String getUsername() { return username; }
    public String getEmail() { return email; }
    public LocalDateTime getCreatedTime() { return createdTime; }
    public List<String> getRoles() { return roles; }
    
    /**
     * åˆ›å»ºä¿®æ”¹åçš„æ–°å¯¹è±¡ï¼ˆè€Œä¸æ˜¯ä¿®æ”¹å½“å‰å¯¹è±¡ï¼‰
     */
    public ImmutableUserInfo withEmail(String newEmail) {
        return new ImmutableUserInfo(userId, username, newEmail, createdTime, roles);
    }
    
    public ImmutableUserInfo addRole(String role) {
        List<String> newRoles = new ArrayList<>(roles);
        newRoles.add(role);
        return new ImmutableUserInfo(userId, username, email, createdTime, newRoles);
    }
}

/**
 * ä½¿ç”¨ä¸å¯å˜å¯¹è±¡çš„Service
 */
@Service
public class ImmutableUserService {
    
    private final Map<String, ImmutableUserInfo> userCache = new ConcurrentHashMap<>();
    
    public void cacheUser(ImmutableUserInfo userInfo) {
        // ä¸å¯å˜å¯¹è±¡å¯ä»¥å®‰å…¨åœ°åœ¨å¤šçº¿ç¨‹é—´å…±äº«
        userCache.put(userInfo.getUserId(), userInfo);
    }
    
    public ImmutableUserInfo getUser(String userId) {
        return userCache.get(userId);
    }
    
    public void updateUserEmail(String userId, String newEmail) {
        userCache.computeIfPresent(userId, (key, oldUserInfo) -> 
            oldUserInfo.withEmail(newEmail)  // åˆ›å»ºæ–°å¯¹è±¡
        );
    }
}
```

### 3. åˆç†ä½¿ç”¨ç¼“å­˜

```java
/**
 * çº¿ç¨‹å®‰å…¨çš„ç¼“å­˜å®ç°
 */
@Service
public class ThreadSafeCacheService {
    
    // ä½¿ç”¨ConcurrentHashMapå®ç°çº¿ç¨‹å®‰å…¨ç¼“å­˜
    private final ConcurrentHashMap<String, UserDTO> userCache = new ConcurrentHashMap<>();
    
    // ç¼“å­˜è¿‡æœŸæ—¶é—´ç®¡ç†
    private final ConcurrentHashMap<String, Long> cacheTimestamps = new ConcurrentHashMap<>();
    
    private static final long CACHE_TTL = 5 * 60 * 1000; // 5åˆ†é’Ÿ
    
    @Autowired
    private UserRepository userRepository;
    
    /**
     * çº¿ç¨‹å®‰å…¨çš„ç¼“å­˜è·å–
     */
    public UserDTO getUser(String userId) {
        // æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ
        if (isCacheExpired(userId)) {
            removeFromCache(userId);
        }
        
        // ä½¿ç”¨computeIfAbsentåŸå­æ“ä½œ
        return userCache.computeIfAbsent(userId, this::loadUserFromDatabase);
    }
    
    /**
     * åŸå­çš„ç¼“å­˜æ›´æ–°æ“ä½œ
     */
    public void updateUser(String userId, UserDTO userDTO) {
        userCache.put(userId, userDTO);
        cacheTimestamps.put(userId, System.currentTimeMillis());
        
        // åŒæ—¶æ›´æ–°æ•°æ®åº“
        updateUserInDatabase(userDTO);
    }
    
    /**
     * å®‰å…¨çš„ç¼“å­˜æ¸…ç†
     */
    public void evictExpiredEntries() {
        long currentTime = System.currentTimeMillis();
        
        // æ‰¾å‡ºè¿‡æœŸçš„é”®
        Set<String> expiredKeys = cacheTimestamps.entrySet().stream()
            .filter(entry -> currentTime - entry.getValue() > CACHE_TTL)
            .map(Map.Entry::getKey)
            .collect(Collectors.toSet());
        
        // æ‰¹é‡æ¸…ç†
        expiredKeys.forEach(this::removeFromCache);
    }
    
    private boolean isCacheExpired(String userId) {
        Long timestamp = cacheTimestamps.get(userId);
        return timestamp == null || 
               (System.currentTimeMillis() - timestamp) > CACHE_TTL;
    }
    
    private void removeFromCache(String userId) {
        userCache.remove(userId);
        cacheTimestamps.remove(userId);
    }
    
    private UserDTO loadUserFromDatabase(String userId) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException("ç”¨æˆ·ä¸å­˜åœ¨: " + userId));
        
        UserDTO dto = convertToDTO(user);
        
        // è®°å½•ç¼“å­˜æ—¶é—´
        cacheTimestamps.put(userId, System.currentTimeMillis());
        
        return dto;
    }
    
    private void updateUserInDatabase(UserDTO userDTO) {
        // æ›´æ–°æ•°æ®åº“çš„é€»è¾‘
        User user = userRepository.findById(userDTO.getId())
            .orElseThrow(() -> new UserNotFoundException("ç”¨æˆ·ä¸å­˜åœ¨"));
        
        user.setUsername(userDTO.getUsername());
        user.setEmail(userDTO.getEmail());
        userRepository.save(user);
    }
    
    private UserDTO convertToDTO(User user) {
        // è½¬æ¢é€»è¾‘
        return new UserDTO(user.getId(), user.getUsername(), user.getEmail());
    }
}
```

### 4. å¼‚æ­¥å¤„ç†æ¨¡å¼

```java
/**
 * å¼‚æ­¥å¤„ç†é¿å…çº¿ç¨‹å®‰å…¨é—®é¢˜
 */
@Service
public class AsyncProcessingService {
    
    @Async("taskExecutor")
    public CompletableFuture<String> processUserDataAsync(String userId) {
        try {
            // æ¯ä¸ªå¼‚æ­¥ä»»åŠ¡éƒ½æœ‰è‡ªå·±çš„çº¿ç¨‹æ ˆ
            // é¿å…äº†å…±äº«çŠ¶æ€çš„çº¿ç¨‹å®‰å…¨é—®é¢˜
            String result = processUserData(userId);
            return CompletableFuture.completedFuture(result);
        } catch (Exception e) {
            CompletableFuture<String> future = new CompletableFuture<>();
            future.completeExceptionally(e);
            return future;
        }
    }
    
    /**
     * æ‰¹é‡å¼‚æ­¥å¤„ç†
     */
    public CompletableFuture<List<String>> processMultipleUsersAsync(List<String> userIds) {
        List<CompletableFuture<String>> futures = userIds.stream()
            .map(this::processUserDataAsync)
            .collect(Collectors.toList());
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList()));
    }
    
    private String processUserData(String userId) {
        // æ¨¡æ‹Ÿè€—æ—¶å¤„ç†
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("å¤„ç†è¢«ä¸­æ–­", e);
        }
        return "å¤„ç†å®Œæˆ: " + userId;
    }
}
```

## âš¡ æ€§èƒ½å¯¹æ¯”ä¸é€‰æ‹©æŒ‡å—

### æ€§èƒ½æµ‹è¯•å¯¹æ¯”

```java
/**
 * ä¸åŒçº¿ç¨‹å®‰å…¨æ–¹æ¡ˆçš„æ€§èƒ½æµ‹è¯•
 */
@Component
public class PerformanceComparison {
    
    public void comparePerformance() throws InterruptedException {
        int threadCount = 100;
        int operationsPerThread = 100000;
        
        System.out.println("=== çº¿ç¨‹å®‰å…¨æ–¹æ¡ˆæ€§èƒ½å¯¹æ¯” ===");
        
        // 1. synchronizedæ–¹æ³•æµ‹è¯•
        testSynchronizedPerformance(threadCount, operationsPerThread);
        
        // 2. AtomicIntegeræµ‹è¯•
        testAtomicPerformance(threadCount, operationsPerThread);
        
        // 3. ThreadLocalæµ‹è¯•
        testThreadLocalPerformance(threadCount, operationsPerThread);
        
        // 4. æ— é”è®¾è®¡æµ‹è¯•
        testLockFreePerformance(threadCount, operationsPerThread);
    }
    
    private void testSynchronizedPerformance(int threadCount, int operations) 
            throws InterruptedException {
        SynchronizedCounter counter = new SynchronizedCounter();
        long startTime = System.currentTimeMillis();
        
        CountDownLatch latch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < operations; j++) {
                        counter.increment();
                    }
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        latch.await();
        long endTime = System.currentTimeMillis();
        
        System.out.printf("Synchronized: %d ms, ç»“æœ: %d%n", 
                         endTime - startTime, counter.getValue());
    }
    
    private void testAtomicPerformance(int threadCount, int operations) 
            throws InterruptedException {
        AtomicInteger counter = new AtomicInteger(0);
        long startTime = System.currentTimeMillis();
        
        CountDownLatch latch = new CountDownLatch(threadCount);
        for (int i = 0; i < threadCount; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < operations; j++) {
                        counter.incrementAndGet();
                    }
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        
        latch.await();
        long endTime = System.currentTimeMillis();
        
        System.out.printf("AtomicInteger: %d ms, ç»“æœ: %d%n", 
                         endTime - startTime, counter.get());
    }
    
    // è¾…åŠ©ç±»
    static class SynchronizedCounter {
        private int value = 0;
        
        public synchronized void increment() {
            value++;
        }
        
        public synchronized int getValue() {
            return value;
        }
    }
}
```

### é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | åŸå›  |
|------|----------|------|
| ç®€å•è®¡æ•°å™¨ | AtomicInteger | é«˜æ€§èƒ½ï¼Œæ— é”å®ç° |
| çŠ¶æ€æ ‡å¿— | volatile | è½»é‡çº§ï¼Œé€‚åˆç®€å•æ ‡å¿—ä½ |
| å¤æ‚ä¸šåŠ¡é€»è¾‘ | æ— çŠ¶æ€è®¾è®¡ | å¤©ç„¶çº¿ç¨‹å®‰å…¨ï¼Œæ˜“ç»´æŠ¤ |
| ç”¨æˆ·ä¸Šä¸‹æ–‡ | ThreadLocal | çº¿ç¨‹éš”ç¦»ï¼Œé¿å…å‚æ•°ä¼ é€’ |
| ç¼“å­˜åœºæ™¯ | ConcurrentHashMap | é«˜å¹¶å‘è¯»å†™æ€§èƒ½ |
| ä½é¢‘æ›´æ–° | synchronized | ç®€å•å¯é ï¼Œé€‚åˆä½å¹¶å‘ |

## ğŸ¯ æ€»ç»“ä¸å»ºè®®

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **Springå•ä¾‹æœ¬è´¨**ï¼šå®¹å™¨çº§å•ä¾‹ï¼Œæ‰€æœ‰æ³¨å…¥ç‚¹å…±äº«åŒä¸€å®ä¾‹
2. **çº¿ç¨‹å®‰å…¨é—®é¢˜**ï¼šå®ä¾‹å˜é‡åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹å­˜åœ¨ç«æ€æ¡ä»¶
3. **è§£å†³æ–¹æ¡ˆä¼˜å…ˆçº§**ï¼šæ— çŠ¶æ€è®¾è®¡ > åŸå­ç±» > ThreadLocal > synchronized
4. **æ€§èƒ½è€ƒé‡**ï¼šåŸå­ç±» > ThreadLocal > synchronized > é‡é‡çº§é”

### æœ€ä½³å®è·µå»ºè®®

âœ… **æ¨èåšæ³•ï¼š**
- ä¼˜å…ˆè®¾è®¡æ— çŠ¶æ€çš„Service
- ä½¿ç”¨ä¸å¯å˜å¯¹è±¡ä¼ é€’æ•°æ®
- åˆç†ä½¿ç”¨åŸå­ç±»å¤„ç†ç®€å•è®¡æ•°
- ThreadLocalç”¨äºç”¨æˆ·ä¸Šä¸‹æ–‡éš”ç¦»
- åŠæ—¶æ¸…ç†ThreadLocalé˜²æ­¢å†…å­˜æ³„æ¼

âŒ **é¿å…åšæ³•ï¼š**
- åœ¨å•ä¾‹Beanä¸­ä½¿ç”¨å¯å˜çš„å®ä¾‹å˜é‡
- è¿‡åº¦ä½¿ç”¨synchronizedå¯¼è‡´æ€§èƒ½é—®é¢˜
- å¿½ç•¥ThreadLocalçš„å†…å­˜æ³„æ¼é£é™©
- å°†çº¿ç¨‹å®‰å…¨é—®é¢˜ç•™ç»™ä½¿ç”¨è€…å¤„ç†

### é¢è¯•è¦ç‚¹

**å¸¸è§é¢è¯•é—®é¢˜ï¼š**

1. **Spring Beané»˜è®¤æ˜¯å•ä¾‹çš„ï¼Œå¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Ÿ**
   - ç­”æ¡ˆï¼šé€šè¿‡æ— çŠ¶æ€è®¾è®¡ã€åŸå­ç±»ã€ThreadLocalç­‰æ–¹å¼

2. **Springå•ä¾‹å’ŒSingletonæ¨¡å¼æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ**
   - ç­”æ¡ˆï¼šSpringæ˜¯å®¹å™¨çº§å•ä¾‹ï¼ŒSingletonæ˜¯JVMçº§å•ä¾‹

3. **ä»€ä¹ˆæƒ…å†µä¸‹Spring Beanä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Ÿ**
   - ç­”æ¡ˆï¼šBeanä¸­æœ‰å¯å˜çš„å®ä¾‹å˜é‡æ—¶

4. **å¦‚ä½•è§£å†³Springå•ä¾‹Beançš„çº¿ç¨‹å®‰å…¨é—®é¢˜ï¼Ÿ**
   - ç­”æ¡ˆï¼šå¤šç§æ–¹æ¡ˆå¯¹æ¯”ï¼Œé‡ç‚¹è¯´æ˜æ— çŠ¶æ€è®¾è®¡çš„ä¼˜åŠ¿

é€šè¿‡æ·±å…¥ç†è§£Springå•ä¾‹æ¨¡å¼çš„æœ¬è´¨å’Œçº¿ç¨‹å®‰å…¨æœºåˆ¶ï¼Œæˆ‘ä»¬èƒ½å¤Ÿç¼–å†™å‡ºæ—¢é«˜æ•ˆåˆå®‰å…¨çš„Springåº”ç”¨ç¨‹åºã€‚è®°ä½ï¼Œ**æ— çŠ¶æ€è®¾è®¡æ˜¯æœ€ä½³å®è·µ**ï¼Œå®ƒä¸ä»…è§£å†³äº†çº¿ç¨‹å®‰å…¨é—®é¢˜ï¼Œè¿˜è®©ä»£ç æ›´åŠ æ¸…æ™°å’Œæ˜“äºæµ‹è¯•ã€‚
