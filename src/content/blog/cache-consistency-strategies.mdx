---
title: "ç¼“å­˜ä¸€è‡´æ€§ç­–ç•¥ä¸åˆ†å¸ƒå¼ç¼“å­˜è®¾è®¡æ·±åº¦è§£æ"
description: "æ·±å…¥æ¢è®¨ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜çš„æ ¹æœ¬åŸå› ã€è§£å†³ç­–ç•¥å’Œåˆ†å¸ƒå¼ç¼“å­˜è®¾è®¡æœ€ä½³å®è·µï¼Œç»“åˆå®é™…é¡¹ç›®ç»éªŒåˆ†äº«ç¼“å­˜æ¶æ„è®¾è®¡è¦ç‚¹ã€‚"
pubDate: 2024-12-28
updatedDate: 2024-12-28
tags: ["cache", "consistency", "distributed", "redis", "performance", "interview", "best-practices"]
categories: ["middleware"]
subject: "åˆ†å¸ƒå¼ç¼“å­˜æ¶æ„"
draft: false
featured: true
author: "Gerrad Zhang"
location: "æ­¦æ±‰ï¼Œä¸­å›½"
---

## ğŸ¤” é—®é¢˜èƒŒæ™¯ä¸æŠ€æœ¯æ¼”è¿›

### æˆ‘ä»¬è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œç¼“å­˜ä¸€è‡´æ€§æ˜¯ä¸€ä¸ªæ ¸å¿ƒæŒ‘æˆ˜ã€‚å½“æ•°æ®å­˜å‚¨åœ¨å¤šä¸ªç¼“å­˜å±‚çº§å’Œæ•°æ®åº“ä¸­æ—¶ï¼Œå¦‚ä½•ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§æˆä¸ºå…³é”®é—®é¢˜ï¼š

- **æ•°æ®ä¸ä¸€è‡´é£é™©**ï¼šç¼“å­˜ä¸æ•°æ®åº“æ•°æ®ä¸åŒæ­¥ï¼Œç”¨æˆ·çœ‹åˆ°è¿‡æœŸæ•°æ®
- **å¹¶å‘æ›´æ–°å†²çª**ï¼šå¤šä¸ªæœåŠ¡åŒæ—¶æ›´æ–°åŒä¸€ä»½æ•°æ®ï¼Œå¯¼è‡´æ•°æ®è¦†ç›–
- **åˆ†å¸ƒå¼ç¯å¢ƒå¤æ‚æ€§**ï¼šå¤šä¸ªç¼“å­˜èŠ‚ç‚¹é—´æ•°æ®åŒæ­¥å›°éš¾
- **æ€§èƒ½ä¸ä¸€è‡´æ€§æƒè¡¡**ï¼šå¼ºä¸€è‡´æ€§å¾€å¾€ä»¥ç‰ºç‰²æ€§èƒ½ä¸ºä»£ä»·

### æ²¡æœ‰ç¼“å­˜ä¸€è‡´æ€§ç­–ç•¥æ—¶æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ

æ—©æœŸç³»ç»Ÿé€šå¸¸é‡‡ç”¨ç®€å•ç²—æš´çš„æ–¹å¼ï¼š

```java
// ä¼ ç»Ÿåšæ³•ï¼šç›´æ¥æ“ä½œæ•°æ®åº“ï¼Œæ€§èƒ½å·®
public User getUserById(Long userId) {
    return userMapper.selectById(userId); // æ¯æ¬¡éƒ½æŸ¥æ•°æ®åº“
}

public void updateUser(User user) {
    userMapper.updateById(user); // ç›´æ¥æ›´æ–°æ•°æ®åº“
}
```

**ä¼ ç»Ÿæ–¹æ¡ˆçš„é—®é¢˜**ï¼š
- æ•°æ®åº“å‹åŠ›å·¨å¤§ï¼ŒQPSå—é™
- å“åº”æ—¶é—´é•¿ï¼Œç”¨æˆ·ä½“éªŒå·®
- æ— æ³•æ”¯æ’‘é«˜å¹¶å‘åœºæ™¯
- æ•°æ®åº“æˆä¸ºç³»ç»Ÿç“¶é¢ˆ

### æŠ€æœ¯æ¼”è¿›çš„å†å²è„‰ç»œ

ç¼“å­˜ä¸€è‡´æ€§è§£å†³æ–¹æ¡ˆçš„å‘å±•å†ç¨‹ï¼š

1. **å•æœºç¼“å­˜æ—¶ä»£**ï¼ˆ2000-2005ï¼‰ï¼šæœ¬åœ°ç¼“å­˜ï¼Œä¸€è‡´æ€§é—®é¢˜ç›¸å¯¹ç®€å•
2. **åˆ†å¸ƒå¼ç¼“å­˜å…´èµ·**ï¼ˆ2005-2010ï¼‰ï¼šMemcachedæ™®åŠï¼Œå¼€å§‹é¢ä¸´åˆ†å¸ƒå¼ä¸€è‡´æ€§
3. **Redisç”Ÿæ€å‘å±•**ï¼ˆ2010-2015ï¼‰ï¼šæ›´ä¸°å¯Œçš„æ•°æ®ç»“æ„å’ŒæŒä¹…åŒ–æ–¹æ¡ˆ
4. **å¾®æœåŠ¡æ¶æ„**ï¼ˆ2015-2020ï¼‰ï¼šæœåŠ¡æ‹†åˆ†å¸¦æ¥æ›´å¤æ‚çš„ç¼“å­˜ä¸€è‡´æ€§æŒ‘æˆ˜
5. **äº‘åŸç”Ÿæ—¶ä»£**ï¼ˆ2020è‡³ä»Šï¼‰ï¼šService Meshã€è¾¹ç¼˜ç¼“å­˜ç­‰æ–°æ¶æ„æ¨¡å¼

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µä¸åŸç†

### ç¼“å­˜ä¸€è‡´æ€§åŸºæœ¬æ¦‚å¿µ

**ç¼“å­˜ä¸€è‡´æ€§**æ˜¯æŒ‡ç¼“å­˜ä¸­çš„æ•°æ®ä¸æ•°æ®æºï¼ˆé€šå¸¸æ˜¯æ•°æ®åº“ï¼‰ä¸­çš„æ•°æ®ä¿æŒåŒæ­¥çš„ç¨‹åº¦ã€‚æ ¹æ®ä¸€è‡´æ€§å¼ºåº¦ï¼Œå¯åˆ†ä¸ºï¼š

```java
// å¼ºä¸€è‡´æ€§ï¼šè¯»å–æ—¶ç«‹å³åæ˜ æœ€æ–°å†™å…¥
public interface StrongConsistency {
    // å†™å…¥åç«‹å³å¯è¯»å–åˆ°æœ€æ–°å€¼
    void write(String key, String value);
    String read(String key); // æ€»æ˜¯è¿”å›æœ€æ–°å€¼
}

// æœ€ç»ˆä¸€è‡´æ€§ï¼šå…è®¸çŸ­æœŸä¸ä¸€è‡´ï¼Œä½†æœ€ç»ˆä¼šæ”¶æ•›
public interface EventualConsistency {
    // å†™å…¥åå¯èƒ½éœ€è¦ä¸€æ®µæ—¶é—´æ‰èƒ½è¯»å–åˆ°æœ€æ–°å€¼
    void write(String key, String value);
    String read(String key); // å¯èƒ½è¿”å›æ—§å€¼
}

// å¼±ä¸€è‡´æ€§ï¼šä¸ä¿è¯ä½•æ—¶èƒ½è¯»åˆ°æœ€æ–°å€¼
public interface WeakConsistency {
    void write(String key, String value);
    String read(String key); // å¯èƒ½æ°¸è¿œè¯»ä¸åˆ°æœ€æ–°å€¼
}
```

### CAPç†è®ºåœ¨ç¼“å­˜è®¾è®¡ä¸­çš„åº”ç”¨

æ ¹æ®CAPç†è®ºï¼Œåˆ†å¸ƒå¼ç³»ç»Ÿåªèƒ½åŒæ—¶æ»¡è¶³ä»¥ä¸‹ä¸‰ä¸ªç‰¹æ€§ä¸­çš„ä¸¤ä¸ªï¼š

- **Consistencyï¼ˆä¸€è‡´æ€§ï¼‰**ï¼šæ‰€æœ‰èŠ‚ç‚¹åŒæ—¶çœ‹åˆ°ç›¸åŒæ•°æ®
- **Availabilityï¼ˆå¯ç”¨æ€§ï¼‰**ï¼šç³»ç»ŸæŒç»­å¯ç”¨
- **Partition toleranceï¼ˆåˆ†åŒºå®¹é”™æ€§ï¼‰**ï¼šç½‘ç»œåˆ†åŒºæ—¶ç³»ç»Ÿç»§ç»­å·¥ä½œ

### ç¼“å­˜ä¸€è‡´æ€§æ¨¡å‹

```java
public enum ConsistencyModel {
    STRONG_CONSISTENCY,    // å¼ºä¸€è‡´æ€§
    SEQUENTIAL_CONSISTENCY, // é¡ºåºä¸€è‡´æ€§
    CAUSAL_CONSISTENCY,    // å› æœä¸€è‡´æ€§
    EVENTUAL_CONSISTENCY,  // æœ€ç»ˆä¸€è‡´æ€§
    WEAK_CONSISTENCY      // å¼±ä¸€è‡´æ€§
}
```

## ğŸ”§ å®ç°åŸç†ä¸æºç åˆ†æ

### Cache-Asideæ¨¡å¼å®ç°

Cache-Asideæ˜¯æœ€å¸¸ç”¨çš„ç¼“å­˜æ¨¡å¼ï¼Œåº”ç”¨ç¨‹åºç›´æ¥ç®¡ç†ç¼“å­˜ï¼š

```java
@Service
public class UserServiceImpl implements UserService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private UserMapper userMapper;
    
    private static final String USER_CACHE_PREFIX = "user:";
    private static final int CACHE_TTL = 3600; // 1å°æ—¶
    
    /**
     * Cache-Asideæ¨¡å¼è¯»å–
     */
    @Override
    public User getUserById(Long userId) {
        String cacheKey = USER_CACHE_PREFIX + userId;
        
        // 1. å…ˆæŸ¥ç¼“å­˜
        User user = (User) redisTemplate.opsForValue().get(cacheKey);
        if (user != null) {
            return user;
        }
        
        // 2. ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢æ•°æ®åº“
        user = userMapper.selectById(userId);
        if (user != null) {
            // 3. å†™å…¥ç¼“å­˜
            redisTemplate.opsForValue().set(cacheKey, user, CACHE_TTL, TimeUnit.SECONDS);
        }
        
        return user;
    }
    
    /**
     * Cache-Asideæ¨¡å¼æ›´æ–°
     */
    @Override
    @Transactional
    public void updateUser(User user) {
        // 1. å…ˆæ›´æ–°æ•°æ®åº“
        userMapper.updateById(user);
        
        // 2. åˆ é™¤ç¼“å­˜ï¼ˆè€Œä¸æ˜¯æ›´æ–°ç¼“å­˜ï¼‰
        String cacheKey = USER_CACHE_PREFIX + user.getId();
        redisTemplate.delete(cacheKey);
    }
}
```

### Write-Throughæ¨¡å¼å®ç°

Write-Throughæ¨¡å¼ä¸­ï¼Œç¼“å­˜å±‚è´Ÿè´£æ•°æ®çš„è¯»å†™ï¼š

```java
@Component
public class WriteThroughCache {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private UserMapper userMapper;
    
    /**
     * Write-Throughå†™å…¥
     */
    public void writeThrough(String key, User user) {
        try {
            // 1. åŒæ—¶å†™å…¥ç¼“å­˜å’Œæ•°æ®åº“
            CompletableFuture<Void> cacheWrite = CompletableFuture.runAsync(() -> {
                redisTemplate.opsForValue().set(key, user);
            });
            
            CompletableFuture<Void> dbWrite = CompletableFuture.runAsync(() -> {
                userMapper.updateById(user);
            });
            
            // 2. ç­‰å¾…ä¸¤ä¸ªæ“ä½œéƒ½å®Œæˆ
            CompletableFuture.allOf(cacheWrite, dbWrite).get();
            
        } catch (Exception e) {
            // å›æ»šæ“ä½œ
            rollbackWrite(key, user);
            throw new RuntimeException("Write-through failed", e);
        }
    }
    
    private void rollbackWrite(String key, User user) {
        // å®ç°å›æ»šé€»è¾‘
        redisTemplate.delete(key);
    }
}
```

### Write-Behindæ¨¡å¼å®ç°

Write-Behindï¼ˆWrite-Backï¼‰æ¨¡å¼å¼‚æ­¥å†™å…¥æ•°æ®åº“ï¼š

```java
@Component
public class WriteBehindCache {
    
    private final BlockingQueue<WriteOperation> writeQueue = new LinkedBlockingQueue<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
    
    @PostConstruct
    public void init() {
        // å¯åŠ¨å¼‚æ­¥å†™å…¥çº¿ç¨‹
        scheduler.scheduleAtFixedRate(this::processWriteQueue, 0, 1, TimeUnit.SECONDS);
    }
    
    /**
     * Write-Behindå†™å…¥
     */
    public void writeBehind(String key, User user) {
        // 1. ç«‹å³å†™å…¥ç¼“å­˜
        redisTemplate.opsForValue().set(key, user);
        
        // 2. å¼‚æ­¥å†™å…¥æ•°æ®åº“
        WriteOperation operation = new WriteOperation(key, user, System.currentTimeMillis());
        writeQueue.offer(operation);
    }
    
    private void processWriteQueue() {
        List<WriteOperation> batch = new ArrayList<>();
        writeQueue.drainTo(batch, 100); // æ‰¹é‡å¤„ç†
        
        if (!batch.isEmpty()) {
            batchWriteToDatabase(batch);
        }
    }
    
    private void batchWriteToDatabase(List<WriteOperation> operations) {
        try {
            List<User> users = operations.stream()
                .map(WriteOperation::getUser)
                .collect(Collectors.toList());
            
            userMapper.batchUpdate(users);
            
        } catch (Exception e) {
            // å†™å…¥å¤±è´¥ï¼Œé‡æ–°å…¥é˜Ÿ
            operations.forEach(op -> writeQueue.offer(op));
        }
    }
}
```

### åˆ†å¸ƒå¼é”ä¿è¯ä¸€è‡´æ€§

ä½¿ç”¨Redisåˆ†å¸ƒå¼é”é˜²æ­¢å¹¶å‘æ›´æ–°ï¼š

```java
@Component
public class DistributedLockCache {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String LOCK_PREFIX = "lock:";
    private static final int LOCK_TIMEOUT = 30; // 30ç§’
    
    /**
     * ä½¿ç”¨åˆ†å¸ƒå¼é”çš„ç¼“å­˜æ›´æ–°
     */
    public void updateWithLock(Long userId, User user) {
        String lockKey = LOCK_PREFIX + userId;
        String lockValue = UUID.randomUUID().toString();
        
        try {
            // 1. è·å–åˆ†å¸ƒå¼é”
            if (acquireLock(lockKey, lockValue)) {
                // 2. æ‰§è¡Œæ›´æ–°æ“ä½œ
                updateUserSafely(userId, user);
            } else {
                throw new RuntimeException("Failed to acquire lock");
            }
        } finally {
            // 3. é‡Šæ”¾é”
            releaseLock(lockKey, lockValue);
        }
    }
    
    private boolean acquireLock(String lockKey, String lockValue) {
        Boolean success = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, lockValue, LOCK_TIMEOUT, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);
    }
    
    private void releaseLock(String lockKey, String lockValue) {
        String script = 
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "  return redis.call('del', KEYS[1]) " +
            "else " +
            "  return 0 " +
            "end";
        
        redisTemplate.execute(new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(lockKey), lockValue);
    }
    
    private void updateUserSafely(Long userId, User user) {
        // åŒé‡æ£€æŸ¥ï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§
        User currentUser = getUserFromDatabase(userId);
        if (currentUser.getVersion().equals(user.getVersion())) {
            // ç‰ˆæœ¬åŒ¹é…ï¼Œæ‰§è¡Œæ›´æ–°
            user.setVersion(user.getVersion() + 1);
            userMapper.updateById(user);
            
            // æ›´æ–°ç¼“å­˜
            String cacheKey = "user:" + userId;
            redisTemplate.opsForValue().set(cacheKey, user);
        } else {
            throw new OptimisticLockException("Data has been modified by another process");
        }
    }
}
```

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹ä¸ä»£ç ç¤ºä¾‹

### ç”µå•†åº“å­˜ç¼“å­˜ä¸€è‡´æ€§æ–¹æ¡ˆ

ç”µå•†ç³»ç»Ÿä¸­ï¼Œåº“å­˜æ•°æ®çš„ä¸€è‡´æ€§è‡³å…³é‡è¦ï¼š

```java
@Service
public class InventoryService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private InventoryMapper inventoryMapper;
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    /**
     * åº“å­˜æ‰£å‡ï¼Œä¿è¯ç¼“å­˜ä¸€è‡´æ€§
     */
    @Transactional
    public boolean deductInventory(Long productId, Integer quantity) {
        String lockKey = "inventory_lock:" + productId;
        String lockValue = UUID.randomUUID().toString();
        
        try {
            // 1. è·å–åˆ†å¸ƒå¼é”
            if (!acquireLock(lockKey, lockValue, 5)) {
                return false;
            }
            
            // 2. æ£€æŸ¥ç¼“å­˜ä¸­çš„åº“å­˜
            String cacheKey = "inventory:" + productId;
            Integer cachedStock = (Integer) redisTemplate.opsForValue().get(cacheKey);
            
            if (cachedStock == null) {
                // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®åº“åŠ è½½
                Inventory inventory = inventoryMapper.selectById(productId);
                cachedStock = inventory != null ? inventory.getStock() : 0;
                redisTemplate.opsForValue().set(cacheKey, cachedStock, 300, TimeUnit.SECONDS);
            }
            
            // 3. æ£€æŸ¥åº“å­˜æ˜¯å¦å……è¶³
            if (cachedStock < quantity) {
                return false;
            }
            
            // 4. æ‰£å‡æ•°æ®åº“åº“å­˜
            int updated = inventoryMapper.deductStock(productId, quantity);
            if (updated == 0) {
                return false;
            }
            
            // 5. æ›´æ–°ç¼“å­˜
            redisTemplate.opsForValue().increment(cacheKey, -quantity);
            
            // 6. å‘é€å¼‚æ­¥æ¶ˆæ¯ï¼Œç¡®ä¿æœ€ç»ˆä¸€è‡´æ€§
            InventoryChangeEvent event = new InventoryChangeEvent(productId, -quantity);
            rabbitTemplate.convertAndSend("inventory.exchange", "inventory.changed", event);
            
            return true;
            
        } finally {
            releaseLock(lockKey, lockValue);
        }
    }
    
    /**
     * ç›‘å¬åº“å­˜å˜æ›´äº‹ä»¶ï¼Œå¤„ç†ç¼“å­˜ä¸€è‡´æ€§
     */
    @RabbitListener(queues = "inventory.sync.queue")
    public void handleInventoryChange(InventoryChangeEvent event) {
        String cacheKey = "inventory:" + event.getProductId();
        
        // é‡æ–°ä»æ•°æ®åº“åŠ è½½æœ€æ–°åº“å­˜
        Inventory inventory = inventoryMapper.selectById(event.getProductId());
        if (inventory != null) {
            redisTemplate.opsForValue().set(cacheKey, inventory.getStock(), 300, TimeUnit.SECONDS);
        } else {
            redisTemplate.delete(cacheKey);
        }
    }
}
```

### å¤šçº§ç¼“å­˜ä¸€è‡´æ€§æ¶æ„

å®ç°L1ï¼ˆæœ¬åœ°ç¼“å­˜ï¼‰+ L2ï¼ˆRedisï¼‰çš„å¤šçº§ç¼“å­˜ï¼š

```java
@Component
public class MultiLevelCache {
    
    // L1ç¼“å­˜ï¼šæœ¬åœ°ç¼“å­˜
    private final Cache<String, Object> localCache = Caffeine.newBuilder()
        .maximumSize(10000)
        .expireAfterWrite(5, TimeUnit.MINUTES)
        .build();
    
    // L2ç¼“å­˜ï¼šRedis
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private RedisMessageListenerContainer listenerContainer;
    
    @PostConstruct
    public void initCacheSync() {
        // ç›‘å¬Redisé”®ç©ºé—´é€šçŸ¥
        listenerContainer.addMessageListener(new CacheInvalidationListener(), 
            new PatternTopic("__keyevent@0__:del"));
        listenerContainer.addMessageListener(new CacheInvalidationListener(), 
            new PatternTopic("__keyevent@0__:expired"));
    }
    
    /**
     * å¤šçº§ç¼“å­˜è¯»å–
     */
    public Object get(String key) {
        // 1. æŸ¥è¯¢L1ç¼“å­˜
        Object value = localCache.getIfPresent(key);
        if (value != null) {
            return value;
        }
        
        // 2. æŸ¥è¯¢L2ç¼“å­˜
        value = redisTemplate.opsForValue().get(key);
        if (value != null) {
            // å›å¡«L1ç¼“å­˜
            localCache.put(key, value);
            return value;
        }
        
        return null;
    }
    
    /**
     * å¤šçº§ç¼“å­˜å†™å…¥
     */
    public void put(String key, Object value, Duration ttl) {
        // 1. å†™å…¥L2ç¼“å­˜
        redisTemplate.opsForValue().set(key, value, ttl);
        
        // 2. å†™å…¥L1ç¼“å­˜
        localCache.put(key, value);
        
        // 3. å‘å¸ƒç¼“å­˜æ›´æ–°äº‹ä»¶
        CacheUpdateEvent event = new CacheUpdateEvent(key, value);
        redisTemplate.convertAndSend("cache.update", event);
    }
    
    /**
     * å¤šçº§ç¼“å­˜åˆ é™¤
     */
    public void evict(String key) {
        // 1. åˆ é™¤L2ç¼“å­˜
        redisTemplate.delete(key);
        
        // 2. åˆ é™¤L1ç¼“å­˜
        localCache.invalidate(key);
        
        // 3. å‘å¸ƒç¼“å­˜å¤±æ•ˆäº‹ä»¶
        redisTemplate.convertAndSend("cache.invalidate", key);
    }
    
    /**
     * ç¼“å­˜å¤±æ•ˆç›‘å¬å™¨
     */
    private class CacheInvalidationListener implements MessageListener {
        @Override
        public void onMessage(Message message, byte[] pattern) {
            String key = new String(message.getBody());
            // åˆ é™¤æœ¬åœ°ç¼“å­˜
            localCache.invalidate(key);
        }
    }
}
```

### ç¼“å­˜é¢„çƒ­å’Œé™çº§ç­–ç•¥

```java
@Component
public class CacheWarmupService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private ProductService productService;
    
    /**
     * ç¼“å­˜é¢„çƒ­
     */
    @PostConstruct
    public void warmupCache() {
        CompletableFuture.runAsync(() -> {
            try {
                // é¢„çƒ­çƒ­é—¨å•†å“æ•°æ®
                List<Long> hotProductIds = getHotProductIds();
                for (Long productId : hotProductIds) {
                    Product product = productService.getProductFromDatabase(productId);
                    if (product != null) {
                        String cacheKey = "product:" + productId;
                        redisTemplate.opsForValue().set(cacheKey, product, 3600, TimeUnit.SECONDS);
                    }
                }
                log.info("Cache warmup completed, warmed {} products", hotProductIds.size());
            } catch (Exception e) {
                log.error("Cache warmup failed", e);
            }
        });
    }
    
    /**
     * ç¼“å­˜é™çº§ç­–ç•¥
     */
    public Product getProductWithFallback(Long productId) {
        String cacheKey = "product:" + productId;
        
        try {
            // 1. å°è¯•ä»ç¼“å­˜è·å–
            Product product = (Product) redisTemplate.opsForValue().get(cacheKey);
            if (product != null) {
                return product;
            }
            
            // 2. ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢æ•°æ®åº“
            product = productService.getProductFromDatabase(productId);
            if (product != null) {
                // å¼‚æ­¥å†™å…¥ç¼“å­˜ï¼Œé¿å…é˜»å¡
                CompletableFuture.runAsync(() -> {
                    redisTemplate.opsForValue().set(cacheKey, product, 3600, TimeUnit.SECONDS);
                });
            }
            
            return product;
            
        } catch (Exception e) {
            log.error("Cache operation failed, fallback to database", e);
            // 3. ç¼“å­˜æ•…éšœï¼Œç›´æ¥æŸ¥è¯¢æ•°æ®åº“
            return productService.getProductFromDatabase(productId);
        }
    }
}
```

## ğŸ¯ é¢è¯•é«˜é¢‘é—®é¢˜ç²¾è®²

### 1. ç¼“å­˜ä¸€è‡´æ€§æœ‰å“ªäº›ç­–ç•¥ï¼Ÿå„æœ‰ä»€ä¹ˆä¼˜ç¼ºç‚¹ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
- **Cache-Aside**ï¼šåº”ç”¨ç®¡ç†ç¼“å­˜ï¼Œå…ˆåˆ ç¼“å­˜å†æ›´æ–°æ•°æ®åº“
- **Write-Through**ï¼šåŒæ­¥å†™å…¥ç¼“å­˜å’Œæ•°æ®åº“
- **Write-Behind**ï¼šå¼‚æ­¥å†™å…¥æ•°æ®åº“
- **Refresh-Ahead**ï¼šåœ¨ç¼“å­˜è¿‡æœŸå‰ä¸»åŠ¨åˆ·æ–°

**æ‰©å±•è¦ç‚¹**ï¼š
```java
// Cache-Asideä¼˜ç¼ºç‚¹
ä¼˜ç‚¹ï¼šå®ç°ç®€å•ï¼Œåº”ç”¨å¯æ§
ç¼ºç‚¹ï¼šå¯èƒ½å‡ºç°çŸ­æš‚ä¸ä¸€è‡´

// Write-Throughä¼˜ç¼ºç‚¹  
ä¼˜ç‚¹ï¼šå¼ºä¸€è‡´æ€§
ç¼ºç‚¹ï¼šå†™å…¥å»¶è¿Ÿé«˜ï¼Œç¼“å­˜å¯èƒ½å­˜å‚¨ä¸å¸¸ç”¨æ•°æ®

// Write-Behindä¼˜ç¼ºç‚¹
ä¼˜ç‚¹ï¼šå†™å…¥æ€§èƒ½å¥½
ç¼ºç‚¹ï¼šå¯èƒ½ä¸¢å¤±æ•°æ®ï¼Œä¸€è‡´æ€§è¾ƒå¼±
```

### 2. ä¸ºä»€ä¹ˆåˆ é™¤ç¼“å­˜è€Œä¸æ˜¯æ›´æ–°ç¼“å­˜ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
åˆ é™¤ç¼“å­˜æ¯”æ›´æ–°ç¼“å­˜æ›´å®‰å…¨ï¼ŒåŸå› åŒ…æ‹¬ï¼š
- é¿å…å¹¶å‘æ›´æ–°å¯¼è‡´çš„æ•°æ®ä¸ä¸€è‡´
- å‡å°‘ä¸å¿…è¦çš„ç¼“å­˜å†™å…¥
- é™ä½ç¼“å­˜å’Œæ•°æ®åº“çš„è€¦åˆåº¦

**æ‰©å±•è¦ç‚¹**ï¼š
```java
// æ›´æ–°ç¼“å­˜çš„é—®é¢˜
çº¿ç¨‹Aï¼šæ›´æ–°æ•°æ®åº“ -> æ›´æ–°ç¼“å­˜(æ—§å€¼)
çº¿ç¨‹Bï¼šæ›´æ–°æ•°æ®åº“ -> æ›´æ–°ç¼“å­˜(æ–°å€¼)
// ç»“æœï¼šæ•°æ®åº“æ˜¯æ–°å€¼ï¼Œç¼“å­˜æ˜¯æ—§å€¼

// åˆ é™¤ç¼“å­˜çš„æ–¹æ¡ˆ
çº¿ç¨‹Aï¼šæ›´æ–°æ•°æ®åº“ -> åˆ é™¤ç¼“å­˜
çº¿ç¨‹Bï¼šè¯»å–æ—¶å‘ç°ç¼“å­˜ä¸ºç©º -> æŸ¥è¯¢æ•°æ®åº“ -> å†™å…¥ç¼“å­˜
// ç»“æœï¼šä¿è¯æœ€ç»ˆä¸€è‡´æ€§
```

### 3. å¦‚ä½•è§£å†³ç¼“å­˜å‡»ç©¿ã€ç©¿é€ã€é›ªå´©é—®é¢˜ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
- **ç¼“å­˜å‡»ç©¿**ï¼šçƒ­ç‚¹keyè¿‡æœŸï¼Œå¤§é‡è¯·æ±‚ç›´æ¥è®¿é—®æ•°æ®åº“
  - è§£å†³ï¼šåˆ†å¸ƒå¼é”ã€æ°¸ä¸è¿‡æœŸã€å¼‚æ­¥åˆ·æ–°
- **ç¼“å­˜ç©¿é€**ï¼šæŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ®ï¼Œç¼“å­˜æ— æ³•å‘½ä¸­
  - è§£å†³ï¼šå¸ƒéš†è¿‡æ»¤å™¨ã€ç¼“å­˜ç©ºå€¼ã€å‚æ•°æ ¡éªŒ
- **ç¼“å­˜é›ªå´©**ï¼šå¤§é‡ç¼“å­˜åŒæ—¶è¿‡æœŸ
  - è§£å†³ï¼šè¿‡æœŸæ—¶é—´éšæœºåŒ–ã€å¤šçº§ç¼“å­˜ã€ç†”æ–­é™çº§

### 4. åˆ†å¸ƒå¼ç¯å¢ƒä¸‹å¦‚ä½•ä¿è¯ç¼“å­˜ä¸€è‡´æ€§ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
- ä½¿ç”¨åˆ†å¸ƒå¼é”é˜²æ­¢å¹¶å‘å†²çª
- åŸºäºç‰ˆæœ¬å·çš„ä¹è§‚é”æœºåˆ¶
- æ¶ˆæ¯é˜Ÿåˆ—å¼‚æ­¥åŒæ­¥
- æœ€ç»ˆä¸€è‡´æ€§è€Œéå¼ºä¸€è‡´æ€§

**é¢è¯•æŠ€å·§**ï¼šç»“åˆå…·ä½“åœºæ™¯è¯´æ˜ï¼Œå¦‚ç”µå•†åº“å­˜ã€ç”¨æˆ·ä¼šè¯ç­‰ã€‚

### 5. Redisé›†ç¾¤æ¨¡å¼ä¸‹çš„ä¸€è‡´æ€§é—®é¢˜ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
- **ä¸»ä»å¤åˆ¶å»¶è¿Ÿ**ï¼šå†™å…¥ä¸»èŠ‚ç‚¹åï¼Œä»èŠ‚ç‚¹å¯èƒ½è¿˜æœªåŒæ­¥
- **è„‘è£‚é—®é¢˜**ï¼šç½‘ç»œåˆ†åŒºå¯¼è‡´å¤šä¸ªä¸»èŠ‚ç‚¹
- **æ§½ä½è¿ç§»**ï¼šClusteræ¨¡å¼ä¸‹æ•°æ®è¿ç§»æœŸé—´çš„ä¸€è‡´æ€§

**æ‰©å±•è¦ç‚¹**ï¼š
```java
// è§£å†³æ–¹æ¡ˆ
1. ä½¿ç”¨waitå‘½ä»¤ç¡®ä¿å¤åˆ¶å®Œæˆ
2. é…ç½®min-slaves-to-writeå‚æ•°
3. å®¢æˆ·ç«¯é‡è¯•æœºåˆ¶
4. è¯»å†™åˆ†ç¦»æ—¶çš„ä¸»ä»é€‰æ‹©ç­–ç•¥
```

### 6. å¦‚ä½•è®¾è®¡ä¸€ä¸ªé«˜å¯ç”¨çš„ç¼“å­˜æ¶æ„ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
å¤šçº§ç¼“å­˜ + ä¸»ä»å¤åˆ¶ + é›†ç¾¤éƒ¨ç½² + ç›‘æ§å‘Šè­¦

**æ¶æ„è¦ç‚¹**ï¼š
- L1æœ¬åœ°ç¼“å­˜ï¼šå“åº”æœ€å¿«ï¼Œå®¹é‡æœ‰é™
- L2åˆ†å¸ƒå¼ç¼“å­˜ï¼šå®¹é‡å¤§ï¼Œç½‘ç»œå»¶è¿Ÿ
- L3æ•°æ®åº“ï¼šæŒä¹…åŒ–å­˜å‚¨ï¼Œæ€§èƒ½è¾ƒä½
- é™çº§ç­–ç•¥ï¼šç¼“å­˜æ•…éšœæ—¶çš„å¤‡ç”¨æ–¹æ¡ˆ

### 7. ç¼“å­˜é¢„çƒ­å’Œç¼“å­˜æ›´æ–°ç­–ç•¥ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
- **é¢„çƒ­ç­–ç•¥**ï¼šç³»ç»Ÿå¯åŠ¨æ—¶åŠ è½½çƒ­ç‚¹æ•°æ®
- **æ›´æ–°ç­–ç•¥**ï¼šå®šæ—¶æ›´æ–°ã€äº‹ä»¶é©±åŠ¨æ›´æ–°ã€æ‡’åŠ è½½æ›´æ–°
- **æ·˜æ±°ç­–ç•¥**ï¼šLRUã€LFUã€TTLã€éšæœºæ·˜æ±°

### 8. å¦‚ä½•ç›‘æ§å’Œä¼˜åŒ–ç¼“å­˜æ€§èƒ½ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
- **å…³é”®æŒ‡æ ‡**ï¼šå‘½ä¸­ç‡ã€å“åº”æ—¶é—´ã€å†…å­˜ä½¿ç”¨ç‡ã€ç½‘ç»œIO
- **ç›‘æ§å·¥å…·**ï¼šRedisç›‘æ§ã€APMå·¥å…·ã€è‡ªå®šä¹‰æŒ‡æ ‡
- **ä¼˜åŒ–ç­–ç•¥**ï¼šæ•°æ®ç»“æ„ä¼˜åŒ–ã€åºåˆ—åŒ–ä¼˜åŒ–ã€ç½‘ç»œä¼˜åŒ–

## âš¡ æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹

### ç¼“å­˜æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```java
@Component
public class CacheOptimizer {
    
    /**
     * æ‰¹é‡æ“ä½œä¼˜åŒ–
     */
    public Map<String, Object> batchGet(List<String> keys) {
        // ä½¿ç”¨pipelineå‡å°‘ç½‘ç»œå¾€è¿”
        List<Object> values = redisTemplate.executePipelined(new RedisCallback<Object>() {
            @Override
            public Object doInRedis(RedisConnection connection) throws DataAccessException {
                for (String key : keys) {
                    connection.get(key.getBytes());
                }
                return null;
            }
        });
        
        Map<String, Object> result = new HashMap<>();
        for (int i = 0; i < keys.size(); i++) {
            result.put(keys.get(i), values.get(i));
        }
        return result;
    }
    
    /**
     * åºåˆ—åŒ–ä¼˜åŒ–
     */
    @Bean
    public RedisTemplate<String, Object> optimizedRedisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        
        // ä½¿ç”¨æ›´é«˜æ•ˆçš„åºåˆ—åŒ–æ–¹å¼
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericFastJsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericFastJsonRedisSerializer());
        
        return template;
    }
}
```

### å¸¸è§æ€§èƒ½é™·é˜±

1. **å¤§keyé—®é¢˜**ï¼šé¿å…å­˜å‚¨è¿‡å¤§çš„value
2. **çƒ­keyé—®é¢˜**ï¼šä½¿ç”¨æœ¬åœ°ç¼“å­˜åˆ†æ•£å‹åŠ›
3. **é¢‘ç¹åºåˆ—åŒ–**ï¼šé€‰æ‹©é«˜æ•ˆçš„åºåˆ—åŒ–æ–¹å¼
4. **ç½‘ç»œå»¶è¿Ÿ**ï¼šä½¿ç”¨pipelineæ‰¹é‡æ“ä½œ

### ç›‘æ§å’Œå‘Šè­¦

```java
@Component
public class CacheMonitor {
    
    private final MeterRegistry meterRegistry;
    
    public CacheMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public Object getWithMetrics(String key) {
        Timer.Sample sample = Timer.start(meterRegistry);
        try {
            Object value = redisTemplate.opsForValue().get(key);
            if (value != null) {
                meterRegistry.counter("cache.hit").increment();
            } else {
                meterRegistry.counter("cache.miss").increment();
            }
            return value;
        } finally {
            sample.stop(Timer.builder("cache.access.time").register(meterRegistry));
        }
    }
}
```

## ğŸ“š æ€»ç»“ä¸æŠ€æœ¯å¯¹æ¯”

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

ç¼“å­˜ä¸€è‡´æ€§æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿçš„æ ¸å¿ƒæŒ‘æˆ˜ï¼Œéœ€è¦åœ¨æ€§èƒ½å’Œä¸€è‡´æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ï¼š

1. **é€‰æ‹©åˆé€‚çš„ä¸€è‡´æ€§æ¨¡å‹**ï¼šæ ¹æ®ä¸šåŠ¡éœ€æ±‚é€‰æ‹©å¼ºä¸€è‡´æ€§æˆ–æœ€ç»ˆä¸€è‡´æ€§
2. **å®æ–½å¤šå±‚é˜²æŠ¤**ï¼šåˆ†å¸ƒå¼é”ã€ç‰ˆæœ¬æ§åˆ¶ã€æ¶ˆæ¯é˜Ÿåˆ—ç­‰å¤šç§æœºåˆ¶ç»“åˆ
3. **ç›‘æ§å’Œä¼˜åŒ–**ï¼šå»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»ï¼ŒæŒç»­ä¼˜åŒ–æ€§èƒ½
4. **é™çº§ç­–ç•¥**ï¼šå‡†å¤‡ç¼“å­˜æ•…éšœæ—¶çš„å¤‡ç”¨æ–¹æ¡ˆ

### æŠ€æœ¯é€‰å‹å¯¹æ¯”

| æ–¹æ¡ˆ | ä¸€è‡´æ€§ | æ€§èƒ½ | å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|--------|------|--------|----------|
| Cache-Aside | æœ€ç»ˆä¸€è‡´ | é«˜ | ä½ | é€šç”¨åœºæ™¯ |
| Write-Through | å¼ºä¸€è‡´ | ä¸­ | ä¸­ | æ•°æ®ä¸€è‡´æ€§è¦æ±‚é«˜ |
| Write-Behind | å¼±ä¸€è‡´ | é«˜ | é«˜ | é«˜å¹¶å‘å†™å…¥ |
| åˆ†å¸ƒå¼é” | å¼ºä¸€è‡´ | ä½ | é«˜ | å…³é”®æ•°æ®æ›´æ–° |

### æŒç»­å­¦ä¹ å»ºè®®

1. **æ·±å…¥ç†è§£åˆ†å¸ƒå¼ç†è®º**ï¼šCAPã€BASEã€ACIDç­‰
2. **å®è·µä¸åŒç¼“å­˜æ¨¡å¼**ï¼šåœ¨é¡¹ç›®ä¸­å°è¯•å„ç§ä¸€è‡´æ€§ç­–ç•¥
3. **å…³æ³¨æ–°æŠ€æœ¯å‘å±•**ï¼šå¦‚Redis 7.0çš„æ–°ç‰¹æ€§ã€äº‘åŸç”Ÿç¼“å­˜æ–¹æ¡ˆ
4. **å­¦ä¹ ç›¸å…³æŠ€æœ¯**ï¼šæ¶ˆæ¯é˜Ÿåˆ—ã€åˆ†å¸ƒå¼é”ã€ç›‘æ§ç³»ç»Ÿç­‰

ç¼“å­˜ä¸€è‡´æ€§æ˜¯ä¸€ä¸ªå¤æ‚ä½†é‡è¦çš„æŠ€æœ¯é¢†åŸŸï¼Œéœ€è¦ç»“åˆå…·ä½“ä¸šåŠ¡åœºæ™¯ï¼Œåœ¨æ€§èƒ½ã€ä¸€è‡´æ€§å’Œå¤æ‚åº¦ä¹‹é—´æ‰¾åˆ°æœ€ä½³å¹³è¡¡ç‚¹ã€‚ 