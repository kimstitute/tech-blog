---
title: "Elasticsearchåˆ†å¸ƒå¼æœç´¢å¼•æ“æ¶æ„ä¸ä¼˜åŒ–å®è·µ"
description: "æ·±å…¥æ¢è®¨Elasticsearchåˆ†å¸ƒå¼æœç´¢å¼•æ“çš„æ ¸å¿ƒæ¶æ„ï¼ŒåŒ…æ‹¬å€’æ’ç´¢å¼•ã€åˆ†ç‰‡æœºåˆ¶ã€æŸ¥è¯¢ä¼˜åŒ–å’Œé›†ç¾¤ç®¡ç†ï¼Œç»“åˆå®é™…é¡¹ç›®ç»éªŒåˆ†äº«å¤§è§„æ¨¡æœç´¢ç³»ç»Ÿè®¾è®¡å®è·µã€‚"
pubDate: 2024-12-28
updatedDate: 2024-12-28
tags: ["elasticsearch", "distributed-search", "inverted-index", "sharding", "query-optimization", "lucene", "interview", "best-practices"]
categories: ["middleware"]
subject: "åˆ†å¸ƒå¼æœç´¢"
draft: false
featured: true
author: "Gerrad Zhang"
location: "æ­¦æ±‰ï¼Œä¸­å›½"
---

## ğŸ¤” é—®é¢˜èƒŒæ™¯ä¸æŠ€æœ¯æ¼”è¿›

### æˆ‘ä»¬è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

åœ¨å¤§æ•°æ®æ—¶ä»£ï¼Œä¼ ç»Ÿæ•°æ®åº“çš„å…¨æ–‡æ£€ç´¢èƒ½åŠ›å·²æ— æ³•æ»¡è¶³å¤æ‚æœç´¢éœ€æ±‚ã€‚Elasticsearchè¦è§£å†³çš„æ ¸å¿ƒé—®é¢˜ï¼š**å…¨æ–‡æ£€ç´¢**ã€**å®æ—¶æœç´¢**ã€**å¤§è§„æ¨¡æ•°æ®å¤„ç†**ã€**å¤æ‚æŸ¥è¯¢**ã€**é«˜å¯ç”¨æ€§**ã€‚

### æ²¡æœ‰è¿™ä¸ªæŠ€æœ¯æ—¶æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ

æ—©æœŸæœç´¢ä¸»è¦é€šè¿‡ï¼š**æ•°æ®åº“LIKEæŸ¥è¯¢**ã€**æ–‡ä»¶ç³»ç»Ÿæœç´¢**ã€**ç®€å•ç´¢å¼•**ç­‰æ–¹å¼ï¼Œå­˜åœ¨æ€§èƒ½å·®ã€åŠŸèƒ½å¼±ã€æ‰©å±•æ€§å·®ç­‰é—®é¢˜ã€‚

### æŠ€æœ¯æ¼”è¿›çš„å†å²è„‰ç»œ

æœç´¢æŠ€æœ¯ä»**å…³é”®è¯åŒ¹é…** â†’ **å…¨æ–‡ç´¢å¼•** â†’ **åˆ†å¸ƒå¼æœç´¢** â†’ **æ™ºèƒ½æœç´¢**ä¸æ–­æ¼”è¿›ï¼ŒElasticsearchåŸºäºLuceneæ„å»ºäº†å®Œæ•´çš„åˆ†å¸ƒå¼æœç´¢è§£å†³æ–¹æ¡ˆã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µä¸åŸç†

### åŸºç¡€æ¦‚å¿µå®šä¹‰

**å€’æ’ç´¢å¼•**ï¼šå°†æ–‡æ¡£ä¸­çš„è¯æ±‡æ˜ å°„åˆ°åŒ…å«è¯¥è¯æ±‡çš„æ–‡æ¡£åˆ—è¡¨ï¼Œå®ç°å¿«é€Ÿå…¨æ–‡æ£€ç´¢ã€‚
**åˆ†ç‰‡ï¼ˆShardï¼‰**ï¼šç´¢å¼•çš„ç‰©ç†åˆ†å‰²å•å…ƒï¼Œå®ç°æ°´å¹³æ‰©å±•å’Œå¹¶è¡Œå¤„ç†ã€‚
**å‰¯æœ¬ï¼ˆReplicaï¼‰**ï¼šåˆ†ç‰‡çš„å†—ä½™å¤‡ä»½ï¼Œæä¾›é«˜å¯ç”¨æ€§å’Œè¯»å–æ€§èƒ½ã€‚
**é›†ç¾¤ï¼ˆClusterï¼‰**ï¼šå¤šä¸ªèŠ‚ç‚¹ç»„æˆçš„åˆ†å¸ƒå¼ç³»ç»Ÿï¼Œæä¾›ç»Ÿä¸€çš„æœç´¢æœåŠ¡ã€‚

### å·¥ä½œåŸç†è¯¦è§£

Elasticsearché€šè¿‡**åˆ†å¸ƒå¼æ¶æ„**ã€**å€’æ’ç´¢å¼•**ã€**åˆ†ç‰‡è·¯ç”±**ã€**æŸ¥è¯¢åè°ƒ**ç­‰æœºåˆ¶å®ç°é«˜æ€§èƒ½æœç´¢ã€‚æŸ¥è¯¢è¯·æ±‚ç»è¿‡è·¯ç”±åˆ†å‘åˆ°ç›¸å…³åˆ†ç‰‡ï¼Œå¹¶è¡Œæ‰§è¡Œååˆå¹¶ç»“æœã€‚

### æŠ€æœ¯ç‰¹ç‚¹å’Œä¼˜åŠ¿

**å®æ—¶æœç´¢**ï¼šè¿‘å®æ—¶çš„æ•°æ®ç´¢å¼•å’Œæœç´¢èƒ½åŠ›
**æ°´å¹³æ‰©å±•**ï¼šé€šè¿‡å¢åŠ èŠ‚ç‚¹çº¿æ€§æ‰©å±•å¤„ç†èƒ½åŠ›
**é«˜å¯ç”¨æ€§**ï¼šå¤šå‰¯æœ¬æœºåˆ¶ä¿è¯æœåŠ¡å¯ç”¨æ€§
**ä¸°å¯ŒåŠŸèƒ½**ï¼šæ”¯æŒå¤æ‚æŸ¥è¯¢ã€èšåˆåˆ†æã€åœ°ç†æœç´¢ç­‰

## ğŸ”§ å®ç°åŸç†ä¸æºç åˆ†æ

### åº•å±‚å®ç°æœºåˆ¶

**å€’æ’ç´¢å¼•ç»“æ„**ï¼š
- Term Dictionaryï¼šè¯æ±‡å­—å…¸
- Posting Listï¼šæ–‡æ¡£åˆ—è¡¨
- Term Vectorï¼šè¯æ±‡å‘é‡
- Field Dataï¼šå­—æ®µæ•°æ®ç¼“å­˜

**åˆ†ç‰‡è·¯ç”±ç®—æ³•**ï¼š
```java
// é»˜è®¤è·¯ç”±ç®—æ³•
shard = hash(routing) % number_of_primary_shards

// è‡ªå®šä¹‰è·¯ç”±
shard = hash(custom_routing_value) % number_of_primary_shards
```

### å…³é”®æºç è§£è¯»

```java
// å€’æ’ç´¢å¼•æ ¸å¿ƒç»“æ„
public class InvertedIndex {
    private Map<String, PostingList> termIndex;
    
    public PostingList getPostingList(String term) {
        return termIndex.get(term);
    }
    
    public List<Document> search(String term) {
        PostingList postings = getPostingList(term);
        return postings.getDocuments();
    }
}

// åˆ†ç‰‡è·¯ç”±å®ç°
public class ShardRouting {
    public int getShardId(String routing, int numShards) {
        return Math.floorMod(Murmur3HashFunction.hash(routing), numShards);
    }
}
```

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹ä¸ä»£ç ç¤ºä¾‹

### å…·ä½“é¡¹ç›®åº”ç”¨

åœ¨ç”µå•†æœç´¢ç³»ç»Ÿä¸­ï¼Œéœ€è¦æ”¯æŒå•†å“çš„å¤šç»´åº¦æœç´¢å’Œå®æ—¶æ¨èã€‚é€šè¿‡Elasticsearché›†ç¾¤ä¼˜åŒ–ï¼Œå®ç°äº†æ¯«ç§’çº§å“åº”æ—¶é—´ï¼Œæ”¯æŒåƒä¸‡çº§å•†å“çš„å¤æ‚æœç´¢ã€‚

### å®Œæ•´ä»£ç å®ç°

**Elasticsearché…ç½®**ï¼š

```java
@Configuration
public class ElasticsearchConfig {
    
    @Bean
    public ElasticsearchClient elasticsearchClient() {
        RestClient restClient = RestClient.builder(
            new HttpHost("es-node1", 9200, "http"),
            new HttpHost("es-node2", 9200, "http"),
            new HttpHost("es-node3", 9200, "http")
        ).build();
        
        ElasticsearchTransport transport = new RestClientTransport(
            restClient, new JacksonJsonpMapper());
            
        return new ElasticsearchClient(transport);
    }
}
```

**ç´¢å¼•ç®¡ç†æœåŠ¡**ï¼š

```java
@Service
public class ProductIndexService {
    
    @Autowired
    private ElasticsearchClient client;
    
    /**
     * åˆ›å»ºå•†å“ç´¢å¼•
     */
    public void createProductIndex() throws IOException {
        CreateIndexRequest request = CreateIndexRequest.of(i -> i
            .index("products")
            .settings(s -> s
                .numberOfShards("3")
                .numberOfReplicas("1")
                .analysis(a -> a
                    .analyzer("ik_analyzer", an -> an
                        .custom(c -> c
                            .tokenizer("ik_max_word")
                            .filter("lowercase", "stop")
                        )
                    )
                )
            )
            .mappings(m -> m
                .properties("id", p -> p.keyword(k -> k))
                .properties("title", p -> p.text(t -> t
                    .analyzer("ik_analyzer")
                    .searchAnalyzer("ik_analyzer")
                ))
                .properties("description", p -> p.text(t -> t
                    .analyzer("ik_analyzer")
                ))
                .properties("price", p -> p.double_(d -> d))
                .properties("category", p -> p.keyword(k -> k))
                .properties("tags", p -> p.keyword(k -> k))
                .properties("createTime", p -> p.date(d -> d
                    .format("yyyy-MM-dd HH:mm:ss")
                ))
            )
        );
        
        client.indices().create(request);
    }
    
    /**
     * æ‰¹é‡ç´¢å¼•å•†å“
     */
    public void bulkIndexProducts(List<Product> products) throws IOException {
        BulkRequest.Builder bulkBuilder = new BulkRequest.Builder();
        
        for (Product product : products) {
            bulkBuilder.operations(op -> op
                .index(idx -> idx
                    .index("products")
                    .id(product.getId())
                    .document(product)
                )
            );
        }
        
        BulkResponse response = client.bulk(bulkBuilder.build());
        
        if (response.errors()) {
            for (BulkResponseItem item : response.items()) {
                if (item.error() != null) {
                    log.error("ç´¢å¼•å¤±è´¥: {}", item.error().reason());
                }
            }
        }
    }
}
```

**æœç´¢æœåŠ¡å®ç°**ï¼š

```java
@Service
public class ProductSearchService {
    
    @Autowired
    private ElasticsearchClient client;
    
    /**
     * å¤šæ¡ä»¶æœç´¢
     */
    public SearchResult<Product> searchProducts(ProductSearchRequest request) throws IOException {
        SearchRequest searchRequest = SearchRequest.of(s -> s
            .index("products")
            .query(q -> buildQuery(request))
            .aggregations(buildAggregations())
            .sort(buildSort(request))
            .from(request.getFrom())
            .size(request.getSize())
            .highlight(h -> h
                .fields("title", hf -> hf
                    .preTags("<em>")
                    .postTags("</em>")
                )
                .fields("description", hf -> hf
                    .preTags("<em>")
                    .postTags("</em>")
                )
            )
        );
        
        SearchResponse<Product> response = client.search(searchRequest, Product.class);
        
        return buildSearchResult(response);
    }
    
    private Query buildQuery(ProductSearchRequest request) {
        BoolQuery.Builder boolQuery = new BoolQuery.Builder();
        
        // å…³é”®è¯æœç´¢
        if (StringUtils.hasText(request.getKeyword())) {
            boolQuery.must(m -> m
                .multiMatch(mm -> mm
                    .query(request.getKeyword())
                    .fields("title^2", "description")
                    .type(TextQueryType.BestFields)
                    .fuzziness("AUTO")
                )
            );
        }
        
        // åˆ†ç±»è¿‡æ»¤
        if (StringUtils.hasText(request.getCategory())) {
            boolQuery.filter(f -> f
                .term(t -> t
                    .field("category")
                    .value(request.getCategory())
                )
            );
        }
        
        // ä»·æ ¼èŒƒå›´è¿‡æ»¤
        if (request.getMinPrice() != null || request.getMaxPrice() != null) {
            boolQuery.filter(f -> f
                .range(r -> {
                    RangeQuery.Builder rangeBuilder = r.field("price");
                    if (request.getMinPrice() != null) {
                        rangeBuilder.gte(JsonData.of(request.getMinPrice()));
                    }
                    if (request.getMaxPrice() != null) {
                        rangeBuilder.lte(JsonData.of(request.getMaxPrice()));
                    }
                    return rangeBuilder;
                })
            );
        }
        
        // æ ‡ç­¾è¿‡æ»¤
        if (request.getTags() != null && !request.getTags().isEmpty()) {
            boolQuery.filter(f -> f
                .terms(t -> t
                    .field("tags")
                    .terms(ts -> ts.value(
                        request.getTags().stream()
                            .map(FieldValue::of)
                            .collect(Collectors.toList())
                    ))
                )
            );
        }
        
        return Query.of(q -> q.bool(boolQuery.build()));
    }
    
    private Map<String, Aggregation> buildAggregations() {
        return Map.of(
            "categories", Aggregation.of(a -> a
                .terms(t -> t
                    .field("category")
                    .size(20)
                )
            ),
            "price_ranges", Aggregation.of(a -> a
                .range(r -> r
                    .field("price")
                    .ranges(
                        Range.of(ra -> ra.to(JsonData.of(100))),
                        Range.of(ra -> ra.from(JsonData.of(100)).to(JsonData.of(500))),
                        Range.of(ra -> ra.from(JsonData.of(500)).to(JsonData.of(1000))),
                        Range.of(ra -> ra.from(JsonData.of(1000)))
                    )
                )
            )
        );
    }
}
```

**æœç´¢å»ºè®®æœåŠ¡**ï¼š

```java
@Service
public class SearchSuggestionService {
    
    @Autowired
    private ElasticsearchClient client;
    
    /**
     * æœç´¢å»ºè®®
     */
    public List<String> getSuggestions(String input) throws IOException {
        SearchRequest request = SearchRequest.of(s -> s
            .index("products")
            .size(0)
            .suggest(su -> su
                .suggesters("product_suggest", sug -> sug
                    .text(input)
                    .completion(c -> c
                        .field("suggest")
                        .size(10)
                        .skipDuplicates(true)
                    )
                )
            )
        );
        
        SearchResponse<Product> response = client.search(request, Product.class);
        
        return response.suggest().get("product_suggest").stream()
            .flatMap(suggestion -> suggestion.completion().options().stream())
            .map(option -> option.text())
            .distinct()
            .collect(Collectors.toList());
    }
}
```

## ğŸ¯ é¢è¯•é«˜é¢‘é—®é¢˜ç²¾è®²

### 1. Elasticsearchçš„å€’æ’ç´¢å¼•æ˜¯ä»€ä¹ˆï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼šå€’æ’ç´¢å¼•æ˜¯Elasticsearchçš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼š

**ç»“æ„ç»„æˆ**ï¼š
- Term Dictionaryï¼šå­˜å‚¨æ‰€æœ‰å”¯ä¸€è¯æ±‡
- Posting Listï¼šæ¯ä¸ªè¯æ±‡å¯¹åº”çš„æ–‡æ¡£åˆ—è¡¨
- Term Frequencyï¼šè¯æ±‡åœ¨æ–‡æ¡£ä¸­çš„é¢‘ç‡
- Positionï¼šè¯æ±‡åœ¨æ–‡æ¡£ä¸­çš„ä½ç½®

**å·¥ä½œåŸç†**ï¼š
1. æ–‡æ¡£åˆ†è¯ç”Ÿæˆè¯æ±‡åˆ—è¡¨
2. ä¸ºæ¯ä¸ªè¯æ±‡å»ºç«‹æ–‡æ¡£æ˜ å°„
3. æŸ¥è¯¢æ—¶é€šè¿‡è¯æ±‡å¿«é€Ÿå®šä½æ–‡æ¡£
4. åˆå¹¶å¤šä¸ªè¯æ±‡çš„ç»“æœé›†

**ä¼˜åŠ¿**ï¼š
- æŸ¥è¯¢é€Ÿåº¦å¿«ï¼Œæ—¶é—´å¤æ‚åº¦O(1)
- æ”¯æŒå¤æ‚çš„å…¨æ–‡æ£€ç´¢
- å†…å­˜ä½¿ç”¨æ•ˆç‡é«˜

### 2. Elasticsearchå¦‚ä½•å®ç°åˆ†å¸ƒå¼ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼šElasticsearché€šè¿‡å¤šç§æœºåˆ¶å®ç°åˆ†å¸ƒå¼ï¼š

**åˆ†ç‰‡æœºåˆ¶**ï¼š
- ä¸»åˆ†ç‰‡ï¼šæ•°æ®çš„ä¸»è¦å­˜å‚¨å•å…ƒ
- å‰¯æœ¬åˆ†ç‰‡ï¼šä¸»åˆ†ç‰‡çš„å¤‡ä»½
- åˆ†ç‰‡è·¯ç”±ï¼šæ ¹æ®æ–‡æ¡£IDè®¡ç®—åˆ†ç‰‡ä½ç½®

**é›†ç¾¤æ¶æ„**ï¼š
```yaml
# èŠ‚ç‚¹è§’è‰²é…ç½®
node.roles: ["master", "data", "ingest"]

# ä¸»èŠ‚ç‚¹ï¼šé›†ç¾¤ç®¡ç†
node.roles: ["master"]

# æ•°æ®èŠ‚ç‚¹ï¼šæ•°æ®å­˜å‚¨
node.roles: ["data"]

# åè°ƒèŠ‚ç‚¹ï¼šè¯·æ±‚è·¯ç”±
node.roles: []
```

**æ•…éšœæ¢å¤**ï¼š
- ä¸»åˆ†ç‰‡ä¸¢å¤±æ—¶æå‡å‰¯æœ¬ä¸ºä¸»åˆ†ç‰‡
- èŠ‚ç‚¹æ•…éšœæ—¶é‡æ–°åˆ†é…åˆ†ç‰‡
- è‡ªåŠ¨æ•°æ®å¹³è¡¡å’Œæ¢å¤

### 3. ElasticsearchæŸ¥è¯¢æ€§èƒ½å¦‚ä½•ä¼˜åŒ–ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼šElasticsearchæŸ¥è¯¢ä¼˜åŒ–çš„å¤šä¸ªç»´åº¦ï¼š

**ç´¢å¼•ä¼˜åŒ–**ï¼š
```json
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1,
    "refresh_interval": "30s",
    "index.max_result_window": 10000
  },
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "ik_max_word",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      }
    }
  }
}
```

**æŸ¥è¯¢ä¼˜åŒ–**ï¼š
- ä½¿ç”¨è¿‡æ»¤å™¨è€ŒéæŸ¥è¯¢ï¼ˆfilter vs queryï¼‰
- åˆç†ä½¿ç”¨åˆ†é¡µï¼ˆfrom + size vs scrollï¼‰
- é¿å…æ·±åº¦åˆ†é¡µ
- ä½¿ç”¨åˆé€‚çš„æŸ¥è¯¢ç±»å‹

**ç¼“å­˜ä¼˜åŒ–**ï¼š
- Query Cacheï¼šç¼“å­˜æŸ¥è¯¢ç»“æœ
- Request Cacheï¼šç¼“å­˜è¯·æ±‚ç»“æœ
- Field Data Cacheï¼šç¼“å­˜å­—æ®µæ•°æ®

### 4. å¦‚ä½•å¤„ç†Elasticsearchçš„æ•°æ®ä¸€è‡´æ€§ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼šElasticsearchæ•°æ®ä¸€è‡´æ€§ç­–ç•¥ï¼š

**å†™å…¥ä¸€è‡´æ€§**ï¼š
```java
// ç­‰å¾…æ‰€æœ‰å‰¯æœ¬ç¡®è®¤
IndexRequest request = new IndexRequest("index")
    .id("1")
    .source(document)
    .setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL);
```

**è¯»å–ä¸€è‡´æ€§**ï¼š
```java
// æŒ‡å®šä¼˜å…ˆçº§
SearchRequest request = new SearchRequest("index")
    .preference("_primary");  // ä¼˜å…ˆä»ä¸»åˆ†ç‰‡è¯»å–
```

**ç‰ˆæœ¬æ§åˆ¶**ï¼š
```java
// ä¹è§‚é”æ§åˆ¶
IndexRequest request = new IndexRequest("index")
    .id("1")
    .version(currentVersion)
    .versionType(VersionType.EXTERNAL);
```

### 5. Elasticsearché›†ç¾¤å¦‚ä½•ç›‘æ§å’Œè¿ç»´ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼šElasticsearchç›‘æ§è¿ç»´çš„å…³é”®æŒ‡æ ‡ï¼š

**é›†ç¾¤å¥åº·ç›‘æ§**ï¼š
```bash
# é›†ç¾¤å¥åº·çŠ¶æ€
GET /_cluster/health

# èŠ‚ç‚¹ä¿¡æ¯
GET /_nodes/stats

# ç´¢å¼•ç»Ÿè®¡
GET /_stats
```

**æ€§èƒ½ç›‘æ§æŒ‡æ ‡**ï¼š
- æŸ¥è¯¢QPSå’Œå“åº”æ—¶é—´
- ç´¢å¼•é€Ÿåº¦å’Œæ–‡æ¡£æ•°é‡
- å†…å­˜å’ŒCPUä½¿ç”¨ç‡
- ç£ç›˜ç©ºé—´å’ŒIOçŠ¶æ€

**å‘Šè­¦ç­–ç•¥**ï¼š
- é›†ç¾¤çŠ¶æ€ä¸ºçº¢è‰²æˆ–é»„è‰²
- æŸ¥è¯¢å“åº”æ—¶é—´è¶…è¿‡é˜ˆå€¼
- èŠ‚ç‚¹ç¦»çº¿æˆ–åˆ†ç‰‡æœªåˆ†é…
- ç£ç›˜ç©ºé—´ä¸è¶³

## âš¡ æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹

### æ€§èƒ½ç“¶é¢ˆåˆ†æ

**å¸¸è§æ€§èƒ½ç“¶é¢ˆ**ï¼š
1. **å†…å­˜ä¸è¶³**ï¼šå †å†…å­˜ã€å­—æ®µæ•°æ®ç¼“å­˜
2. **ç£ç›˜IO**ï¼šç´¢å¼•å†™å…¥ã€æ®µåˆå¹¶
3. **ç½‘ç»œå»¶è¿Ÿ**ï¼šé›†ç¾¤é—´é€šä¿¡ã€å®¢æˆ·ç«¯è¿æ¥
4. **æŸ¥è¯¢å¤æ‚åº¦**ï¼šæ·±åº¦åˆ†é¡µã€å¤æ‚èšåˆ

### ä¼˜åŒ–ç­–ç•¥æ–¹æ¡ˆ

**ç¡¬ä»¶ä¼˜åŒ–**ï¼š
```yaml
# JVMå†…å­˜é…ç½®
-Xms8g -Xmx8g

# ç³»ç»Ÿé…ç½®
vm.max_map_count=262144
fs.file-max=65536
```

**ç´¢å¼•ä¼˜åŒ–**ï¼š
```json
{
  "settings": {
    "index.refresh_interval": "30s",
    "index.number_of_replicas": 0,
    "index.merge.policy.max_merged_segment": "2gb"
  }
}
```

### å¸¸è§å‘ç‚¹è§„é¿

**åˆ†ç‰‡è®¾è®¡è¯¯åŒº**ï¼š
- åˆ†ç‰‡æ•°é‡ä¸æ˜¯è¶Šå¤šè¶Šå¥½
- å•ä¸ªåˆ†ç‰‡å»ºè®®ä¸è¶…è¿‡50GB
- é¿å…è¿‡åº¦åˆ†ç‰‡å¯¼è‡´å¼€é”€å¢åŠ 

**æŸ¥è¯¢ä¼˜åŒ–è¯¯åŒº**ï¼š
- é¿å…ä½¿ç”¨wildcardå’ŒregexæŸ¥è¯¢
- åˆç†ä½¿ç”¨èšåˆæŸ¥è¯¢
- æ³¨æ„æ·±åº¦åˆ†é¡µçš„æ€§èƒ½å½±å“

## ğŸ“š æ€»ç»“ä¸æŠ€æœ¯å¯¹æ¯”

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

Elasticsearchåˆ†å¸ƒå¼æœç´¢éœ€è¦æŒæ¡ï¼š**å€’æ’ç´¢å¼•åŸç†**ã€**åˆ†ç‰‡æœºåˆ¶**ã€**æŸ¥è¯¢ä¼˜åŒ–**ã€**é›†ç¾¤ç®¡ç†**ã€**æ€§èƒ½è°ƒä¼˜**ç­‰æ ¸å¿ƒæŠ€èƒ½ã€‚

### ä¸ç›¸å…³æŠ€æœ¯å¯¹æ¯”

| ç‰¹æ€§ | Elasticsearch | Solr | MongoDB | MySQL |
|------|---------------|------|---------|-------|
| å…¨æ–‡æ£€ç´¢ | ä¼˜ç§€ | ä¼˜ç§€ | åŸºç¡€ | åŸºç¡€ |
| åˆ†å¸ƒå¼ | åŸç”Ÿæ”¯æŒ | æ”¯æŒ | åŸç”Ÿæ”¯æŒ | éœ€ä¸­é—´ä»¶ |
| å®æ—¶æ€§ | è¿‘å®æ—¶ | è¿‘å®æ—¶ | å®æ—¶ | å®æ—¶ |
| æ‰©å±•æ€§ | ä¼˜ç§€ | è‰¯å¥½ | ä¼˜ç§€ | æœ‰é™ |
| å¤æ‚åº¦ | ä¸­ç­‰ | é«˜ | ä½ | ä½ |

### æŒç»­å­¦ä¹ å»ºè®®

**æ·±å…¥å­¦ä¹ æ–¹å‘**ï¼š
1. **LuceneåŸç†**ï¼šç†è§£åº•å±‚æœç´¢å¼•æ“å®ç°
2. **ELK Stack**ï¼šæŒæ¡å®Œæ•´çš„æ—¥å¿—åˆ†ææ–¹æ¡ˆ
3. **æœºå™¨å­¦ä¹ **ï¼šå­¦ä¹ Elasticsearch MLåŠŸèƒ½
4. **äº‘æœåŠ¡**ï¼šäº†è§£æ‰˜ç®¡ElasticsearchæœåŠ¡

**å®è·µå»ºè®®**ï¼š
ä»åŸºç¡€çš„ç´¢å¼•å’ŒæŸ¥è¯¢å¼€å§‹ï¼Œé€æ­¥æŒæ¡é«˜çº§ç‰¹æ€§å’Œæ€§èƒ½ä¼˜åŒ–ã€‚é‡è§†ç›‘æ§å’Œè¿ç»´ï¼Œå»ºç«‹å®Œå–„çš„æœç´¢ç³»ç»Ÿç®¡ç†ä½“ç³»ã€‚ 