---
title: "Redisé›†ç¾¤æ¶æ„ä¸é«˜å¯ç”¨æ–¹æ¡ˆæ·±åº¦è§£æ"
description: "æ·±å…¥æ¢è®¨Redis Clusteråˆ†å¸ƒå¼æ¶æ„ã€Redis Sentinelå“¨å…µæ¨¡å¼å’Œä¸»ä»å¤åˆ¶æœºåˆ¶ã€‚æŒæ¡é«˜å¯ç”¨éƒ¨ç½²ç­–ç•¥ã€æ•…éšœè½¬ç§»åŸç†å’Œé›†ç¾¤æ‰©å®¹æŠ€æœ¯ï¼Œæ„å»ºç”Ÿäº§çº§Redisé«˜å¯ç”¨æ–¹æ¡ˆã€‚"
pubDate: 2024-12-28
updatedDate: 2024-12-28
tags: ["redis", "cluster", "high-availability", "sentinel", "replication", "failover", "distributed", "interview"]
categories: ["database"]
subject: "ç¼“å­˜æŠ€æœ¯"
draft: false
featured: true
author: "Gerrad Zhang"
location: "æ­¦æ±‰ï¼Œä¸­å›½"
---

## ğŸ¤” é—®é¢˜èƒŒæ™¯ä¸æŠ€æœ¯æ¼”è¿›

### æˆ‘ä»¬è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

å•æœºRedisåœ¨ç”Ÿäº§ç¯å¢ƒä¸­é¢ä¸´å¤šé‡æŒ‘æˆ˜ï¼š

- **å•ç‚¹æ•…éšœé£é™©**ï¼šRedisæœåŠ¡å™¨å®•æœºå¯¼è‡´æ•´ä¸ªç¼“å­˜ç³»ç»Ÿä¸å¯ç”¨
- **å†…å­˜å®¹é‡é™åˆ¶**ï¼šå•æœºå†…å­˜æœ‰é™ï¼Œæ— æ³•å­˜å‚¨æµ·é‡æ•°æ®
- **æ€§èƒ½ç“¶é¢ˆ**ï¼šå•æœºQPSæœ‰ä¸Šé™ï¼Œæ— æ³•æ”¯æ’‘é«˜å¹¶å‘è®¿é—®
- **æ•°æ®å®‰å…¨æ€§**ï¼šå†…å­˜æ•°æ®æ˜“ä¸¢å¤±ï¼Œéœ€è¦å¯é çš„å¤‡ä»½æœºåˆ¶
- **æ‰©å±•æ€§å·®**ï¼šä¸šåŠ¡å¢é•¿æ—¶éš¾ä»¥åŠ¨æ€æ‰©å®¹

```java
// å•æœºRedisçš„é—®é¢˜ç¤ºä¾‹
public class SingleRedisProblems {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public void demonstrateSinglePointFailure() {
        try {
            // å¤§é‡ä¸šåŠ¡ä¾èµ–Redis
            String userSession = (String) redisTemplate.opsForValue().get("session:user123");
            List<String> shoppingCart = redisTemplate.opsForList().range("cart:user123", 0, -1);
            String userPreferences = (String) redisTemplate.opsForValue().get("prefs:user123");
            
            // å¦‚æœRedisæœåŠ¡å™¨çªç„¶å®•æœº...
            // æ‰€æœ‰ä¾èµ–Redisçš„åŠŸèƒ½éƒ½ä¼šå¤±æ•ˆï¼š
            // - ç”¨æˆ·éœ€è¦é‡æ–°ç™»å½•
            // - è´­ç‰©è½¦æ•°æ®ä¸¢å¤±
            // - ä¸ªæ€§åŒ–æ¨èå¤±æ•ˆ
            // - ç³»ç»Ÿå“åº”æ—¶é—´æ€¥å‰§å¢åŠ 
            
        } catch (Exception e) {
            log.error("Redisè¿æ¥å¤±è´¥ï¼Œç³»ç»ŸåŠŸèƒ½å—å½±å“", e);
            // ä¸šåŠ¡é™çº§å¤„ç†ï¼Œä½†ç”¨æˆ·ä½“éªŒä¸¥é‡å—æŸ
        }
    }
    
    public void demonstrateCapacityLimitation() {
        /*
         * å†…å­˜å®¹é‡é—®é¢˜ï¼š
         * - å•æœºå†…å­˜ï¼š128GB
         * - ä¸šåŠ¡æ•°æ®ï¼š500GB
         * - ç»“æœï¼šæ— æ³•å…¨éƒ¨ç¼“å­˜ï¼Œç¼“å­˜å‘½ä¸­ç‡ä½
         * 
         * æ€§èƒ½ç“¶é¢ˆï¼š
         * - å•æœºQPSï¼š10ä¸‡
         * - ä¸šåŠ¡éœ€æ±‚ï¼š50ä¸‡QPS
         * - ç»“æœï¼šå“åº”æ—¶é—´å¢åŠ ï¼Œç”¨æˆ·ä½“éªŒå·®
         */
    }
}
```

### æ²¡æœ‰è¿™ä¸ªæŠ€æœ¯æ—¶æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ

åœ¨Redisé›†ç¾¤æŠ€æœ¯å‡ºç°ä¹‹å‰ï¼Œå¼€å‘è€…ä¸»è¦é€šè¿‡ä»¥ä¸‹æ–¹å¼è§£å†³é«˜å¯ç”¨é—®é¢˜ï¼š

**1. ä¸»ä»å¤åˆ¶ + æ‰‹åŠ¨åˆ‡æ¢**
```bash
# æ‰‹åŠ¨ä¸»ä»åˆ‡æ¢
redis-cli -h slave-server SLAVEOF NO ONE
# åº”ç”¨ç¨‹åºæ‰‹åŠ¨åˆ‡æ¢è¿æ¥åœ°å€
```
- **é—®é¢˜**ï¼šéœ€è¦äººå·¥å¹²é¢„ï¼Œåˆ‡æ¢æ—¶é—´é•¿ï¼Œå®¹æ˜“å‡ºé”™

**2. å®¢æˆ·ç«¯åˆ†ç‰‡**
```java
// å®¢æˆ·ç«¯ä¸€è‡´æ€§å“ˆå¸Œåˆ†ç‰‡
public class ClientSharding {
    private List<JedisPool> redisPools;
    
    public Jedis getRedisConnection(String key) {
        int hash = key.hashCode();
        int index = Math.abs(hash) % redisPools.size();
        return redisPools.get(index).getResource();
    }
}
```
- **é—®é¢˜**ï¼šæ‰©å®¹å›°éš¾ï¼Œæ•°æ®è¿ç§»å¤æ‚ï¼Œå®¢æˆ·ç«¯é€»è¾‘å¤æ‚

**3. ä»£ç†å±‚æ–¹æ¡ˆ**
- ä½¿ç”¨Twemproxyã€Codisç­‰ä»£ç†
- **é—®é¢˜**ï¼šå¢åŠ ç½‘ç»œå»¶è¿Ÿï¼Œä»£ç†æˆä¸ºæ–°çš„å•ç‚¹

**4. åº”ç”¨å±‚å¤šå†™**
```java
// å¤šä¸ªRediså®ä¾‹åŒæ—¶å†™å…¥
public void writeToMultipleRedis(String key, String value) {
    redis1.set(key, value);
    redis2.set(key, value);
    redis3.set(key, value);
}
```
- **é—®é¢˜**ï¼šæ•°æ®ä¸€è‡´æ€§éš¾ä»¥ä¿è¯ï¼Œæ€§èƒ½å¼€é”€å¤§

### æŠ€æœ¯æ¼”è¿›çš„å†å²è„‰ç»œ

**2010å¹´**: Redis 2.0å¼•å…¥ä¸»ä»å¤åˆ¶
- æ”¯æŒä¸€ä¸»å¤šä»æ¶æ„
- æ•°æ®è‡ªåŠ¨åŒæ­¥åˆ°ä»èŠ‚ç‚¹
- æ‰‹åŠ¨æ•…éšœåˆ‡æ¢

**2012å¹´**: Redis 2.6å¼•å…¥Sentinelå“¨å…µ
- è‡ªåŠ¨æ•…éšœæ£€æµ‹å’Œåˆ‡æ¢
- ä¸»ä»åˆ‡æ¢è‡ªåŠ¨åŒ–
- é…ç½®ç®¡ç†å’Œé€šçŸ¥

**2015å¹´**: Redis 3.0å¼•å…¥Clusteré›†ç¾¤
- åŸç”Ÿåˆ†å¸ƒå¼æ”¯æŒ
- è‡ªåŠ¨æ•°æ®åˆ†ç‰‡ï¼ˆ16384ä¸ªslotï¼‰
- æ— ä¸­å¿ƒåŒ–æ¶æ„

**2016å¹´**: Redis 3.2é›†ç¾¤åŠŸèƒ½å®Œå–„
- é›†ç¾¤é‡å¹³è¡¡ä¼˜åŒ–
- æ•…éšœè½¬ç§»æ”¹è¿›
- ç®¡ç†å·¥å…·å®Œå–„

**2018å¹´**: Redis 5.0é›†ç¾¤å¢å¼º
- Streamæ•°æ®ç±»å‹é›†ç¾¤æ”¯æŒ
- é›†ç¾¤ç®¡ç†å‘½ä»¤æ”¹è¿›
- æ€§èƒ½ä¼˜åŒ–

**2020å¹´è‡³ä»Š**: äº‘åŸç”Ÿé›†ç¾¤
- Kubernetesé›†ç¾¤éƒ¨ç½²
- å®¹å™¨åŒ–é«˜å¯ç”¨æ–¹æ¡ˆ
- å¤šäº‘æ¶æ„æ”¯æŒ

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µä¸åŸç†

### Redisä¸»ä»å¤åˆ¶æœºåˆ¶

**ä¸»ä»å¤åˆ¶**æ˜¯Redisé«˜å¯ç”¨çš„åŸºç¡€ï¼Œå®ç°æ•°æ®å¤‡ä»½å’Œè¯»å†™åˆ†ç¦»ï¼š

```java
/**
 * Redisä¸»ä»å¤åˆ¶æ¶æ„åˆ†æ
 */
public class RedisMasterSlaveAnalysis {
    
    /**
     * ä¸»ä»å¤åˆ¶åŸç†
     */
    public void analyzeMasterSlaveReplication() {
        /*
         * å¤åˆ¶è¿‡ç¨‹ï¼š
         * 1. ä»èŠ‚ç‚¹è¿æ¥ä¸»èŠ‚ç‚¹
         * 2. ä»èŠ‚ç‚¹å‘é€PSYNCå‘½ä»¤è¯·æ±‚åŒæ­¥
         * 3. ä¸»èŠ‚ç‚¹æ‰§è¡ŒBGSAVEç”ŸæˆRDBå¿«ç…§
         * 4. ä¸»èŠ‚ç‚¹å°†RDBæ–‡ä»¶å‘é€ç»™ä»èŠ‚ç‚¹
         * 5. ä»èŠ‚ç‚¹åŠ è½½RDBæ–‡ä»¶æ¢å¤æ•°æ®
         * 6. ä¸»èŠ‚ç‚¹å°†ç¼“å†²åŒºçš„å†™å‘½ä»¤å‘é€ç»™ä»èŠ‚ç‚¹
         * 7. åç»­å†™å‘½ä»¤å®æ—¶åŒæ­¥
         * 
         * åŒæ­¥ç±»å‹ï¼š
         * - å…¨é‡åŒæ­¥ï¼šé¦–æ¬¡è¿æ¥æˆ–é•¿æ—¶é—´æ–­å¼€åé‡è¿
         * - å¢é‡åŒæ­¥ï¼šæ­£å¸¸è¿è¡Œæ—¶çš„å®æ—¶åŒæ­¥
         * - éƒ¨åˆ†åŒæ­¥ï¼šçŸ­æš‚æ–­å¼€åçš„å¿«é€Ÿæ¢å¤
         */
    }
    
    /**
     * ä¸»ä»å¤åˆ¶é…ç½®
     */
    public void configureMasterSlave() {
        /*
         * ä¸»èŠ‚ç‚¹é…ç½®ï¼ˆredis-master.confï¼‰ï¼š
         * bind 0.0.0.0
         * port 6379
         * requirepass master_password
         * 
         * # ä¸»ä»å¤åˆ¶å®‰å…¨
         * masterauth master_password
         * 
         * # å¤åˆ¶ç›¸å…³é…ç½®
         * repl-diskless-sync no          # ä½¿ç”¨ç£ç›˜å¤åˆ¶
         * repl-diskless-sync-delay 5     # å»¶è¿Ÿ5ç§’å¼€å§‹å¤åˆ¶
         * 
         * ä»èŠ‚ç‚¹é…ç½®ï¼ˆredis-slave.confï¼‰ï¼š
         * bind 0.0.0.0
         * port 6380
         * 
         * # æŒ‡å®šä¸»èŠ‚ç‚¹
         * replicaof 192.168.1.100 6379
         * masterauth master_password
         * 
         * # ä»èŠ‚ç‚¹åªè¯»
         * replica-read-only yes
         * 
         * # å¤åˆ¶è¶…æ—¶é…ç½®
         * repl-timeout 60
         */
    }
    
    /**
     * è¯»å†™åˆ†ç¦»å®ç°
     */
    public void implementReadWriteSeparation() {
        /*
         * Spring Booté…ç½®è¯»å†™åˆ†ç¦»ï¼š
         */
    }
}

@Configuration
public class RedisReadWriteConfig {
    
    @Bean
    @Primary
    public LettuceConnectionFactory masterConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("redis-master.example.com");
        config.setPort(6379);
        config.setPassword("master_password");
        return new LettuceConnectionFactory(config);
    }
    
    @Bean
    public LettuceConnectionFactory slaveConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("redis-slave.example.com");
        config.setPort(6380);
        config.setPassword("master_password");
        return new LettuceConnectionFactory(config);
    }
    
    @Bean
    public RedisTemplate<String, Object> masterRedisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(masterConnectionFactory());
        // åºåˆ—åŒ–é…ç½®...
        return template;
    }
    
    @Bean
    public RedisTemplate<String, Object> slaveRedisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(slaveConnectionFactory());
        // åºåˆ—åŒ–é…ç½®...
        return template;
    }
}
```

### Redis Sentinelå“¨å…µæ¨¡å¼

**Sentinel**æä¾›è‡ªåŠ¨æ•…éšœæ£€æµ‹å’Œåˆ‡æ¢åŠŸèƒ½ï¼š

```java
/**
 * Redis Sentinelæ¶æ„åˆ†æ
 */
public class RedisSentinelAnalysis {
    
    /**
     * Sentinelå·¥ä½œåŸç†
     */
    public void analyzeSentinelMechanism() {
        /*
         * SentinelåŠŸèƒ½ï¼š
         * 1. ç›‘æ§ï¼šæŒç»­ç›‘æ§ä¸»ä»èŠ‚ç‚¹å¥åº·çŠ¶æ€
         * 2. é€šçŸ¥ï¼šå‘ç®¡ç†å‘˜å‘é€æ•…éšœé€šçŸ¥
         * 3. æ•…éšœè½¬ç§»ï¼šè‡ªåŠ¨å°†ä»èŠ‚ç‚¹æå‡ä¸ºä¸»èŠ‚ç‚¹
         * 4. é…ç½®ç®¡ç†ï¼šä¸ºå®¢æˆ·ç«¯æä¾›å½“å‰ä¸»èŠ‚ç‚¹ä¿¡æ¯
         * 
         * å·¥ä½œæµç¨‹ï¼š
         * 1. Sentinelå®šæœŸå‘ä¸»ä»èŠ‚ç‚¹å‘é€PINGå‘½ä»¤
         * 2. å¦‚æœä¸»èŠ‚ç‚¹åœ¨æŒ‡å®šæ—¶é—´å†…æœªå“åº”ï¼Œæ ‡è®°ä¸ºä¸»è§‚ä¸‹çº¿
         * 3. è¯¢é—®å…¶ä»–Sentinelï¼Œç¡®è®¤ä¸»èŠ‚ç‚¹å®¢è§‚ä¸‹çº¿
         * 4. é€‰ä¸¾Leader Sentinelæ‰§è¡Œæ•…éšœè½¬ç§»
         * 5. é€‰æ‹©åˆé€‚çš„ä»èŠ‚ç‚¹æå‡ä¸ºæ–°ä¸»èŠ‚ç‚¹
         * 6. æ›´æ–°å…¶ä»–ä»èŠ‚ç‚¹çš„å¤åˆ¶ç›®æ ‡
         * 7. é€šçŸ¥å®¢æˆ·ç«¯æ–°çš„ä¸»èŠ‚ç‚¹ä¿¡æ¯
         */
    }
    
    /**
     * Sentinelé…ç½®
     */
    public void configureSentinel() {
        /*
         * sentinel.confé…ç½®ï¼š
         * 
         * # Sentinelç«¯å£
         * port 26379
         * 
         * # ç›‘æ§ä¸»èŠ‚ç‚¹
         * sentinel monitor mymaster 192.168.1.100 6379 2
         * 
         * # è®¤è¯å¯†ç 
         * sentinel auth-pass mymaster master_password
         * 
         * # ä¸»è§‚ä¸‹çº¿æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
         * sentinel down-after-milliseconds mymaster 30000
         * 
         * # æ•…éšœè½¬ç§»è¶…æ—¶æ—¶é—´
         * sentinel failover-timeout mymaster 180000
         * 
         * # åŒæ—¶è¿›è¡Œå¤åˆ¶çš„ä»èŠ‚ç‚¹æ•°é‡
         * sentinel parallel-syncs mymaster 1
         * 
         * # é€šçŸ¥è„šæœ¬
         * sentinel notification-script mymaster /var/redis/notify.sh
         * 
         * # å®¢æˆ·ç«¯é‡æ–°é…ç½®è„šæœ¬
         * sentinel client-reconfig-script mymaster /var/redis/reconfig.sh
         */
    }
}
```

### Redis Clusteré›†ç¾¤æ¶æ„

**Redis Cluster**æä¾›åŸç”Ÿçš„åˆ†å¸ƒå¼è§£å†³æ–¹æ¡ˆï¼š

```java
/**
 * Redis Clusteræ¶æ„åˆ†æ
 */
public class RedisClusterAnalysis {
    
    /**
     * Clusteråˆ†ç‰‡åŸç†
     */
    public void analyzeClusterSharding() {
        /*
         * æ•°æ®åˆ†ç‰‡æœºåˆ¶ï¼š
         * 1. 16384ä¸ªå“ˆå¸Œæ§½ï¼ˆHash Slotï¼‰
         * 2. æ¯ä¸ªKeyé€šè¿‡CRC16ç®—æ³•è®¡ç®—æ§½ä½
         * 3. æ¯ä¸ªèŠ‚ç‚¹è´Ÿè´£ä¸€éƒ¨åˆ†æ§½ä½
         * 4. å®¢æˆ·ç«¯æ ¹æ®æ§½ä½è·¯ç”±è¯·æ±‚
         * 
         * æ§½ä½è®¡ç®—ï¼š
         * slot = CRC16(key) % 16384
         * 
         * é›†ç¾¤æ‹“æ‰‘ï¼š
         * - æœ€å°‘3ä¸ªä¸»èŠ‚ç‚¹
         * - æ¯ä¸ªä¸»èŠ‚ç‚¹å¯é…ç½®å¤šä¸ªä»èŠ‚ç‚¹
         * - èŠ‚ç‚¹é—´é€šè¿‡Gossipåè®®é€šä¿¡
         * - æ— ä¸­å¿ƒåŒ–æ¶æ„ï¼Œä»»æ„èŠ‚ç‚¹å¯æ¥æ”¶è¯·æ±‚
         */
    }
    
    /**
     * æ•…éšœè½¬ç§»æœºåˆ¶
     */
    public void analyzeFailoverMechanism() {
        /*
         * æ•…éšœæ£€æµ‹ï¼š
         * 1. èŠ‚ç‚¹é—´å®šæœŸå‘é€PINGæ¶ˆæ¯
         * 2. è¶…æ—¶æœªå“åº”æ ‡è®°ä¸ºPFAILï¼ˆå¯èƒ½å¤±è´¥ï¼‰
         * 3. å¤šæ•°èŠ‚ç‚¹ç¡®è®¤åæ ‡è®°ä¸ºFAILï¼ˆç¡®è®¤å¤±è´¥ï¼‰
         * 
         * è‡ªåŠ¨æ•…éšœè½¬ç§»ï¼š
         * 1. ä»èŠ‚ç‚¹æ£€æµ‹åˆ°ä¸»èŠ‚ç‚¹å¤±è´¥
         * 2. ä»èŠ‚ç‚¹å‘èµ·é€‰ä¸¾æˆä¸ºæ–°ä¸»èŠ‚ç‚¹
         * 3. æ–°ä¸»èŠ‚ç‚¹æ¥ç®¡åŸä¸»èŠ‚ç‚¹çš„æ§½ä½
         * 4. æ›´æ–°é›†ç¾¤é…ç½®å¹¶å¹¿æ’­
         * 
         * é€‰ä¸¾ç®—æ³•ï¼š
         * - åŸºäºRaftç®—æ³•çš„ç®€åŒ–ç‰ˆæœ¬
         * - å¤åˆ¶åç§»é‡å¤§çš„ä»èŠ‚ç‚¹ä¼˜å…ˆ
         * - èŠ‚ç‚¹IDå°çš„ä»èŠ‚ç‚¹ä¼˜å…ˆï¼ˆtie-breakerï¼‰
         */
    }
    
    /**
     * é›†ç¾¤æ‰©å®¹æœºåˆ¶
     */
    public void analyzeClusterScaling() {
        /*
         * æ‰©å®¹æµç¨‹ï¼š
         * 1. æ·»åŠ æ–°èŠ‚ç‚¹åˆ°é›†ç¾¤
         * 2. åˆ†é…æ§½ä½ç»™æ–°èŠ‚ç‚¹
         * 3. è¿ç§»æ•°æ®åˆ°æ–°èŠ‚ç‚¹
         * 4. æ›´æ–°é›†ç¾¤æ‹“æ‰‘
         * 
         * æ•°æ®è¿ç§»ï¼š
         * - é€ä¸ªæ§½ä½è¿ç§»
         * - æºèŠ‚ç‚¹æ ‡è®°æ§½ä½ä¸ºè¿ç§»ä¸­
         * - é€ä¸ªKeyè¿ç§»åˆ°ç›®æ ‡èŠ‚ç‚¹
         * - è¿ç§»å®Œæˆåæ›´æ–°æ§½ä½å½’å±
         * 
         * ç¼©å®¹æµç¨‹ï¼š
         * 1. å°†èŠ‚ç‚¹çš„æ§½ä½è¿ç§»åˆ°å…¶ä»–èŠ‚ç‚¹
         * 2. ç¡®è®¤èŠ‚ç‚¹æ— æ§½ä½åç§»é™¤
         * 3. æ›´æ–°é›†ç¾¤é…ç½®
         */
    }
}
``` 

## ğŸ”§ å®ç°åŸç†ä¸æºç åˆ†æ

### ä¸»ä»å¤åˆ¶æºç å®ç°

**ä¸»ä»å¤åˆ¶çš„æ ¸å¿ƒå®ç°ä½äº`replication.c`æ–‡ä»¶ä¸­**ï¼š

```c
// Redisä¸»ä»å¤åˆ¶æ ¸å¿ƒä»£ç åˆ†æ
/**
 * PSYNCå‘½ä»¤å®ç° - éƒ¨åˆ†é‡åŒæ­¥
 */
void syncCommand(client *c) {
    /* PSYNCå‘½ä»¤æ ¼å¼: PSYNC <repl_id> <offset> */
    if (!strcasecmp(c->argv[0]->ptr,"psync")) {
        if (c->argc != 3) {
            addReplyError(c, "Wrong number of arguments for PSYNC");
            return;
        }
        
        // è·å–å¤åˆ¶IDå’Œåç§»é‡
        char *master_replid = c->argv[1]->ptr;
        char *offset = c->argv[2]->ptr;
        long long psync_offset;
        
        if (getLongLongFromObjectOrReply(c, c->argv[2], &psync_offset, NULL) != C_OK)
            return;
        
        // åˆ¤æ–­æ˜¯å¦å¯ä»¥è¿›è¡Œéƒ¨åˆ†é‡åŒæ­¥
        if (masterTryPartialResynchronization(c, psync_offset) == C_OK) {
            server.stat_sync_partial_ok++;
            return; /* éƒ¨åˆ†é‡åŒæ­¥æˆåŠŸ */
        } else {
            server.stat_sync_full++;
            /* æ‰§è¡Œå…¨é‡é‡åŒæ­¥ */
        }
    }
    
    // å…¨é‡é‡åŒæ­¥æµç¨‹
    c->flags |= CLIENT_SLAVE;
    c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
    
    // å¦‚æœæ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„BGSAVEï¼Œå¯åŠ¨æ–°çš„BGSAVE
    if (server.rdb_child_pid == -1) {
        if (startBgsaveForReplication(c->slave_req) != C_OK) {
            addReplyError(c, "Unable to perform background save");
            return;
        }
    }
    
    // å°†å®¢æˆ·ç«¯æ·»åŠ åˆ°ç­‰å¾…åˆ—è¡¨
    listAddNodeTail(server.slaves, c);
}

/**
 * ä¸»èŠ‚ç‚¹å‘ä»èŠ‚ç‚¹å‘é€RDBæ–‡ä»¶
 */
void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
    listNode *ln;
    listIter li;
    
    listRewind(server.slaves, &li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        
        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
            slave->replstate = SLAVE_STATE_WAIT_BGSAVE_END;
        } else if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
            struct stat buf;
            
            if (bgsaveerr != C_OK) {
                freeClient(slave);
                continue;
            }
            
            // æ‰“å¼€RDBæ–‡ä»¶å‡†å¤‡å‘é€
            if ((slave->repldbfd = open(server.rdb_filename, O_RDONLY)) == -1 ||
                fstat(slave->repldbfd, &buf) == -1) {
                freeClient(slave);
                continue;
            }
            
            // è®°å½•RDBæ–‡ä»¶å¤§å°å’Œå‘é€è¿›åº¦
            slave->repldboff = 0;
            slave->repldbsize = buf.st_size;
            slave->replstate = SLAVE_STATE_SEND_BULK;
            slave->replpreamble = sdscatprintf(sdsempty(),
                "$%lld\r\n", (unsigned long long) slave->repldbsize);
            
            // æ³¨å†Œå†™äº‹ä»¶ï¼Œå‡†å¤‡å‘é€RDBæ•°æ®
            aeCreateFileEvent(server.el, slave->fd, AE_WRITABLE, sendBulkToSlave, slave);
        }
    }
}

/**
 * å‘é€RDBæ•°æ®åˆ°ä»èŠ‚ç‚¹
 */
void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {
    client *slave = privdata;
    char buf[PROTO_IOBUF_LEN];
    ssize_t nwritten, buflen;
    
    // å…ˆå‘é€RDBæ–‡ä»¶å¤§å°ä¿¡æ¯
    if (slave->replpreamble) {
        nwritten = connWrite(slave->conn, slave->replpreamble, sdslen(slave->replpreamble));
        if (nwritten == -1) {
            freeClient(slave);
            return;
        }
        slave->replpreamble = sdsrange(slave->replpreamble, nwritten, -1);
        if (sdslen(slave->replpreamble) == 0) {
            sdsfree(slave->replpreamble);
            slave->replpreamble = NULL;
        } else {
            return;
        }
    }
    
    // å‘é€RDBæ–‡ä»¶å†…å®¹
    lseek(slave->repldbfd, slave->repldboff, SEEK_SET);
    buflen = read(slave->repldbfd, buf, PROTO_IOBUF_LEN);
    if (buflen <= 0) {
        if (buflen == 0) {
            // RDBæ–‡ä»¶å‘é€å®Œæˆ
            close(slave->repldbfd);
            slave->repldbfd = -1;
            aeDeleteFileEvent(server.el, slave->fd, AE_WRITABLE);
            slave->replstate = SLAVE_STATE_ONLINE;
            
            // å‘é€ç¼“å†²åŒºä¸­çš„å†™å‘½ä»¤
            if (aeCreateFileEvent(server.el, slave->fd, AE_WRITABLE,
                sendReplyToClient, slave) == AE_ERR) {
                freeClient(slave);
                return;
            }
            slave->repldboff = 0;
        } else {
            freeClient(slave);
            return;
        }
        return;
    }
    
    // å†™å…¥ç½‘ç»œç¼“å†²åŒº
    if ((nwritten = connWrite(slave->conn, buf, buflen)) == -1) {
        freeClient(slave);
        return;
    }
    slave->repldboff += nwritten;
    
    // æ›´æ–°ç½‘ç»œç»Ÿè®¡
    server.stat_net_output_bytes += nwritten;
}

/**
 * å®æ—¶åŒæ­¥å†™å‘½ä»¤åˆ°ä»èŠ‚ç‚¹
 */
void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
    listNode *ln;
    listIter li;
    int j, len;
    char llstr[LONG_STR_SIZE];
    
    // å¦‚æœæ²¡æœ‰ä»èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
    if (listLength(slaves) == 0) return;
    
    // æ„é€ Redisåè®®æ ¼å¼çš„å‘½ä»¤
    robj **outv;
    int outc = 0, j;
    
    // å¦‚æœéœ€è¦åˆ‡æ¢æ•°æ®åº“
    if (server.slaveseldb != dictid) {
        robj *selectcmd;
        
        if (dictid >= 0 && dictid < PROTO_SHARED_SELECT_CMDS) {
            selectcmd = shared.select[dictid];
        } else {
            int dictid_len = ll2string(llstr, sizeof(llstr), dictid);
            selectcmd = createObject(OBJ_STRING,
                sdscatprintf(sdsempty(), "*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n",
                    dictid_len, llstr));
        }
        
        // å‘é€SELECTå‘½ä»¤åˆ°æ‰€æœ‰ä»èŠ‚ç‚¹
        listRewind(slaves, &li);
        while((ln = listNext(&li))) {
            client *slave = ln->value;
            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
            addReply(slave, selectcmd);
        }
        
        if (dictid < 0 || dictid >= PROTO_SHARED_SELECT_CMDS)
            decrRefCount(selectcmd);
    }
    server.slaveseldb = dictid;
    
    // å‘é€å®é™…çš„å†™å‘½ä»¤
    listRewind(slaves, &li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        
        // åªå‘åœ¨çº¿çš„ä»èŠ‚ç‚¹å‘é€å‘½ä»¤
        if (slave->replstate != SLAVE_STATE_ONLINE) continue;
        
        // æ·»åŠ å‘½ä»¤åˆ°ä»èŠ‚ç‚¹çš„è¾“å‡ºç¼“å†²åŒº
        addReplyArrayLen(slave, argc);
        for (j = 0; j < argc; j++) {
            addReplyBulk(slave, argv[j]);
        }
    }
}
```

### Sentinelå“¨å…µæºç å®ç°

**Sentinelçš„æ ¸å¿ƒå®ç°ä½äº`sentinel.c`æ–‡ä»¶ä¸­**ï¼š

```c
// Redis Sentinelæ ¸å¿ƒä»£ç åˆ†æ
/**
 * Sentinelä¸»å¾ªç¯ - ç›‘æ§å’Œæ•…éšœæ£€æµ‹
 */
void sentinelTimer(void) {
    sentinelCheckTiltCondition();
    sentinelHandleDictOfRedisInstances(sentinel.masters);
    sentinelRunPendingScripts();
    sentinelCollectTerminatedScripts();
    sentinelKillTimedoutScripts();
    
    // å¤„ç†é‡æ–°é…ç½®çŠ¶æ€
    sentinelHandleRedisInstance(sentinel.masters);
}

/**
 * æ£€æŸ¥Rediså®ä¾‹çŠ¶æ€
 */
void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
    /* å‘é€PINGå‘½ä»¤æ£€æŸ¥å®ä¾‹çŠ¶æ€ */
    sentinelSendPeriodicCommands(ri);
    
    /* æ£€æŸ¥ä¸»è§‚ä¸‹çº¿çŠ¶æ€ */
    sentinelCheckSubjectivelyDown(ri);
    
    /* æ£€æŸ¥å®¢è§‚ä¸‹çº¿çŠ¶æ€ï¼ˆä»…å¯¹ä¸»èŠ‚ç‚¹ï¼‰ */
    if (ri->flags & SRI_MASTER) {
        sentinelCheckObjectivelyDown(ri);
        
        /* å¦‚æœä¸»èŠ‚ç‚¹å®¢è§‚ä¸‹çº¿ï¼Œå¼€å§‹æ•…éšœè½¬ç§» */
        if (sentinelStartFailoverIfNeeded(ri))
            sentinelAskMasterStateToOtherSentinels(ri, SENTINEL_ASK_FORCED);
        
        /* æ‰§è¡Œæ•…éšœè½¬ç§»æ­¥éª¤ */
        sentinelFailoverStateMachine(ri);
        
        /* å‘å…¶ä»–Sentinelè¯¢é—®ä¸»èŠ‚ç‚¹çŠ¶æ€ */
        sentinelAskMasterStateToOtherSentinels(ri, SENTINEL_NO_FLAGS);
    }
}

/**
 * æ£€æŸ¥ä¸»è§‚ä¸‹çº¿çŠ¶æ€
 */
void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
    mstime_t elapsed = 0;
    
    if (ri->link->last_pong_time)
        elapsed = mstime() - ri->link->last_pong_time;
    else if (ri->link->last_ping_time)
        elapsed = mstime() - ri->link->last_ping_time;
    
    /* å¦‚æœè¶…è¿‡down-after-millisecondsæ—¶é—´æ²¡æœ‰å“åº” */
    if (elapsed > ri->down_after_period) {
        /* æ ‡è®°ä¸ºä¸»è§‚ä¸‹çº¿ */
        if ((ri->flags & SRI_S_DOWN) == 0) {
            sentinelEvent(LL_WARNING, "+sdown", ri, "%@");
            ri->s_down_since_time = mstime();
            ri->flags |= SRI_S_DOWN;
        }
    } else {
        /* æ¢å¤æ­£å¸¸çŠ¶æ€ */
        if (ri->flags & SRI_S_DOWN) {
            sentinelEvent(LL_WARNING, "-sdown", ri, "%@");
            ri->flags &= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);
        }
    }
}

/**
 * æ£€æŸ¥å®¢è§‚ä¸‹çº¿çŠ¶æ€
 */
void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    unsigned int quorum = 0, odown = 0;
    
    /* ä¸»èŠ‚ç‚¹å¿…é¡»å…ˆä¸»è§‚ä¸‹çº¿ */
    if (master->flags & SRI_S_DOWN) {
        quorum = 1; /* å½“å‰Sentinelè®¤ä¸ºä¸‹çº¿ */
        
        /* ç»Ÿè®¡å…¶ä»–Sentinelçš„æŠ•ç¥¨ */
        di = dictGetIterator(master->sentinels);
        while((de = dictNext(di)) != NULL) {
            sentinelRedisInstance *ri = dictGetVal(de);
            
            if (ri->flags & SRI_MASTER_DOWN) quorum++;
        }
        dictReleaseIterator(di);
        
        /* å¦‚æœè¾¾åˆ°quorumæ•°é‡ï¼Œæ ‡è®°ä¸ºå®¢è§‚ä¸‹çº¿ */
        if (quorum >= master->quorum) odown = 1;
    }
    
    /* æ›´æ–°å®¢è§‚ä¸‹çº¿çŠ¶æ€ */
    if (odown) {
        if ((master->flags & SRI_O_DOWN) == 0) {
            sentinelEvent(LL_WARNING, "+odown", master, "%@ #quorum %d/%d",
                quorum, master->quorum);
            master->flags |= SRI_O_DOWN;
            master->o_down_since_time = mstime();
        }
    } else {
        if (master->flags & SRI_O_DOWN) {
            sentinelEvent(LL_WARNING, "-odown", master, "%@");
            master->flags &= ~SRI_O_DOWN;
        }
    }
}

/**
 * æ•…éšœè½¬ç§»çŠ¶æ€æœº
 */
void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
    if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS)) return;
    
    switch(ri->failover_state) {
        case SENTINEL_FAILOVER_STATE_WAIT_START:
            sentinelFailoverWaitStart(ri);
            break;
        case SENTINEL_FAILOVER_STATE_SELECT_SLAVE:
            sentinelFailoverSelectSlave(ri);
            break;
        case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:
            sentinelFailoverSendSlaveOfNoOne(ri);
            break;
        case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:
            sentinelFailoverWaitPromotion(ri);
            break;
        case SENTINEL_FAILOVER_STATE_RECONF_SLAVES:
            sentinelFailoverReconfNextSlave(ri);
            break;
    }
}

/**
 * é€‰æ‹©æœ€ä½³ä»èŠ‚ç‚¹è¿›è¡Œæå‡
 */
sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {
    sentinelRedisInstance **instance =
        zmalloc(sizeof(instance[0]) * dictSize(master->slaves));
    sentinelRedisInstance *selected = NULL;
    int instances = 0;
    dictIterator *di;
    dictEntry *de;
    mstime_t max_master_down_time = 0;
    
    /* æ”¶é›†å¯ç”¨çš„ä»èŠ‚ç‚¹ */
    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);
        mstime_t info_validity_time;
        
        /* è·³è¿‡ä¸‹çº¿çš„ä»èŠ‚ç‚¹ */
        if (slave->flags & (SRI_S_DOWN|SRI_O_DOWN)) continue;
        
        /* è·³è¿‡æ–­å¼€è¿æ¥çš„ä»èŠ‚ç‚¹ */
        if (slave->link->disconnected) continue;
        
        /* è·³è¿‡å¤åˆ¶å»¶è¿Ÿè¿‡å¤§çš„ä»èŠ‚ç‚¹ */
        if (mstime() - slave->slave_repl_offset_time > SENTINEL_INFO_PERIOD*5)
            continue;
        
        /* è·³è¿‡ä¼˜å…ˆçº§ä¸º0çš„ä»èŠ‚ç‚¹ï¼ˆä¸å‚ä¸é€‰ä¸¾ï¼‰ */
        if (slave->slave_priority == 0) continue;
        
        instance[instances++] = slave;
    }
    dictReleaseIterator(di);
    
    /* æ ¹æ®ä¼˜å…ˆçº§ã€å¤åˆ¶åç§»é‡ã€è¿è¡ŒIDæ’åº */
    if (instances) {
        qsort(instance, instances, sizeof(sentinelRedisInstance*),
              compareSlavesForPromotion);
        selected = instance[0];
    }
    zfree(instance);
    return selected;
}
```

### Clusteré›†ç¾¤æºç å®ç°

**Redis Clusterçš„æ ¸å¿ƒå®ç°ä½äº`cluster.c`æ–‡ä»¶ä¸­**ï¼š

```c
// Redis Clusteræ ¸å¿ƒä»£ç åˆ†æ
/**
 * é›†ç¾¤æ§½ä½åˆ†é…å’Œè·¯ç”±
 */
int clusterProcessCommand(client *c) {
    /* å¦‚æœä¸æ˜¯é›†ç¾¤æ¨¡å¼ï¼Œæ­£å¸¸å¤„ç†å‘½ä»¤ */
    if (!(server.cluster_enabled)) return 0;
    
    /* å¤šé”®å‘½ä»¤çš„æ§½ä½æ£€æŸ¥ */
    if (server.cluster->state != CLUSTER_OK) {
        if (!(c->cmd->flags & CMD_ASKING)) {
            addReplySds(c, sdsnew("-CLUSTERDOWN The cluster is down\r\n"));
            return 1;
        }
    }
    
    /* è®¡ç®—å‘½ä»¤æ¶‰åŠçš„æ§½ä½ */
    int hashslot;
    int error_code;
    clusterNode *n = getNodeByQuery(c, c->cmd, c->argv, c->argc, &hashslot, &error_code);
    
    if (n == NULL || n != server.cluster->myself) {
        if (c->cmd->flags & CMD_ASKING) {
            clusterRedirectClient(c, n, hashslot, CLUSTER_REDIR_ASK);
        } else {
            clusterRedirectClient(c, n, hashslot, CLUSTER_REDIR_MOVED);
        }
        return 1;
    }
    
    /* åœ¨å½“å‰èŠ‚ç‚¹æ‰§è¡Œå‘½ä»¤ */
    return 0;
}

/**
 * æ ¹æ®Keyè®¡ç®—æ§½ä½
 */
unsigned int keyHashSlot(char *key, int keylen) {
    int s, e; /* start-end indexes of { and } */
    
    /* æŸ¥æ‰¾å“ˆå¸Œæ ‡ç­¾ {...} */
    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;
    
    /* æ²¡æœ‰æ‰¾åˆ° { ï¼Œä½¿ç”¨æ•´ä¸ªkey */
    if (s == keylen) return crc16(key, keylen) & 0x3FFF;
    
    /* æŸ¥æ‰¾åŒ¹é…çš„ } */
    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;
    
    /* æ²¡æœ‰æ‰¾åˆ° } æˆ–è€… {} ä¸ºç©ºï¼Œä½¿ç”¨æ•´ä¸ªkey */
    if (e == keylen || e == s+1) return crc16(key, keylen) & 0x3FFF;
    
    /* ä½¿ç”¨ {tag} ä¸­çš„å†…å®¹è®¡ç®—æ§½ä½ */
    return crc16(key+s+1, e-s-1) & 0x3FFF;
}

/**
 * é›†ç¾¤æ•…éšœæ£€æµ‹
 */
void clusterCron(void) {
    dictIterator *di;
    dictEntry *de;
    int update_state = 0;
    int orphaned_masters; /* Masters with no working slaves. */
    int max_slaves; /* Max number of slaves for a single master. */
    int this_slaves; /* Number of slaves for our master (if we are slave). */
    mstime_t min_pong = 0, now = mstime();
    clusterNode *min_pong_node = NULL;
    
    /* éå†æ‰€æœ‰å·²çŸ¥èŠ‚ç‚¹ */
    di = dictGetIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        
        /* è·³è¿‡è‡ªå·±å’Œæ¡æ‰‹ä¸­çš„èŠ‚ç‚¹ */
        if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE)) continue;
        
        /* æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦è¶…æ—¶ */
        if (!(node->flags & CLUSTER_NODE_NOADDR) &&
            node->pong_received &&
            (now - node->pong_received) > server.cluster_node_timeout)
        {
            /* æ ‡è®°èŠ‚ç‚¹ä¸ºå¯èƒ½å¤±è´¥ */
            node->flags |= CLUSTER_NODE_PFAIL;
            update_state = 1;
        }
    }
    dictReleaseIterator(di);
    
    /* æ£€æŸ¥æ˜¯å¦æœ‰èŠ‚ç‚¹è¢«æ ‡è®°ä¸ºFAIL */
    di = dictGetIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        int needed_quorum = (server.cluster->size / 2) + 1;
        
        if (node->flags & CLUSTER_NODE_PFAIL) {
            int failure_reports = clusterNodeFailureReportsCount(node);
            
            /* å¦‚æœæ•…éšœæŠ¥å‘Šæ•°é‡è¾¾åˆ°quorumï¼Œæ ‡è®°ä¸ºFAIL */
            if (failure_reports >= needed_quorum) {
                node->flags &= ~CLUSTER_NODE_PFAIL;
                node->flags |= CLUSTER_NODE_FAIL;
                node->fail_time = mstime();
                
                /* å¹¿æ’­FAILæ¶ˆæ¯ */
                clusterSendFail(node->name);
                clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|
                                   CLUSTER_TODO_SAVE_CONFIG);
                update_state = 1;
            }
        }
    }
    dictReleaseIterator(di);
    
    /* å¦‚æœæˆ‘ä»¬æ˜¯ä»èŠ‚ç‚¹ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è¿›è¡Œæ•…éšœè½¬ç§» */
    if (nodeIsSlave(server.cluster->myself) &&
        server.cluster->myself->slaveof &&
        nodeTimedOut(server.cluster->myself->slaveof))
    {
        clusterHandleSlaveFailover();
    }
    
    /* æ›´æ–°é›†ç¾¤çŠ¶æ€ */
    if (update_state || server.cluster->state == CLUSTER_FAIL)
        clusterUpdateState();
}

/**
 * ä»èŠ‚ç‚¹æ•…éšœè½¬ç§»å¤„ç†
 */
void clusterHandleSlaveFailover(void) {
    mstime_t data_age;
    mstime_t auth_age = mstime() - server.cluster->failover_auth_time;
    int needed_quorum = (server.cluster->size / 2) + 1;
    int manual_failover = server.cluster->mf_end != 0 &&
                          server.cluster->mf_can_start;
    mstime_t auth_timeout, auth_retry_time;
    
    server.cluster->todo_before_sleep &= ~CLUSTER_TODO_HANDLE_FAILOVER;
    
    /* è®¡ç®—æ•°æ®å¹´é¾„ */
    data_age = (server.unixtime - server.cluster->myself->slaveof->ping_sent) * 1000;
    
    /* å¦‚æœæ•°æ®å¤ªæ—§ï¼Œä¸è¿›è¡Œæ•…éšœè½¬ç§» */
    if (data_age > server.cluster_node_timeout * CLUSTER_SLAVE_VALIDITY_MULT)
        return;
    
    /* å¦‚æœè¿˜æ²¡æœ‰è¯·æ±‚æŠ•ç¥¨æƒé™ï¼Œå‘èµ·æŠ•ç¥¨ */
    if (server.cluster->failover_auth_sent == 0) {
        server.cluster->currentEpoch++;
        server.cluster->failover_auth_epoch = server.cluster->currentEpoch;
        server.cluster->failover_auth_sent = 1;
        server.cluster->failover_auth_time = mstime() +
            500 + random() % 500; /* æ·»åŠ éšæœºå»¶è¿Ÿé¿å…å†²çª */
        
        /* å‘æ‰€æœ‰ä¸»èŠ‚ç‚¹è¯·æ±‚æŠ•ç¥¨ */
        clusterRequestFailoverAuth();
        return;
    }
    
    /* æ£€æŸ¥æ˜¯å¦è·å¾—è¶³å¤Ÿçš„æŠ•ç¥¨ */
    if (server.cluster->failover_auth_count >= needed_quorum) {
        /* è·å¾—è¶³å¤ŸæŠ•ç¥¨ï¼Œå¼€å§‹æ•…éšœè½¬ç§» */
        clusterFailoverReplaceYourMaster();
    }
}
``` 

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹ä¸ä»£ç ç¤ºä¾‹

### ä¸»ä»å¤åˆ¶å®æˆ˜éƒ¨ç½²

**å®Œæ•´çš„ä¸»ä»å¤åˆ¶ç¯å¢ƒæ­å»º**ï¼š

```java
/**
 * Redisä¸»ä»å¤åˆ¶å®Œæ•´å®ç°
 */
@Configuration
@EnableConfigurationProperties(RedisProperties.class)
public class RedisReplicationConfig {
    
    @Value("${redis.master.host:localhost}")
    private String masterHost;
    
    @Value("${redis.master.port:6379}")
    private int masterPort;
    
    @Value("${redis.slave.host:localhost}")
    private String slaveHost;
    
    @Value("${redis.slave.port:6380}")
    private int slavePort;
    
    @Value("${redis.password}")
    private String password;
    
    /**
     * ä¸»èŠ‚ç‚¹è¿æ¥å·¥å‚
     */
    @Bean
    @Primary
    public LettuceConnectionFactory masterConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName(masterHost);
        config.setPort(masterPort);
        config.setPassword(password);
        
        // è¿æ¥æ± é…ç½®
        GenericObjectPoolConfig<StatefulRedisConnection<String, String>> poolConfig = 
            new GenericObjectPoolConfig<>();
        poolConfig.setMaxTotal(20);
        poolConfig.setMaxIdle(10);
        poolConfig.setMinIdle(5);
        poolConfig.setTestOnBorrow(true);
        poolConfig.setTestOnReturn(true);
        poolConfig.setTestWhileIdle(true);
        
        LettucePoolingClientConfiguration clientConfig = LettucePoolingClientConfiguration.builder()
            .poolConfig(poolConfig)
            .commandTimeout(Duration.ofSeconds(5))
            .shutdownTimeout(Duration.ofSeconds(10))
            .build();
        
        return new LettuceConnectionFactory(config, clientConfig);
    }
    
    /**
     * ä»èŠ‚ç‚¹è¿æ¥å·¥å‚ï¼ˆåªè¯»ï¼‰
     */
    @Bean
    public LettuceConnectionFactory slaveConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName(slaveHost);
        config.setPort(slavePort);
        config.setPassword(password);
        
        GenericObjectPoolConfig<StatefulRedisConnection<String, String>> poolConfig = 
            new GenericObjectPoolConfig<>();
        poolConfig.setMaxTotal(50); // è¯»æ“ä½œè¾ƒå¤šï¼Œå¢åŠ è¿æ¥æ•°
        poolConfig.setMaxIdle(20);
        poolConfig.setMinIdle(10);
        
        LettucePoolingClientConfiguration clientConfig = LettucePoolingClientConfiguration.builder()
            .poolConfig(poolConfig)
            .readFrom(ReadFrom.REPLICA_PREFERRED) // ä¼˜å…ˆä»ä»èŠ‚ç‚¹è¯»å–
            .commandTimeout(Duration.ofSeconds(3))
            .build();
        
        return new LettuceConnectionFactory(config, clientConfig);
    }
    
    /**
     * ä¸»èŠ‚ç‚¹Redisæ¨¡æ¿ï¼ˆå†™æ“ä½œï¼‰
     */
    @Bean
    public RedisTemplate<String, Object> masterRedisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(masterConnectionFactory());
        
        // åºåˆ—åŒ–é…ç½®
        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = 
            new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, 
            ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
        
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.setDefaultSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        
        return template;
    }
    
    /**
     * ä»èŠ‚ç‚¹Redisæ¨¡æ¿ï¼ˆè¯»æ“ä½œï¼‰
     */
    @Bean
    public RedisTemplate<String, Object> slaveRedisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(slaveConnectionFactory());
        
        // ä½¿ç”¨ç›¸åŒçš„åºåˆ—åŒ–é…ç½®
        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = 
            new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, 
            ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
        
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.setDefaultSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        
        return template;
    }
}

/**
 * è¯»å†™åˆ†ç¦»æœåŠ¡å®ç°
 */
@Service
public class RedisReadWriteService {
    
    @Autowired
    @Qualifier("masterRedisTemplate")
    private RedisTemplate<String, Object> masterRedisTemplate;
    
    @Autowired
    @Qualifier("slaveRedisTemplate")
    private RedisTemplate<String, Object> slaveRedisTemplate;
    
    private static final Logger logger = LoggerFactory.getLogger(RedisReadWriteService.class);
    
    /**
     * å†™æ“ä½œ - ä½¿ç”¨ä¸»èŠ‚ç‚¹
     */
    public void writeData(String key, Object value) {
        try {
            masterRedisTemplate.opsForValue().set(key, value, Duration.ofHours(1));
            logger.info("æ•°æ®å†™å…¥ä¸»èŠ‚ç‚¹æˆåŠŸ: key={}", key);
        } catch (Exception e) {
            logger.error("æ•°æ®å†™å…¥ä¸»èŠ‚ç‚¹å¤±è´¥: key={}", key, e);
            throw new RuntimeException("Rediså†™å…¥å¤±è´¥", e);
        }
    }
    
    /**
     * å†™æ“ä½œ - æ‰¹é‡å†™å…¥
     */
    public void writeBatchData(Map<String, Object> dataMap) {
        try {
            masterRedisTemplate.opsForValue().multiSet(dataMap);
            
            // è®¾ç½®è¿‡æœŸæ—¶é—´
            dataMap.keySet().forEach(key -> 
                masterRedisTemplate.expire(key, Duration.ofHours(1))
            );
            
            logger.info("æ‰¹é‡æ•°æ®å†™å…¥ä¸»èŠ‚ç‚¹æˆåŠŸ: count={}", dataMap.size());
        } catch (Exception e) {
            logger.error("æ‰¹é‡æ•°æ®å†™å…¥ä¸»èŠ‚ç‚¹å¤±è´¥", e);
            throw new RuntimeException("Redisæ‰¹é‡å†™å…¥å¤±è´¥", e);
        }
    }
    
    /**
     * è¯»æ“ä½œ - ä½¿ç”¨ä»èŠ‚ç‚¹
     */
    public Object readData(String key) {
        try {
            Object value = slaveRedisTemplate.opsForValue().get(key);
            logger.debug("ä»ä»èŠ‚ç‚¹è¯»å–æ•°æ®: key={}, found={}", key, value != null);
            return value;
        } catch (Exception e) {
            logger.warn("ä»ä»èŠ‚ç‚¹è¯»å–å¤±è´¥ï¼Œå°è¯•ä»ä¸»èŠ‚ç‚¹è¯»å–: key={}", key);
            
            // ä»èŠ‚ç‚¹è¯»å–å¤±è´¥ï¼Œé™çº§åˆ°ä¸»èŠ‚ç‚¹
            try {
                Object value = masterRedisTemplate.opsForValue().get(key);
                logger.info("ä»ä¸»èŠ‚ç‚¹è¯»å–æ•°æ®æˆåŠŸ: key={}", key);
                return value;
            } catch (Exception masterException) {
                logger.error("ä»ä¸»èŠ‚ç‚¹è¯»å–ä¹Ÿå¤±è´¥: key={}", key, masterException);
                throw new RuntimeException("Redisè¯»å–å¤±è´¥", masterException);
            }
        }
    }
    
    /**
     * è¯»æ“ä½œ - æ‰¹é‡è¯»å–
     */
    public List<Object> readBatchData(List<String> keys) {
        try {
            List<Object> values = slaveRedisTemplate.opsForValue().multiGet(keys);
            logger.debug("ä»ä»èŠ‚ç‚¹æ‰¹é‡è¯»å–æ•°æ®: count={}", keys.size());
            return values;
        } catch (Exception e) {
            logger.warn("ä»ä»èŠ‚ç‚¹æ‰¹é‡è¯»å–å¤±è´¥ï¼Œå°è¯•ä»ä¸»èŠ‚ç‚¹è¯»å–");
            
            try {
                List<Object> values = masterRedisTemplate.opsForValue().multiGet(keys);
                logger.info("ä»ä¸»èŠ‚ç‚¹æ‰¹é‡è¯»å–æ•°æ®æˆåŠŸ: count={}", keys.size());
                return values;
            } catch (Exception masterException) {
                logger.error("ä»ä¸»èŠ‚ç‚¹æ‰¹é‡è¯»å–ä¹Ÿå¤±è´¥", masterException);
                throw new RuntimeException("Redisæ‰¹é‡è¯»å–å¤±è´¥", masterException);
            }
        }
    }
    
    /**
     * åˆ é™¤æ“ä½œ - ä½¿ç”¨ä¸»èŠ‚ç‚¹
     */
    public void deleteData(String key) {
        try {
            Boolean deleted = masterRedisTemplate.delete(key);
            logger.info("ä»ä¸»èŠ‚ç‚¹åˆ é™¤æ•°æ®: key={}, deleted={}", key, deleted);
        } catch (Exception e) {
            logger.error("ä»ä¸»èŠ‚ç‚¹åˆ é™¤æ•°æ®å¤±è´¥: key={}", key, e);
            throw new RuntimeException("Redisåˆ é™¤å¤±è´¥", e);
        }
    }
    
    /**
     * å¥åº·æ£€æŸ¥
     */
    public Map<String, String> healthCheck() {
        Map<String, String> status = new HashMap<>();
        
        // æ£€æŸ¥ä¸»èŠ‚ç‚¹
        try {
            String masterPing = masterRedisTemplate.getConnectionFactory()
                .getConnection().ping();
            status.put("master", "PONG".equals(masterPing) ? "UP" : "DOWN");
        } catch (Exception e) {
            status.put("master", "DOWN");
            logger.error("ä¸»èŠ‚ç‚¹å¥åº·æ£€æŸ¥å¤±è´¥", e);
        }
        
        // æ£€æŸ¥ä»èŠ‚ç‚¹
        try {
            String slavePing = slaveRedisTemplate.getConnectionFactory()
                .getConnection().ping();
            status.put("slave", "PONG".equals(slavePing) ? "UP" : "DOWN");
        } catch (Exception e) {
            status.put("slave", "DOWN");
            logger.error("ä»èŠ‚ç‚¹å¥åº·æ£€æŸ¥å¤±è´¥", e);
        }
        
        return status;
    }
}
```

### Sentinelå“¨å…µæ¨¡å¼å®æˆ˜

**ç”Ÿäº§çº§Sentinelé›†ç¾¤é…ç½®**ï¼š

```yaml
# application.yml - Sentinelé…ç½®
spring:
  redis:
    sentinel:
      master: mymaster
      nodes:
        - 192.168.1.101:26379
        - 192.168.1.102:26379
        - 192.168.1.103:26379
      password: ${REDIS_PASSWORD}
    password: ${REDIS_PASSWORD}
    timeout: 5000ms
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 5
        max-wait: 5000ms
      shutdown-timeout: 10000ms
```

```java
/**
 * Redis Sentinelé…ç½®
 */
@Configuration
public class RedisSentinelConfig {
    
    @Value("${spring.redis.sentinel.master}")
    private String masterName;
    
    @Value("${spring.redis.password}")
    private String password;
    
    @Value("#{'${spring.redis.sentinel.nodes}'.split(',')}")
    private List<String> sentinelNodes;
    
    /**
     * Sentinelè¿æ¥å·¥å‚
     */
    @Bean
    public LettuceConnectionFactory sentinelConnectionFactory() {
        // è§£æSentinelèŠ‚ç‚¹
        Set<RedisNode> sentinelSet = sentinelNodes.stream()
            .map(node -> {
                String[] parts = node.split(":");
                return new RedisNode(parts[0], Integer.parseInt(parts[1]));
            })
            .collect(Collectors.toSet());
        
        RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration(masterName, sentinelSet);
        sentinelConfig.setPassword(password);
        sentinelConfig.setSentinelPassword(password);
        
        // è¿æ¥æ± é…ç½®
        GenericObjectPoolConfig<StatefulRedisConnection<String, String>> poolConfig = 
            new GenericObjectPoolConfig<>();
        poolConfig.setMaxTotal(20);
        poolConfig.setMaxIdle(10);
        poolConfig.setMinIdle(5);
        poolConfig.setTestOnBorrow(true);
        poolConfig.setTestOnReturn(true);
        poolConfig.setTestWhileIdle(true);
        
        LettucePoolingClientConfiguration clientConfig = LettucePoolingClientConfiguration.builder()
            .poolConfig(poolConfig)
            .commandTimeout(Duration.ofSeconds(5))
            .shutdownTimeout(Duration.ofSeconds(10))
            .readFrom(ReadFrom.REPLICA_PREFERRED) // è¯»å†™åˆ†ç¦»
            .build();
        
        return new LettuceConnectionFactory(sentinelConfig, clientConfig);
    }
    
    /**
     * Redisæ¨¡æ¿
     */
    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(sentinelConnectionFactory());
        
        // åºåˆ—åŒ–é…ç½®
        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = 
            new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, 
            ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
        
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.setDefaultSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        
        return template;
    }
    
    /**
     * Sentinelç›‘å¬å™¨ - ç›‘æ§ä¸»èŠ‚ç‚¹åˆ‡æ¢
     */
    @Bean
    public RedisSentinelListener sentinelListener() {
        return new RedisSentinelListener();
    }
}

/**
 * Sentineläº‹ä»¶ç›‘å¬å™¨
 */
@Component
public class RedisSentinelListener implements ApplicationListener<RedisSentinelFailoverEvent> {
    
    private static final Logger logger = LoggerFactory.getLogger(RedisSentinelListener.class);
    
    @Override
    public void onApplicationEvent(RedisSentinelFailoverEvent event) {
        logger.warn("Redis Sentinelæ•…éšœè½¬ç§»äº‹ä»¶: oldMaster={}, newMaster={}", 
            event.getOldMaster(), event.getNewMaster());
        
        // å‘é€å‘Šè­¦é€šçŸ¥
        sendFailoverAlert(event);
        
        // è®°å½•æ•…éšœè½¬ç§»æ—¥å¿—
        recordFailoverLog(event);
        
        // è§¦å‘åº”ç”¨å±‚çš„æ•…éšœæ¢å¤é€»è¾‘
        handleFailoverRecovery(event);
    }
    
    private void sendFailoverAlert(RedisSentinelFailoverEvent event) {
        // å®ç°å‘Šè­¦é€šçŸ¥é€»è¾‘
        // å¯ä»¥å‘é€é‚®ä»¶ã€çŸ­ä¿¡ã€é’‰é’‰é€šçŸ¥ç­‰
        logger.info("å‘é€Redisæ•…éšœè½¬ç§»å‘Šè­¦é€šçŸ¥");
    }
    
    private void recordFailoverLog(RedisSentinelFailoverEvent event) {
        // è®°å½•è¯¦ç»†çš„æ•…éšœè½¬ç§»æ—¥å¿—
        logger.info("è®°å½•Redisæ•…éšœè½¬ç§»æ—¥å¿—åˆ°æ•°æ®åº“");
    }
    
    private void handleFailoverRecovery(RedisSentinelFailoverEvent event) {
        // æ‰§è¡Œæ•…éšœæ¢å¤åçš„ä¸šåŠ¡é€»è¾‘
        // æ¯”å¦‚æ¸…ç†ç¼“å­˜ã€é‡æ–°åŠ è½½æ•°æ®ç­‰
        logger.info("æ‰§è¡ŒRedisæ•…éšœè½¬ç§»åçš„æ¢å¤é€»è¾‘");
    }
}

/**
 * é«˜å¯ç”¨RedisæœåŠ¡
 */
@Service
public class HighAvailabilityRedisService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final Logger logger = LoggerFactory.getLogger(HighAvailabilityRedisService.class);
    
    /**
     * å®¹é”™çš„å†™æ“ä½œ
     */
    @Retryable(value = {Exception.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
    public void setWithRetry(String key, Object value, Duration timeout) {
        try {
            redisTemplate.opsForValue().set(key, value, timeout);
            logger.debug("Rediså†™å…¥æˆåŠŸ: key={}", key);
        } catch (Exception e) {
            logger.error("Rediså†™å…¥å¤±è´¥ï¼Œå°†é‡è¯•: key={}", key, e);
            throw e;
        }
    }
    
    /**
     * å®¹é”™çš„è¯»æ“ä½œ
     */
    @Retryable(value = {Exception.class}, maxAttempts = 3, backoff = @Backoff(delay = 500))
    public Object getWithRetry(String key) {
        try {
            Object value = redisTemplate.opsForValue().get(key);
            logger.debug("Redisè¯»å–æˆåŠŸ: key={}, found={}", key, value != null);
            return value;
        } catch (Exception e) {
            logger.error("Redisè¯»å–å¤±è´¥ï¼Œå°†é‡è¯•: key={}", key, e);
            throw e;
        }
    }
    
    /**
     * æ‰¹é‡æ“ä½œçš„å®¹é”™å¤„ç†
     */
    public Map<String, Object> batchGetWithFallback(List<String> keys) {
        Map<String, Object> result = new HashMap<>();
        
        try {
            List<Object> values = redisTemplate.opsForValue().multiGet(keys);
            for (int i = 0; i < keys.size(); i++) {
                if (i < values.size() && values.get(i) != null) {
                    result.put(keys.get(i), values.get(i));
                }
            }
        } catch (Exception e) {
            logger.error("Redisæ‰¹é‡è¯»å–å¤±è´¥ï¼Œå°è¯•å•ä¸ªè¯»å–", e);
            
            // é™çº§ç­–ç•¥ï¼šé€ä¸ªè¯»å–
            for (String key : keys) {
                try {
                    Object value = redisTemplate.opsForValue().get(key);
                    if (value != null) {
                        result.put(key, value);
                    }
                } catch (Exception singleException) {
                    logger.warn("å•ä¸ªkeyè¯»å–ä¹Ÿå¤±è´¥: key={}", key);
                }
            }
        }
        
        return result;
    }
}
```

### Redis Clusteré›†ç¾¤å®æˆ˜

**ç”Ÿäº§çº§Clusteré›†ç¾¤é…ç½®**ï¼š

```yaml
# application.yml - Clusteré…ç½®
spring:
  redis:
    cluster:
      nodes:
        - 192.168.1.101:7000
        - 192.168.1.101:7001
        - 192.168.1.102:7000
        - 192.168.1.102:7001
        - 192.168.1.103:7000
        - 192.168.1.103:7001
      max-redirects: 3
    password: ${REDIS_PASSWORD}
    timeout: 5000ms
    lettuce:
      pool:
        max-active: 50
        max-idle: 20
        min-idle: 10
        max-wait: 5000ms
      cluster:
        refresh:
          adaptive: true
          period: 30s
```

```java
/**
 * Redis Clusteré…ç½®
 */
@Configuration
public class RedisClusterConfig {
    
    @Value("#{'${spring.redis.cluster.nodes}'.split(',')}")
    private List<String> clusterNodes;
    
    @Value("${spring.redis.cluster.max-redirects}")
    private int maxRedirects;
    
    @Value("${spring.redis.password}")
    private String password;
    
    /**
     * Clusterè¿æ¥å·¥å‚
     */
    @Bean
    public LettuceConnectionFactory clusterConnectionFactory() {
        // è§£æé›†ç¾¤èŠ‚ç‚¹
        Set<RedisNode> nodeSet = clusterNodes.stream()
            .map(node -> {
                String[] parts = node.split(":");
                return new RedisNode(parts[0], Integer.parseInt(parts[1]));
            })
            .collect(Collectors.toSet());
        
        RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration();
        clusterConfig.setClusterNodes(nodeSet);
        clusterConfig.setMaxRedirects(maxRedirects);
        clusterConfig.setPassword(password);
        
        // è¿æ¥æ± é…ç½®
        GenericObjectPoolConfig<StatefulRedisConnection<String, String>> poolConfig = 
            new GenericObjectPoolConfig<>();
        poolConfig.setMaxTotal(50);
        poolConfig.setMaxIdle(20);
        poolConfig.setMinIdle(10);
        poolConfig.setTestOnBorrow(true);
        poolConfig.setTestOnReturn(true);
        poolConfig.setTestWhileIdle(true);
        
        // å®¢æˆ·ç«¯é…ç½®
        LettucePoolingClientConfiguration clientConfig = LettucePoolingClientConfiguration.builder()
            .poolConfig(poolConfig)
            .commandTimeout(Duration.ofSeconds(5))
            .shutdownTimeout(Duration.ofSeconds(10))
            .readFrom(ReadFrom.REPLICA_PREFERRED) // è¯»å†™åˆ†ç¦»
            .build();
        
        return new LettuceConnectionFactory(clusterConfig, clientConfig);
    }
    
    /**
     * Cluster Redisæ¨¡æ¿
     */
    @Bean
    public RedisTemplate<String, Object> clusterRedisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(clusterConnectionFactory());
        
        // åºåˆ—åŒ–é…ç½®
        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = 
            new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, 
            ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
        
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.setDefaultSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        
        return template;
    }
    
    /**
     * é›†ç¾¤ç®¡ç†å·¥å…·
     */
    @Bean
    public RedisClusterManager clusterManager() {
        return new RedisClusterManager(clusterConnectionFactory());
    }
}

/**
 * Redis Clusterç®¡ç†å™¨
 */
@Component
public class RedisClusterManager {
    
    private final LettuceConnectionFactory connectionFactory;
    private static final Logger logger = LoggerFactory.getLogger(RedisClusterManager.class);
    
    public RedisClusterManager(LettuceConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }
    
    /**
     * è·å–é›†ç¾¤ä¿¡æ¯
     */
    public ClusterInfo getClusterInfo() {
        try (StatefulRedisClusterConnection<String, String> connection = 
             (StatefulRedisClusterConnection<String, String>) connectionFactory.getConnection()) {
            
            RedisAdvancedClusterCommands<String, String> commands = connection.sync();
            
            // è·å–é›†ç¾¤èŠ‚ç‚¹ä¿¡æ¯
            String clusterNodes = commands.clusterNodes();
            Map<String, String> clusterInfo = commands.clusterInfo();
            
            return ClusterInfo.builder()
                .nodes(parseClusterNodes(clusterNodes))
                .info(clusterInfo)
                .state(clusterInfo.get("cluster_state"))
                .slotsAssigned(Integer.parseInt(clusterInfo.get("cluster_slots_assigned")))
                .slotsOk(Integer.parseInt(clusterInfo.get("cluster_slots_ok")))
                .slotsFail(Integer.parseInt(clusterInfo.get("cluster_slots_fail")))
                .knownNodes(Integer.parseInt(clusterInfo.get("cluster_known_nodes")))
                .build();
                
        } catch (Exception e) {
            logger.error("è·å–é›†ç¾¤ä¿¡æ¯å¤±è´¥", e);
            throw new RuntimeException("è·å–é›†ç¾¤ä¿¡æ¯å¤±è´¥", e);
        }
    }
    
    /**
     * è·å–Keyçš„æ§½ä½ä¿¡æ¯
     */
    public SlotInfo getKeySlot(String key) {
        int slot = SlotHash.getSlot(key);
        
        try (StatefulRedisClusterConnection<String, String> connection = 
             (StatefulRedisClusterConnection<String, String>) connectionFactory.getConnection()) {
            
            RedisAdvancedClusterCommands<String, String> commands = connection.sync();
            List<Object> slotInfo = commands.clusterSlots();
            
            // æŸ¥æ‰¾æ§½ä½å¯¹åº”çš„èŠ‚ç‚¹
            for (Object slotRange : slotInfo) {
                List<Object> range = (List<Object>) slotRange;
                int startSlot = ((Number) range.get(0)).intValue();
                int endSlot = ((Number) range.get(1)).intValue();
                
                if (slot >= startSlot && slot <= endSlot) {
                    List<Object> masterInfo = (List<Object>) range.get(2);
                    String masterHost = new String((byte[]) masterInfo.get(0));
                    int masterPort = ((Number) masterInfo.get(1)).intValue();
                    
                    return SlotInfo.builder()
                        .key(key)
                        .slot(slot)
                        .masterHost(masterHost)
                        .masterPort(masterPort)
                        .slotRange(startSlot + "-" + endSlot)
                        .build();
                }
            }
            
        } catch (Exception e) {
            logger.error("è·å–Keyæ§½ä½ä¿¡æ¯å¤±è´¥: key={}", key, e);
        }
        
        return SlotInfo.builder()
            .key(key)
            .slot(slot)
            .build();
    }
    
    /**
     * å¥åº·æ£€æŸ¥
     */
    public Map<String, String> healthCheck() {
        Map<String, String> healthStatus = new HashMap<>();
        
        try {
            ClusterInfo clusterInfo = getClusterInfo();
            
            healthStatus.put("cluster_state", clusterInfo.getState());
            healthStatus.put("cluster_slots_assigned", String.valueOf(clusterInfo.getSlotsAssigned()));
            healthStatus.put("cluster_slots_ok", String.valueOf(clusterInfo.getSlotsOk()));
            healthStatus.put("cluster_slots_fail", String.valueOf(clusterInfo.getSlotsFail()));
            healthStatus.put("cluster_known_nodes", String.valueOf(clusterInfo.getKnownNodes()));
            
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ§½ä½éƒ½æ­£å¸¸
            if (clusterInfo.getSlotsAssigned() == 16384 && clusterInfo.getSlotsFail() == 0) {
                healthStatus.put("overall_status", "HEALTHY");
            } else {
                healthStatus.put("overall_status", "DEGRADED");
            }
            
        } catch (Exception e) {
            logger.error("é›†ç¾¤å¥åº·æ£€æŸ¥å¤±è´¥", e);
            healthStatus.put("overall_status", "UNHEALTHY");
            healthStatus.put("error", e.getMessage());
        }
        
        return healthStatus;
    }
    
    private List<ClusterNode> parseClusterNodes(String clusterNodes) {
        // è§£æé›†ç¾¤èŠ‚ç‚¹ä¿¡æ¯çš„å®ç°
        return Arrays.stream(clusterNodes.split("\n"))
            .filter(line -> !line.trim().isEmpty())
            .map(this::parseNodeLine)
            .collect(Collectors.toList());
    }
    
    private ClusterNode parseNodeLine(String nodeLine) {
        String[] parts = nodeLine.split(" ");
        return ClusterNode.builder()
            .nodeId(parts[0])
            .endpoint(parts[1])
            .flags(parts[2])
            .master(parts[3])
            .pingTime(Long.parseLong(parts[4]))
            .pongTime(Long.parseLong(parts[5]))
            .epoch(Long.parseLong(parts[6]))
            .state(parts[7])
            .slots(parts.length > 8 ? String.join(" ", Arrays.copyOfRange(parts, 8, parts.length)) : "")
            .build();
    }
}

// æ•°æ®æ¨¡å‹ç±»
@Data
@Builder
public class ClusterInfo {
    private List<ClusterNode> nodes;
    private Map<String, String> info;
    private String state;
    private int slotsAssigned;
    private int slotsOk;
    private int slotsFail;
    private int knownNodes;
}

@Data
@Builder
public class ClusterNode {
    private String nodeId;
    private String endpoint;
    private String flags;
    private String master;
    private long pingTime;
    private long pongTime;
    private long epoch;
    private String state;
    private String slots;
}

@Data
@Builder
public class SlotInfo {
    private String key;
    private int slot;
    private String masterHost;
    private int masterPort;
    private String slotRange;
}
``` 

## ğŸ¯ é¢è¯•é«˜é¢‘é—®é¢˜ç²¾è®²

### é—®é¢˜1ï¼šRedisä¸»ä»å¤åˆ¶çš„å·¥ä½œåŸç†æ˜¯ä»€ä¹ˆï¼Ÿæ•°æ®ä¸€è‡´æ€§å¦‚ä½•ä¿è¯ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š

Redisä¸»ä»å¤åˆ¶é‡‡ç”¨**å¼‚æ­¥å¤åˆ¶**æœºåˆ¶ï¼ŒåŒ…å«ä¸‰ç§åŒæ­¥æ–¹å¼ï¼š

**1. å…¨é‡åŒæ­¥ï¼ˆFull Resynchronizationï¼‰**
- ä»èŠ‚ç‚¹é¦–æ¬¡è¿æ¥ä¸»èŠ‚ç‚¹æ—¶è§¦å‘
- ä¸»èŠ‚ç‚¹æ‰§è¡ŒBGSAVEç”ŸæˆRDBå¿«ç…§
- å°†RDBæ–‡ä»¶å‘é€ç»™ä»èŠ‚ç‚¹
- ä»èŠ‚ç‚¹æ¸…ç©ºæ•°æ®åº“å¹¶åŠ è½½RDB
- ä¸»èŠ‚ç‚¹å°†æœŸé—´çš„å†™å‘½ä»¤å‘é€ç»™ä»èŠ‚ç‚¹

**2. å¢é‡åŒæ­¥ï¼ˆIncremental Syncï¼‰**
- æ­£å¸¸è¿è¡Œæ—¶çš„å®æ—¶åŒæ­¥
- ä¸»èŠ‚ç‚¹å°†å†™å‘½ä»¤å®æ—¶å‘é€ç»™ä»èŠ‚ç‚¹
- åŸºäºå¤åˆ¶ç§¯å‹ç¼“å†²åŒºï¼ˆreplication backlogï¼‰

**3. éƒ¨åˆ†é‡åŒæ­¥ï¼ˆPartial Resynchronizationï¼‰**
- ä»èŠ‚ç‚¹çŸ­æš‚æ–­å¼€åé‡è¿æ—¶è§¦å‘
- åŸºäºå¤åˆ¶åç§»é‡ï¼ˆreplication offsetï¼‰åˆ¤æ–­
- åªåŒæ­¥ç¼ºå¤±çš„éƒ¨åˆ†æ•°æ®

**æ•°æ®ä¸€è‡´æ€§ä¿è¯æœºåˆ¶**ï¼š
```java
// å¤åˆ¶åç§»é‡æœºåˆ¶
public class ReplicationOffset {
    private long masterOffset;  // ä¸»èŠ‚ç‚¹å†™å…¥çš„æ•°æ®é‡
    private long slaveOffset;   // ä»èŠ‚ç‚¹å¤åˆ¶çš„æ•°æ®é‡
    
    // åˆ¤æ–­æ•°æ®æ˜¯å¦ä¸€è‡´
    public boolean isConsistent() {
        return Math.abs(masterOffset - slaveOffset) <= ACCEPTABLE_LAG;
    }
}

// å¤åˆ¶ç§¯å‹ç¼“å†²åŒº
public class ReplicationBacklog {
    private byte[] buffer;      // ç¯å½¢ç¼“å†²åŒº
    private long bufferSize;    // ç¼“å†²åŒºå¤§å°ï¼ˆé»˜è®¤1MBï¼‰
    private long masterOffset; // ä¸»èŠ‚ç‚¹åç§»é‡
    
    // åˆ¤æ–­æ˜¯å¦å¯ä»¥éƒ¨åˆ†é‡åŒæ­¥
    public boolean canPartialSync(long slaveOffset) {
        return masterOffset - slaveOffset <= bufferSize;
    }
}
```

**é¢è¯•åŠ åˆ†ç‚¹**ï¼š
- æåˆ°`repl-diskless-sync`æ— ç›˜å¤åˆ¶ä¼˜åŒ–
- äº†è§£`min-slaves-to-write`å‚æ•°æ§åˆ¶å†™å…¥å®‰å…¨æ€§
- çŸ¥é“å¤åˆ¶è¶…æ—¶å’Œå¿ƒè·³æ£€æµ‹æœºåˆ¶

### é—®é¢˜2ï¼šRedis Sentinelçš„è„‘è£‚é—®é¢˜å¦‚ä½•è§£å†³ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š

**è„‘è£‚ç°è±¡**ï¼šç½‘ç»œåˆ†åŒºå¯¼è‡´å‡ºç°å¤šä¸ªä¸»èŠ‚ç‚¹ï¼Œæ•°æ®ä¸ä¸€è‡´ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š

**1. é…ç½®æœ€å°ä»èŠ‚ç‚¹æ•°**
```bash
# redis.confé…ç½®
min-replicas-to-write 1          # è‡³å°‘1ä¸ªä»èŠ‚ç‚¹åœ¨çº¿æ‰å…è®¸å†™å…¥
min-replicas-max-lag 10          # ä»èŠ‚ç‚¹æœ€å¤§å»¶è¿Ÿ10ç§’
```

**2. Sentinel Quorumæœºåˆ¶**
```bash
# sentinel.confé…ç½®
sentinel monitor mymaster 192.168.1.100 6379 2  # éœ€è¦2ä¸ªSentinelåŒæ„æ‰èƒ½æ•…éšœè½¬ç§»
```

**3. å®¢æˆ·ç«¯è¿æ¥éªŒè¯**
```java
@Service
public class AntiBrainSplitService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * é˜²è„‘è£‚çš„å†™æ“ä½œ
     */
    public void safeWrite(String key, Object value) {
        try {
            // 1. æ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦ä¸ºä¸»èŠ‚ç‚¹
            String role = redisTemplate.getConnectionFactory()
                .getConnection().info("replication").getProperty("role");
            
            if (!"master".equals(role)) {
                throw new RuntimeException("å½“å‰èŠ‚ç‚¹ä¸æ˜¯ä¸»èŠ‚ç‚¹ï¼Œæ‹’ç»å†™å…¥");
            }
            
            // 2. æ£€æŸ¥ä»èŠ‚ç‚¹æ•°é‡
            String connectedSlaves = redisTemplate.getConnectionFactory()
                .getConnection().info("replication").getProperty("connected_slaves");
            
            int slaveCount = Integer.parseInt(connectedSlaves);
            if (slaveCount < 1) {
                throw new RuntimeException("ä»èŠ‚ç‚¹æ•°é‡ä¸è¶³ï¼Œæ‹’ç»å†™å…¥");
            }
            
            // 3. æ‰§è¡Œå†™æ“ä½œ
            redisTemplate.opsForValue().set(key, value);
            
        } catch (Exception e) {
            logger.error("é˜²è„‘è£‚å†™æ“ä½œå¤±è´¥", e);
            throw e;
        }
    }
    
    /**
     * æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§
     */
    public boolean checkConsistency(String key) {
        try {
            // ä»ä¸»èŠ‚ç‚¹è¯»å–
            Object masterValue = redisTemplate.opsForValue().get(key);
            
            // ä»ä»èŠ‚ç‚¹è¯»å–ï¼ˆéœ€è¦é…ç½®ä»èŠ‚ç‚¹è¿æ¥ï¼‰
            Object slaveValue = slaveRedisTemplate.opsForValue().get(key);
            
            return Objects.equals(masterValue, slaveValue);
            
        } catch (Exception e) {
            logger.error("ä¸€è‡´æ€§æ£€æŸ¥å¤±è´¥", e);
            return false;
        }
    }
}
```

**é¢è¯•åŠ åˆ†ç‚¹**ï¼š
- äº†è§£ç½‘ç»œåˆ†åŒºæ£€æµ‹æœºåˆ¶
- çŸ¥é“å®¢æˆ·ç«¯é‡è¿ç­–ç•¥
- æåˆ°ç›‘æ§å’Œå‘Šè­¦çš„é‡è¦æ€§

### é—®é¢˜3ï¼šRedis Clusterå¦‚ä½•å¤„ç†æ§½ä½è¿ç§»ï¼Ÿæ•°æ®è¿ç§»è¿‡ç¨‹ä¸­å¦‚ä½•ä¿è¯æœåŠ¡å¯ç”¨ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š

**æ§½ä½è¿ç§»æµç¨‹**ï¼š

**1. è¿ç§»å‡†å¤‡é˜¶æ®µ**
```bash
# 1. è®¾ç½®ç›®æ ‡èŠ‚ç‚¹ä¸ºå¯¼å…¥çŠ¶æ€
CLUSTER SETSLOT 1000 IMPORTING target-node-id

# 2. è®¾ç½®æºèŠ‚ç‚¹ä¸ºå¯¼å‡ºçŠ¶æ€  
CLUSTER SETSLOT 1000 MIGRATING source-node-id
```

**2. æ•°æ®è¿ç§»é˜¶æ®µ**
```bash
# 3. é€ä¸ªè¿ç§»æ§½ä½ä¸­çš„Key
MIGRATE target-host target-port key destination-db timeout

# 4. æ£€æŸ¥æ§½ä½æ˜¯å¦ä¸ºç©º
CLUSTER COUNTKEYSINSLOT 1000
```

**3. è¿ç§»å®Œæˆé˜¶æ®µ**
```bash
# 5. æ›´æ–°æ§½ä½å½’å±
CLUSTER SETSLOT 1000 NODE target-node-id

# 6. å¹¿æ’­æ§½ä½å˜æ›´
CLUSTER NODES
```

**æœåŠ¡å¯ç”¨æ€§ä¿è¯æœºåˆ¶**ï¼š

```java
/**
 * æ§½ä½è¿ç§»æœŸé—´çš„å®¢æˆ·ç«¯å¤„ç†
 */
@Service
public class ClusterMigrationHandler {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * è¿ç§»æœŸé—´çš„å®‰å…¨è¯»å†™
     */
    public Object safeGet(String key) {
        int maxRetries = 3;
        int retryCount = 0;
        
        while (retryCount < maxRetries) {
            try {
                return redisTemplate.opsForValue().get(key);
                
            } catch (RedisRedirectionException e) {
                // å¤„ç†MOVEDé‡å®šå‘
                if (e.getMessage().contains("MOVED")) {
                    logger.info("æ§½ä½å·²è¿ç§»ï¼Œé‡å®šå‘åˆ°æ–°èŠ‚ç‚¹: {}", e.getMessage());
                    // å®¢æˆ·ç«¯ä¼šè‡ªåŠ¨é‡å®šå‘ï¼Œé‡è¯•å³å¯
                    retryCount++;
                    continue;
                }
                
                // å¤„ç†ASKé‡å®šå‘
                if (e.getMessage().contains("ASK")) {
                    logger.info("æ§½ä½æ­£åœ¨è¿ç§»ï¼Œä¸´æ—¶é‡å®šå‘: {}", e.getMessage());
                    // å‘é€ASKINGå‘½ä»¤åé‡è¯•
                    handleAskRedirection(e);
                    retryCount++;
                    continue;
                }
                
                throw e;
                
            } catch (Exception e) {
                logger.error("è¯»å–å¤±è´¥ï¼Œé‡è¯•: key={}, attempt={}", key, retryCount + 1);
                retryCount++;
                
                if (retryCount >= maxRetries) {
                    throw new RuntimeException("è¯»å–å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°", e);
                }
                
                // ç­‰å¾…åé‡è¯•
                try {
                    Thread.sleep(100 * retryCount);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("é‡è¯•è¢«ä¸­æ–­", ie);
                }
            }
        }
        
        throw new RuntimeException("è¯»å–å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°");
    }
    
    /**
     * å¤„ç†ASKé‡å®šå‘
     */
    private void handleAskRedirection(RedisRedirectionException e) {
        // è§£æASKå“åº”ï¼Œè·å–ç›®æ ‡èŠ‚ç‚¹ä¿¡æ¯
        String askMessage = e.getMessage();
        // æ ¼å¼: ASK 1000 192.168.1.101:7001
        String[] parts = askMessage.split(" ");
        String targetNode = parts[2];
        
        // å‘ç›®æ ‡èŠ‚ç‚¹å‘é€ASKINGå‘½ä»¤
        try {
            // è¿™é‡Œéœ€è¦å»ºç«‹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è¿æ¥å¹¶å‘é€ASKING
            logger.info("å‘é€ASKINGå‘½ä»¤åˆ°ç›®æ ‡èŠ‚ç‚¹: {}", targetNode);
        } catch (Exception ex) {
            logger.error("å‘é€ASKINGå‘½ä»¤å¤±è´¥", ex);
        }
    }
    
    /**
     * è¿ç§»æœŸé—´çš„å†™æ“ä½œ
     */
    public void safeSet(String key, Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            
        } catch (RedisRedirectionException e) {
            if (e.getMessage().contains("MOVED")) {
                // æ§½ä½å·²å®Œå…¨è¿ç§»ï¼Œé‡è¯•å†™å…¥
                logger.info("æ§½ä½å·²è¿ç§»ï¼Œé‡æ–°å†™å…¥: {}", e.getMessage());
                redisTemplate.opsForValue().set(key, value);
            } else {
                throw new RuntimeException("å†™æ“ä½œå¤±è´¥ï¼Œæ§½ä½è¿ç§»ä¸­", e);
            }
        }
    }
}

/**
 * è¿ç§»çŠ¶æ€ç›‘æ§
 */
@Component
public class MigrationMonitor {
    
    /**
     * ç›‘æ§è¿ç§»è¿›åº¦
     */
    @Scheduled(fixedDelay = 5000)
    public void monitorMigration() {
        try {
            // æ£€æŸ¥é›†ç¾¤çŠ¶æ€
            Map<String, String> clusterInfo = getClusterInfo();
            
            String state = clusterInfo.get("cluster_state");
            if ("fail".equals(state)) {
                logger.error("é›†ç¾¤çŠ¶æ€å¼‚å¸¸ï¼Œå¯èƒ½å­˜åœ¨è¿ç§»é—®é¢˜");
                // å‘é€å‘Šè­¦
                sendAlert("é›†ç¾¤çŠ¶æ€å¼‚å¸¸");
            }
            
            // æ£€æŸ¥è¿ç§»ä¸­çš„æ§½ä½
            int migratingSlots = Integer.parseInt(
                clusterInfo.getOrDefault("cluster_slots_migrating", "0"));
            int importingSlots = Integer.parseInt(
                clusterInfo.getOrDefault("cluster_slots_importing", "0"));
            
            if (migratingSlots > 0 || importingSlots > 0) {
                logger.info("æ£€æµ‹åˆ°æ§½ä½è¿ç§»: migrating={}, importing={}", 
                    migratingSlots, importingSlots);
            }
            
        } catch (Exception e) {
            logger.error("è¿ç§»ç›‘æ§å¤±è´¥", e);
        }
    }
    
    private Map<String, String> getClusterInfo() {
        // è·å–é›†ç¾¤ä¿¡æ¯çš„å®ç°
        return new HashMap<>();
    }
    
    private void sendAlert(String message) {
        // å‘é€å‘Šè­¦çš„å®ç°
        logger.warn("å‘é€å‘Šè­¦: {}", message);
    }
}
```

**é¢è¯•åŠ åˆ†ç‚¹**ï¼š
- äº†è§£MOVEDå’ŒASKé‡å®šå‘çš„åŒºåˆ«
- çŸ¥é“æ§½ä½è¿ç§»çš„åŸå­æ€§ä¿è¯
- æåˆ°å®¢æˆ·ç«¯ç¼“å­˜åˆ·æ–°æœºåˆ¶

### é—®é¢˜4ï¼šRedisé›†ç¾¤æ‰©å®¹å’Œç¼©å®¹çš„æœ€ä½³å®è·µæ˜¯ä»€ä¹ˆï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š

**æ‰©å®¹æœ€ä½³å®è·µ**ï¼š

**1. æ·»åŠ èŠ‚ç‚¹**
```bash
# 1. å¯åŠ¨æ–°èŠ‚ç‚¹
redis-server /path/to/redis-7003.conf

# 2. å°†æ–°èŠ‚ç‚¹åŠ å…¥é›†ç¾¤
redis-cli --cluster add-node 192.168.1.101:7003 192.168.1.101:7000

# 3. åˆ†é…æ§½ä½ç»™æ–°èŠ‚ç‚¹
redis-cli --cluster reshard 192.168.1.101:7000
```

**2. è‡ªåŠ¨åŒ–æ‰©å®¹è„šæœ¬**
```java
/**
 * é›†ç¾¤è‡ªåŠ¨æ‰©å®¹ç®¡ç†
 */
@Service
public class ClusterScalingService {
    
    /**
     * è‡ªåŠ¨æ‰©å®¹
     */
    public void autoScale() {
        // 1. æ£€æŸ¥é›†ç¾¤è´Ÿè½½
        ClusterMetrics metrics = getClusterMetrics();
        
        if (shouldScaleOut(metrics)) {
            logger.info("é›†ç¾¤è´Ÿè½½è¿‡é«˜ï¼Œå¼€å§‹è‡ªåŠ¨æ‰©å®¹");
            scaleOut();
        } else if (shouldScaleIn(metrics)) {
            logger.info("é›†ç¾¤è´Ÿè½½è¾ƒä½ï¼Œå¼€å§‹è‡ªåŠ¨ç¼©å®¹");
            scaleIn();
        }
    }
    
    /**
     * æ‰©å®¹åˆ¤æ–­æ¡ä»¶
     */
    private boolean shouldScaleOut(ClusterMetrics metrics) {
        return metrics.getCpuUsage() > 80 ||           // CPUä½¿ç”¨ç‡è¶…è¿‡80%
               metrics.getMemoryUsage() > 85 ||        // å†…å­˜ä½¿ç”¨ç‡è¶…è¿‡85%
               metrics.getConnectionCount() > 8000 ||  // è¿æ¥æ•°è¶…è¿‡8000
               metrics.getQps() > 50000;               // QPSè¶…è¿‡5ä¸‡
    }
    
    /**
     * ç¼©å®¹åˆ¤æ–­æ¡ä»¶
     */
    private boolean shouldScaleIn(ClusterMetrics metrics) {
        return metrics.getCpuUsage() < 30 &&           // CPUä½¿ç”¨ç‡ä½äº30%
               metrics.getMemoryUsage() < 40 &&        // å†…å­˜ä½¿ç”¨ç‡ä½äº40%
               metrics.getConnectionCount() < 2000 &&  // è¿æ¥æ•°ä½äº2000
               metrics.getQps() < 10000 &&             // QPSä½äº1ä¸‡
               getCurrentNodeCount() > 3;              // èŠ‚ç‚¹æ•°å¤§äºæœ€å°å€¼3
    }
    
    /**
     * æ‰§è¡Œæ‰©å®¹
     */
    private void scaleOut() {
        try {
            // 1. åˆ›å»ºæ–°èŠ‚ç‚¹å®ä¾‹
            String newNodeId = createNewNode();
            
            // 2. å°†æ–°èŠ‚ç‚¹åŠ å…¥é›†ç¾¤
            addNodeToCluster(newNodeId);
            
            // 3. é‡æ–°åˆ†é…æ§½ä½
            reshardSlots(newNodeId);
            
            // 4. éªŒè¯æ‰©å®¹ç»“æœ
            validateScaleOut(newNodeId);
            
            logger.info("é›†ç¾¤æ‰©å®¹å®Œæˆ: newNode={}", newNodeId);
            
        } catch (Exception e) {
            logger.error("é›†ç¾¤æ‰©å®¹å¤±è´¥", e);
            // å›æ»šæ“ä½œ
            rollbackScaleOut();
        }
    }
    
    /**
     * æ‰§è¡Œç¼©å®¹
     */
    private void scaleIn() {
        try {
            // 1. é€‰æ‹©è¦ç§»é™¤çš„èŠ‚ç‚¹
            String nodeToRemove = selectNodeToRemove();
            
            // 2. è¿ç§»æ§½ä½åˆ°å…¶ä»–èŠ‚ç‚¹
            migrateSlots(nodeToRemove);
            
            // 3. ä»é›†ç¾¤ä¸­ç§»é™¤èŠ‚ç‚¹
            removeNodeFromCluster(nodeToRemove);
            
            // 4. é”€æ¯èŠ‚ç‚¹å®ä¾‹
            destroyNode(nodeToRemove);
            
            logger.info("é›†ç¾¤ç¼©å®¹å®Œæˆ: removedNode={}", nodeToRemove);
            
        } catch (Exception e) {
            logger.error("é›†ç¾¤ç¼©å®¹å¤±è´¥", e);
            // å›æ»šæ“ä½œ
            rollbackScaleIn();
        }
    }
    
    /**
     * å¹³æ»‘é‡åˆ†ç‰‡
     */
    private void reshardSlots(String targetNodeId) {
        try {
            // è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹åº”è¯¥åˆ†é…çš„æ§½ä½æ•°
            int totalNodes = getCurrentNodeCount();
            int slotsPerNode = 16384 / totalNodes;
            
            // ä»ç°æœ‰èŠ‚ç‚¹è¿ç§»éƒ¨åˆ†æ§½ä½åˆ°æ–°èŠ‚ç‚¹
            List<String> sourceNodes = getExistingNodes();
            int slotsToMigrate = slotsPerNode;
            
            for (String sourceNode : sourceNodes) {
                if (slotsToMigrate <= 0) break;
                
                List<Integer> sourceSlots = getNodeSlots(sourceNode);
                int slotsFromThisNode = Math.min(slotsToMigrate, sourceSlots.size() / totalNodes);
                
                for (int i = 0; i < slotsFromThisNode; i++) {
                    migrateSlot(sourceSlots.get(i), sourceNode, targetNodeId);
                    slotsToMigrate--;
                }
            }
            
        } catch (Exception e) {
            logger.error("é‡åˆ†ç‰‡å¤±è´¥", e);
            throw e;
        }
    }
    
    /**
     * æ¸è¿›å¼æ§½ä½è¿ç§»
     */
    private void migrateSlot(int slot, String sourceNode, String targetNode) {
        try {
            // 1. è®¾ç½®è¿ç§»çŠ¶æ€
            setSlotMigrating(slot, sourceNode, targetNode);
            
            // 2. é€ä¸ªè¿ç§»Key
            List<String> keys = getSlotKeys(slot, sourceNode);
            int batchSize = 100; // æ¯æ‰¹è¿ç§»100ä¸ªKey
            
            for (int i = 0; i < keys.size(); i += batchSize) {
                List<String> batch = keys.subList(i, Math.min(i + batchSize, keys.size()));
                migrateBatch(batch, sourceNode, targetNode);
                
                // é¿å…é˜»å¡ï¼Œæ¯æ‰¹æ¬¡ä¹‹é—´æš‚åœ
                Thread.sleep(10);
            }
            
            // 3. å®Œæˆæ§½ä½è¿ç§»
            completeSlotMigration(slot, targetNode);
            
        } catch (Exception e) {
            logger.error("æ§½ä½è¿ç§»å¤±è´¥: slot={}", slot, e);
            throw e;
        }
    }
}

/**
 * é›†ç¾¤ç›‘æ§æŒ‡æ ‡
 */
@Data
public class ClusterMetrics {
    private double cpuUsage;           // CPUä½¿ç”¨ç‡
    private double memoryUsage;        // å†…å­˜ä½¿ç”¨ç‡
    private int connectionCount;       // è¿æ¥æ•°
    private long qps;                  // æ¯ç§’æŸ¥è¯¢æ•°
    private long networkIn;            // ç½‘ç»œå…¥æµé‡
    private long networkOut;           // ç½‘ç»œå‡ºæµé‡
    private Map<String, NodeMetrics> nodeMetrics; // å„èŠ‚ç‚¹æŒ‡æ ‡
}

@Data
public class NodeMetrics {
    private String nodeId;
    private String endpoint;
    private double cpuUsage;
    private double memoryUsage;
    private int slotCount;
    private long keyCount;
    private boolean isMaster;
}
```

**é¢è¯•åŠ åˆ†ç‚¹**ï¼š
- äº†è§£è“ç»¿éƒ¨ç½²å’Œæ»šåŠ¨å‡çº§ç­–ç•¥
- çŸ¥é“æ•°æ®é¢„çƒ­å’Œç¼“å­˜ç©¿é€é¢„é˜²
- æåˆ°ç›‘æ§å’Œè‡ªåŠ¨åŒ–è¿ç»´çš„é‡è¦æ€§

### é—®é¢˜5ï¼šå¦‚ä½•è®¾è®¡Redisé«˜å¯ç”¨æ¶æ„æ¥åº”å¯¹ä¸åŒçš„æ•…éšœåœºæ™¯ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š

**å¤šå±‚æ¬¡é«˜å¯ç”¨æ¶æ„è®¾è®¡**ï¼š

```java
/**
 * é«˜å¯ç”¨æ¶æ„è®¾è®¡
 */
@Configuration
public class HighAvailabilityArchitecture {
    
    /**
     * å¤šçº§ç¼“å­˜æ¶æ„
     */
    @Bean
    public MultiLevelCacheManager multiLevelCache() {
        return MultiLevelCacheManager.builder()
            .l1Cache(caffeineCache())           // æœ¬åœ°ç¼“å­˜
            .l2Cache(redisClusterCache())       // Redisé›†ç¾¤ç¼“å­˜
            .l3Cache(redisSentinelCache())      // Rediså“¨å…µç¼“å­˜
            .l4Cache(databaseCache())           // æ•°æ®åº“ç¼“å­˜
            .build();
    }
    
    /**
     * æ•…éšœè½¬ç§»ç­–ç•¥
     */
    @Bean
    public FailoverStrategy failoverStrategy() {
        return FailoverStrategy.builder()
            .primaryDataSource(redisCluster())
            .secondaryDataSource(redisSentinel())
            .fallbackDataSource(database())
            .circuitBreakerConfig(circuitBreakerConfig())
            .retryConfig(retryConfig())
            .build();
    }
}

/**
 * é«˜å¯ç”¨ç¼“å­˜æœåŠ¡
 */
@Service
public class HighAvailabilityCacheService {
    
    @Autowired
    private MultiLevelCacheManager cacheManager;
    
    @Autowired
    private FailoverStrategy failoverStrategy;
    
    private static final Logger logger = LoggerFactory.getLogger(HighAvailabilityCacheService.class);
    
    /**
     * é«˜å¯ç”¨è¯»å–
     */
    public <T> T get(String key, Class<T> type) {
        // L1: æœ¬åœ°ç¼“å­˜
        T value = cacheManager.getL1Cache().get(key, type);
        if (value != null) {
            logger.debug("L1ç¼“å­˜å‘½ä¸­: key={}", key);
            return value;
        }
        
        // L2: Redisé›†ç¾¤
        try {
            value = cacheManager.getL2Cache().get(key, type);
            if (value != null) {
                logger.debug("L2ç¼“å­˜å‘½ä¸­: key={}", key);
                // å›å¡«L1ç¼“å­˜
                cacheManager.getL1Cache().put(key, value);
                return value;
            }
        } catch (Exception e) {
            logger.warn("L2ç¼“å­˜è®¿é—®å¤±è´¥ï¼Œé™çº§åˆ°L3: key={}", key, e);
        }
        
        // L3: Rediså“¨å…µ
        try {
            value = cacheManager.getL3Cache().get(key, type);
            if (value != null) {
                logger.debug("L3ç¼“å­˜å‘½ä¸­: key={}", key);
                // å›å¡«ä¸Šçº§ç¼“å­˜
                backfillUpperCache(key, value);
                return value;
            }
        } catch (Exception e) {
            logger.warn("L3ç¼“å­˜è®¿é—®å¤±è´¥ï¼Œé™çº§åˆ°æ•°æ®åº“: key={}", key, e);
        }
        
        // L4: æ•°æ®åº“
        try {
            value = cacheManager.getL4Cache().get(key, type);
            if (value != null) {
                logger.debug("æ•°æ®åº“æŸ¥è¯¢æˆåŠŸ: key={}", key);
                // å›å¡«æ‰€æœ‰çº§åˆ«ç¼“å­˜
                backfillAllCache(key, value);
                return value;
            }
        } catch (Exception e) {
            logger.error("æ‰€æœ‰æ•°æ®æºè®¿é—®å¤±è´¥: key={}", key, e);
            throw new RuntimeException("æ•°æ®è®¿é—®å¤±è´¥", e);
        }
        
        return null;
    }
    
    /**
     * é«˜å¯ç”¨å†™å…¥
     */
    public void put(String key, Object value, Duration ttl) {
        List<Exception> exceptions = new ArrayList<>();
        
        // å°è¯•å†™å…¥æ‰€æœ‰å¯ç”¨çš„ç¼“å­˜å±‚
        try {
            cacheManager.getL2Cache().put(key, value, ttl);
            logger.debug("L2ç¼“å­˜å†™å…¥æˆåŠŸ: key={}", key);
        } catch (Exception e) {
            logger.warn("L2ç¼“å­˜å†™å…¥å¤±è´¥: key={}", key, e);
            exceptions.add(e);
        }
        
        try {
            cacheManager.getL3Cache().put(key, value, ttl);
            logger.debug("L3ç¼“å­˜å†™å…¥æˆåŠŸ: key={}", key);
        } catch (Exception e) {
            logger.warn("L3ç¼“å­˜å†™å…¥å¤±è´¥: key={}", key, e);
            exceptions.add(e);
        }
        
        // æ›´æ–°æœ¬åœ°ç¼“å­˜
        cacheManager.getL1Cache().put(key, value, ttl);
        
        // å¦‚æœæ‰€æœ‰è¿œç¨‹ç¼“å­˜éƒ½å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸
        if (exceptions.size() >= 2) {
            throw new RuntimeException("ç¼“å­˜å†™å…¥å¤±è´¥", exceptions.get(0));
        }
    }
    
    /**
     * æ•…éšœæ¢å¤å¤„ç†
     */
    @EventListener
    public void handleFailoverEvent(FailoverEvent event) {
        logger.info("å¤„ç†æ•…éšœè½¬ç§»äº‹ä»¶: {}", event);
        
        switch (event.getType()) {
            case REDIS_CLUSTER_DOWN:
                handleRedisClusterFailure();
                break;
            case REDIS_SENTINEL_DOWN:
                handleRedisSentinelFailure();
                break;
            case DATABASE_DOWN:
                handleDatabaseFailure();
                break;
            default:
                logger.warn("æœªçŸ¥çš„æ•…éšœç±»å‹: {}", event.getType());
        }
    }
    
    private void handleRedisClusterFailure() {
        // 1. åˆ‡æ¢åˆ°å“¨å…µæ¨¡å¼
        failoverStrategy.switchToSecondary();
        
        // 2. å¢åŠ æœ¬åœ°ç¼“å­˜å®¹é‡
        cacheManager.expandL1Cache();
        
        // 3. å¯ç”¨å†™æ“ä½œç¼“å†²
        enableWriteBuffer();
        
        // 4. å‘é€å‘Šè­¦é€šçŸ¥
        sendAlert("Redisé›†ç¾¤æ•…éšœï¼Œå·²åˆ‡æ¢åˆ°å“¨å…µæ¨¡å¼");
    }
    
    private void handleRedisSentinelFailure() {
        // 1. å®Œå…¨ä¾èµ–æœ¬åœ°ç¼“å­˜å’Œæ•°æ®åº“
        failoverStrategy.switchToFallback();
        
        // 2. å¯ç”¨è¯»å†™åˆ†ç¦»
        enableReadWriteSeparation();
        
        // 3. å¢åŠ æ•°æ®åº“è¿æ¥æ± 
        expandDatabasePool();
        
        // 4. å‘é€å‘Šè­¦é€šçŸ¥
        sendAlert("Rediså®Œå…¨æ•…éšœï¼Œå·²åˆ‡æ¢åˆ°æ•°æ®åº“æ¨¡å¼");
    }
    
    /**
     * å¥åº·æ£€æŸ¥å’Œè‡ªåŠ¨æ¢å¤
     */
    @Scheduled(fixedDelay = 30000)
    public void healthCheck() {
        // æ£€æŸ¥å„çº§ç¼“å­˜å¥åº·çŠ¶æ€
        Map<String, Boolean> healthStatus = new HashMap<>();
        
        healthStatus.put("L1_CACHE", checkL1CacheHealth());
        healthStatus.put("L2_CACHE", checkL2CacheHealth());
        healthStatus.put("L3_CACHE", checkL3CacheHealth());
        healthStatus.put("DATABASE", checkDatabaseHealth());
        
        // è‡ªåŠ¨æ¢å¤
        if (healthStatus.get("L2_CACHE") && !failoverStrategy.isL2Active()) {
            logger.info("æ£€æµ‹åˆ°L2ç¼“å­˜æ¢å¤ï¼Œå¼€å§‹è‡ªåŠ¨åˆ‡å›");
            autoRecovery();
        }
        
        // è®°å½•å¥åº·çŠ¶æ€
        logger.debug("å¥åº·æ£€æŸ¥ç»“æœ: {}", healthStatus);
    }
    
    private void autoRecovery() {
        try {
            // 1. é¢„çƒ­ç¼“å­˜
            warmupCache();
            
            // 2. åˆ‡æ¢å›ä¸»è¦æ•°æ®æº
            failoverStrategy.switchToPrimary();
            
            // 3. æ¢å¤æ­£å¸¸é…ç½®
            restoreNormalConfig();
            
            logger.info("è‡ªåŠ¨æ¢å¤å®Œæˆ");
            
        } catch (Exception e) {
            logger.error("è‡ªåŠ¨æ¢å¤å¤±è´¥", e);
        }
    }
}
```

**é¢è¯•åŠ åˆ†ç‚¹**ï¼š
- äº†è§£CAPç†è®ºåœ¨Redisä¸­çš„åº”ç”¨
- çŸ¥é“æ•°æ®ä¸€è‡´æ€§å’Œå¯ç”¨æ€§çš„æƒè¡¡
- æåˆ°å®¹ç¾å¤‡ä»½å’Œå¼‚åœ°å¤šæ´»æ–¹æ¡ˆ

## âš¡ æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹

### ä¸»ä»å¤åˆ¶æ€§èƒ½ä¼˜åŒ–

**1. å¤åˆ¶ç¼“å†²åŒºä¼˜åŒ–**
```bash
# redis.confä¼˜åŒ–é…ç½®
repl-backlog-size 64mb              # å¢å¤§å¤åˆ¶ç§¯å‹ç¼“å†²åŒº
repl-backlog-ttl 3600              # ç¼“å†²åŒºä¿ç•™æ—¶é—´1å°æ—¶
repl-timeout 60                    # å¤åˆ¶è¶…æ—¶æ—¶é—´
repl-ping-slave-period 10          # å¿ƒè·³é—´éš”
```

**2. ç½‘ç»œä¼˜åŒ–**
```bash
# å¯ç”¨TCP_NODELAYï¼Œå‡å°‘å»¶è¿Ÿ
repl-disable-tcp-nodelay no

# æ— ç›˜å¤åˆ¶ä¼˜åŒ–ï¼ˆé€‚ç”¨äºç½‘ç»œæ¯”ç£ç›˜å¿«çš„åœºæ™¯ï¼‰
repl-diskless-sync yes
repl-diskless-sync-delay 5
```

**3. ä»èŠ‚ç‚¹ä¼˜åŒ–**
```java
@Configuration
public class SlaveOptimizationConfig {
    
    /**
     * ä»èŠ‚ç‚¹è¿æ¥æ± ä¼˜åŒ–
     */
    @Bean
    public LettuceConnectionFactory optimizedSlaveFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName(slaveHost);
        config.setPort(slavePort);
        
        // ä»èŠ‚ç‚¹è¿æ¥æ± é…ç½®
        GenericObjectPoolConfig<StatefulRedisConnection<String, String>> poolConfig = 
            new GenericObjectPoolConfig<>();
        poolConfig.setMaxTotal(100);        // å¢åŠ æœ€å¤§è¿æ¥æ•°
        poolConfig.setMaxIdle(50);          // å¢åŠ æœ€å¤§ç©ºé—²è¿æ¥
        poolConfig.setMinIdle(20);          // ä¿æŒæœ€å°è¿æ¥æ•°
        poolConfig.setTestOnBorrow(false);  // å…³é—­å€Ÿç”¨æ—¶æµ‹è¯•ï¼Œæé«˜æ€§èƒ½
        poolConfig.setTestWhileIdle(true);  // ç©ºé—²æ—¶æµ‹è¯•è¿æ¥
        poolConfig.setTimeBetweenEvictionRunsMillis(30000); // 30ç§’æ£€æŸ¥ä¸€æ¬¡
        
        LettucePoolingClientConfiguration clientConfig = LettucePoolingClientConfiguration.builder()
            .poolConfig(poolConfig)
            .readFrom(ReadFrom.REPLICA)     // å¼ºåˆ¶ä»ä»èŠ‚ç‚¹è¯»å–
            .commandTimeout(Duration.ofSeconds(2))  // å‡å°‘å‘½ä»¤è¶…æ—¶æ—¶é—´
            .build();
        
        return new LettuceConnectionFactory(config, clientConfig);
    }
}
```

### Sentinelæ€§èƒ½ä¼˜åŒ–

**1. Sentinelé…ç½®ä¼˜åŒ–**
```bash
# sentinel.confæ€§èƒ½ä¼˜åŒ–
sentinel down-after-milliseconds mymaster 5000    # å‡å°‘æ•…éšœæ£€æµ‹æ—¶é—´
sentinel failover-timeout mymaster 60000          # å‡å°‘æ•…éšœè½¬ç§»è¶…æ—¶
sentinel parallel-syncs mymaster 2                # å¢åŠ å¹¶è¡ŒåŒæ­¥æ•°é‡
sentinel deny-scripts-reconfig yes                # ç¦ç”¨è„šæœ¬é‡é…ç½®æé«˜å®‰å…¨æ€§
```

**2. å®¢æˆ·ç«¯è¿æ¥ä¼˜åŒ–**
```java
@Service
public class OptimizedSentinelService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private final LoadingCache<String, Object> localCache = Caffeine.newBuilder()
        .maximumSize(10000)
        .expireAfterWrite(Duration.ofMinutes(5))
        .recordStats()
        .build(key -> {
            // ç¼“å­˜æœªå‘½ä¸­æ—¶ä»RedisåŠ è½½
            return redisTemplate.opsForValue().get(key);
        });
    
    /**
     * ä¼˜åŒ–çš„è¯»å–æ“ä½œ
     */
    public Object optimizedGet(String key) {
        try {
            // 1. å…ˆæ£€æŸ¥æœ¬åœ°ç¼“å­˜
            Object value = localCache.getIfPresent(key);
            if (value != null) {
                return value;
            }
            
            // 2. ä»Redisè¯»å–
            value = redisTemplate.opsForValue().get(key);
            if (value != null) {
                // 3. æ›´æ–°æœ¬åœ°ç¼“å­˜
                localCache.put(key, value);
            }
            
            return value;
            
        } catch (Exception e) {
            // 4. æ•…éšœæ—¶è¿”å›æœ¬åœ°ç¼“å­˜
            Object cachedValue = localCache.getIfPresent(key);
            if (cachedValue != null) {
                logger.warn("Redisè®¿é—®å¤±è´¥ï¼Œè¿”å›æœ¬åœ°ç¼“å­˜: key={}", key);
                return cachedValue;
            }
            throw e;
        }
    }
    
    /**
     * æ‰¹é‡é¢„åŠ è½½
     */
    @Async
    public void preloadCache(List<String> keys) {
        try {
            List<Object> values = redisTemplate.opsForValue().multiGet(keys);
            for (int i = 0; i < keys.size(); i++) {
                if (values.get(i) != null) {
                    localCache.put(keys.get(i), values.get(i));
                }
            }
            logger.info("é¢„åŠ è½½ç¼“å­˜å®Œæˆ: count={}", keys.size());
        } catch (Exception e) {
            logger.error("é¢„åŠ è½½ç¼“å­˜å¤±è´¥", e);
        }
    }
}
```

### Clusteræ€§èƒ½ä¼˜åŒ–

**1. æ§½ä½åˆ†å¸ƒä¼˜åŒ–**
```java
/**
 * é›†ç¾¤æ§½ä½ä¼˜åŒ–ç®¡ç†
 */
@Service
public class ClusterSlotOptimizer {
    
    /**
     * æ™ºèƒ½æ§½ä½é‡åˆ†é…
     */
    public void optimizeSlotDistribution() {
        try {
            // 1. æ”¶é›†å„èŠ‚ç‚¹è´Ÿè½½ä¿¡æ¯
            Map<String, NodeLoad> nodeLoads = collectNodeLoads();
            
            // 2. è®¡ç®—æœ€ä¼˜åˆ†é…æ–¹æ¡ˆ
            Map<String, List<Integer>> optimalDistribution = calculateOptimalDistribution(nodeLoads);
            
            // 3. æ‰§è¡Œæ¸è¿›å¼é‡åˆ†é…
            executeGradualRebalancing(optimalDistribution);
            
        } catch (Exception e) {
            logger.error("æ§½ä½ä¼˜åŒ–å¤±è´¥", e);
        }
    }
    
    /**
     * çƒ­ç‚¹Keyæ£€æµ‹å’Œä¼˜åŒ–
     */
    @Scheduled(fixedDelay = 300000) // 5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    public void detectAndOptimizeHotKeys() {
        try {
            // 1. æ£€æµ‹çƒ­ç‚¹Key
            Map<String, Long> hotKeys = detectHotKeys();
            
            // 2. åˆ†æçƒ­ç‚¹åˆ†å¸ƒ
            Map<Integer, List<String>> hotKeysBySlot = groupHotKeysBySlot(hotKeys);
            
            // 3. ä¼˜åŒ–çƒ­ç‚¹æ§½ä½
            for (Map.Entry<Integer, List<String>> entry : hotKeysBySlot.entrySet()) {
                int slot = entry.getKey();
                List<String> keys = entry.getValue();
                
                if (keys.size() > 100) { // çƒ­ç‚¹é˜ˆå€¼
                    optimizeHotSlot(slot, keys);
                }
            }
            
        } catch (Exception e) {
            logger.error("çƒ­ç‚¹Keyä¼˜åŒ–å¤±è´¥", e);
        }
    }
    
    private void optimizeHotSlot(int slot, List<String> hotKeys) {
        // 1. ä¸ºçƒ­ç‚¹Keyåˆ›å»ºæœ¬åœ°ç¼“å­˜
        for (String key : hotKeys) {
            String value = getFromRedis(key);
            if (value != null) {
                localCache.put(key, value, Duration.ofMinutes(10));
            }
        }
        
        // 2. è€ƒè™‘å°†çƒ­ç‚¹æ§½ä½è¿ç§»åˆ°æ€§èƒ½æ›´å¥½çš„èŠ‚ç‚¹
        String currentNode = getSlotNode(slot);
        String betterNode = findBetterNodeForHotSlot(slot);
        
        if (betterNode != null && !betterNode.equals(currentNode)) {
            logger.info("è®¡åˆ’è¿ç§»çƒ­ç‚¹æ§½ä½: slot={}, from={}, to={}", slot, currentNode, betterNode);
            // è¿™é‡Œå¯ä»¥æ ‡è®°ä¸ºå¾…è¿ç§»ï¼Œåœ¨ä½å³°æœŸæ‰§è¡Œ
            scheduleSlotMigration(slot, currentNode, betterNode);
        }
    }
}
```

**2. è¿æ¥æ± ä¼˜åŒ–**
```java
@Configuration
public class ClusterConnectionOptimization {
    
    @Bean
    public LettuceConnectionFactory optimizedClusterFactory() {
        RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration(clusterNodes);
        clusterConfig.setMaxRedirects(2); // å‡å°‘é‡å®šå‘æ¬¡æ•°
        
        // ä¼˜åŒ–çš„è¿æ¥æ± é…ç½®
        GenericObjectPoolConfig<StatefulRedisConnection<String, String>> poolConfig = 
            new GenericObjectPoolConfig<>();
        poolConfig.setMaxTotal(200);        // å¢åŠ æ€»è¿æ¥æ•°
        poolConfig.setMaxIdle(100);         // å¢åŠ æœ€å¤§ç©ºé—²è¿æ¥
        poolConfig.setMinIdle(50);          // ä¿æŒè¶³å¤Ÿçš„æœ€å°è¿æ¥
        poolConfig.setTestOnBorrow(false);  // å…³é—­å€Ÿç”¨æµ‹è¯•
        poolConfig.setTestOnReturn(false);  // å…³é—­å½’è¿˜æµ‹è¯•
        poolConfig.setTestWhileIdle(true);  // åªåœ¨ç©ºé—²æ—¶æµ‹è¯•
        poolConfig.setBlockWhenExhausted(false); // è¿æ¥è€—å°½æ—¶ä¸é˜»å¡
        
        LettucePoolingClientConfiguration clientConfig = LettucePoolingClientConfiguration.builder()
            .poolConfig(poolConfig)
            .commandTimeout(Duration.ofSeconds(3))
            .shutdownTimeout(Duration.ofSeconds(5))
            .readFrom(ReadFrom.REPLICA_PREFERRED)
            .build();
        
        return new LettuceConnectionFactory(clusterConfig, clientConfig);
    }
}
```

### é‡è¦æ³¨æ„äº‹é¡¹

**1. æ•°æ®ä¸€è‡´æ€§æƒè¡¡**
```java
/**
 * ä¸€è‡´æ€§çº§åˆ«é…ç½®
 */
@Component
public class ConsistencyManager {
    
    public enum ConsistencyLevel {
        EVENTUAL,    // æœ€ç»ˆä¸€è‡´æ€§
        STRONG,      // å¼ºä¸€è‡´æ€§
        WEAK         // å¼±ä¸€è‡´æ€§
    }
    
    /**
     * æ ¹æ®ä¸šåŠ¡åœºæ™¯é€‰æ‹©ä¸€è‡´æ€§çº§åˆ«
     */
    public void writeWithConsistency(String key, Object value, ConsistencyLevel level) {
        switch (level) {
            case STRONG:
                // åŒæ­¥å†™å…¥ä¸»èŠ‚ç‚¹ï¼Œç­‰å¾…ä»èŠ‚ç‚¹ç¡®è®¤
                writeToMasterAndWaitSlaves(key, value);
                break;
            case EVENTUAL:
                // åªå†™å…¥ä¸»èŠ‚ç‚¹ï¼Œå¼‚æ­¥å¤åˆ¶åˆ°ä»èŠ‚ç‚¹
                writeToMasterOnly(key, value);
                break;
            case WEAK:
                // å†™å…¥ä»»æ„å¯ç”¨èŠ‚ç‚¹
                writeToAnyAvailableNode(key, value);
                break;
        }
    }
}
```

**2. å®¹é‡è§„åˆ’å»ºè®®**
```java
/**
 * å®¹é‡è§„åˆ’å·¥å…·
 */
@Component
public class CapacityPlanner {
    
    /**
     * è®¡ç®—é›†ç¾¤å®¹é‡éœ€æ±‚
     */
    public ClusterCapacityPlan calculateCapacity(BusinessRequirement requirement) {
        // 1. æ•°æ®é‡ä¼°ç®—
        long totalDataSize = requirement.getKeyCount() * requirement.getAvgValueSize();
        
        // 2. å†…å­˜éœ€æ±‚ï¼ˆè€ƒè™‘å¤åˆ¶å’Œå¼€é”€ï¼‰
        long memoryRequired = totalDataSize * 2 * 1.2; // ä¸»ä»å¤åˆ¶ + 20%å¼€é”€
        
        // 3. QPSéœ€æ±‚åˆ†æ
        long readQps = requirement.getReadQps();
        long writeQps = requirement.getWriteQps();
        
        // 4. èŠ‚ç‚¹æ•°é‡è®¡ç®—
        int nodeCount = Math.max(
            (int) Math.ceil(memoryRequired / MAX_NODE_MEMORY),
            (int) Math.ceil((readQps + writeQps) / MAX_NODE_QPS)
        );
        
        // 5. ç¡®ä¿æœ€å°èŠ‚ç‚¹æ•°
        nodeCount = Math.max(nodeCount, 3);
        
        return ClusterCapacityPlan.builder()
            .nodeCount(nodeCount)
            .memoryPerNode(memoryRequired / nodeCount)
            .expectedQpsPerNode((readQps + writeQps) / nodeCount)
            .replicationFactor(2)
            .build();
    }
}
```

**3. ç›‘æ§å‘Šè­¦é…ç½®**
```yaml
# ç›‘æ§æŒ‡æ ‡é˜ˆå€¼é…ç½®
monitoring:
  redis:
    cluster:
      # èŠ‚ç‚¹å¥åº·ç›‘æ§
      node-down-threshold: 1          # èŠ‚ç‚¹ä¸‹çº¿å‘Šè­¦é˜ˆå€¼
      memory-usage-threshold: 85      # å†…å­˜ä½¿ç”¨ç‡å‘Šè­¦é˜ˆå€¼
      cpu-usage-threshold: 80         # CPUä½¿ç”¨ç‡å‘Šè­¦é˜ˆå€¼
      connection-threshold: 8000      # è¿æ¥æ•°å‘Šè­¦é˜ˆå€¼
      
      # æ€§èƒ½ç›‘æ§
      response-time-threshold: 100    # å“åº”æ—¶é—´å‘Šè­¦é˜ˆå€¼ï¼ˆæ¯«ç§’ï¼‰
      qps-threshold: 50000           # QPSå‘Šè­¦é˜ˆå€¼
      error-rate-threshold: 1        # é”™è¯¯ç‡å‘Šè­¦é˜ˆå€¼ï¼ˆ%ï¼‰
      
      # å¤åˆ¶ç›‘æ§
      replication-lag-threshold: 10   # å¤åˆ¶å»¶è¿Ÿå‘Šè­¦é˜ˆå€¼ï¼ˆç§’ï¼‰
      backlog-usage-threshold: 80     # ç§¯å‹ç¼“å†²åŒºä½¿ç”¨ç‡é˜ˆå€¼
      
      # é›†ç¾¤ç›‘æ§
      slot-migration-timeout: 300     # æ§½ä½è¿ç§»è¶…æ—¶å‘Šè­¦ï¼ˆç§’ï¼‰
      cluster-state-check-interval: 30 # é›†ç¾¤çŠ¶æ€æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
```

**4. å¸¸è§é—®é¢˜é¿å…**
- **é¿å…å¤§Key**ï¼šå•ä¸ªKeyä¸è¶…è¿‡10MBï¼Œä½¿ç”¨Hashåˆ†ç‰‡
- **é¿å…çƒ­ç‚¹Key**ï¼šä½¿ç”¨æœ¬åœ°ç¼“å­˜å’Œå¤šçº§ç¼“å­˜
- **é¿å…é˜»å¡æ“ä½œ**ï¼šä½¿ç”¨SCANæ›¿ä»£KEYSï¼Œé¿å…é•¿æ—¶é—´çš„SORTæ“ä½œ
- **åˆç†è®¾ç½®è¿‡æœŸæ—¶é—´**ï¼šé¿å…å¤§é‡KeyåŒæ—¶è¿‡æœŸ
- **ç›‘æ§æ…¢æŸ¥è¯¢**ï¼šè®¾ç½®slowlogç›‘æ§ï¼Œä¼˜åŒ–æ…¢æŸ¥è¯¢
- **ç½‘ç»œä¼˜åŒ–**ï¼šä½¿ç”¨pipelineæ‰¹é‡æ“ä½œï¼Œå‡å°‘ç½‘ç»œå¾€è¿”
- **å†…å­˜ä¼˜åŒ–**ï¼šåˆç†é…ç½®maxmemoryå’Œæ·˜æ±°ç­–ç•¥

## ğŸ“š æ€»ç»“ä¸æŠ€æœ¯å¯¹æ¯”

### Redisé«˜å¯ç”¨æ–¹æ¡ˆå¯¹æ¯”

| ç‰¹æ€§ | ä¸»ä»å¤åˆ¶ | Sentinelå“¨å…µ | Clusteré›†ç¾¤ |
|------|----------|-------------|-------------|
| **éƒ¨ç½²å¤æ‚åº¦** | ç®€å• | ä¸­ç­‰ | å¤æ‚ |
| **æ•…éšœè½¬ç§»** | æ‰‹åŠ¨ | è‡ªåŠ¨ | è‡ªåŠ¨ |
| **æ•°æ®åˆ†ç‰‡** | ä¸æ”¯æŒ | ä¸æ”¯æŒ | æ”¯æŒ |
| **æ‰©å±•æ€§** | å‚ç›´æ‰©å±• | å‚ç›´æ‰©å±• | æ°´å¹³æ‰©å±• |
| **ä¸€è‡´æ€§** | æœ€ç»ˆä¸€è‡´æ€§ | æœ€ç»ˆä¸€è‡´æ€§ | æœ€ç»ˆä¸€è‡´æ€§ |
| **å®¢æˆ·ç«¯å¤æ‚åº¦** | ä½ | ä¸­ç­‰ | é«˜ |
| **è¿ç»´æˆæœ¬** | ä½ | ä¸­ç­‰ | é«˜ |
| **é€‚ç”¨åœºæ™¯** | å°è§„æ¨¡ã€è¯»å¤šå†™å°‘ | ä¸­ç­‰è§„æ¨¡ã€é«˜å¯ç”¨è¦æ±‚ | å¤§è§„æ¨¡ã€é«˜å¹¶å‘ |

### æ–¹æ¡ˆé€‰æ‹©å»ºè®®

**1. ä¸»ä»å¤åˆ¶é€‚ç”¨åœºæ™¯**
```java
// é€‚ç”¨æ¡ä»¶è¯„ä¼°
public class MasterSlaveScenario {
    public boolean isApplicable(SystemRequirement req) {
        return req.getDataSize() < 50_000_000_000L &&      // æ•°æ®é‡ < 50GB
               req.getWriteQps() < 10_000 &&               // å†™QPS < 1ä¸‡
               req.getReadQps() < 50_000 &&                // è¯»QPS < 5ä¸‡
               req.getDowntimeTolerance() > 300 &&         // å¯å®¹å¿5åˆ†é’Ÿæ•…éšœ
               req.getTeamSize() < 5;                      // è¿ç»´å›¢é˜Ÿ < 5äºº
    }
}
```

**2. Sentinelå“¨å…µé€‚ç”¨åœºæ™¯**
```java
// é€‚ç”¨æ¡ä»¶è¯„ä¼°
public class SentinelScenario {
    public boolean isApplicable(SystemRequirement req) {
        return req.getDataSize() < 200_000_000_000L &&     // æ•°æ®é‡ < 200GB
               req.getWriteQps() < 50_000 &&               // å†™QPS < 5ä¸‡
               req.getReadQps() < 200_000 &&               // è¯»QPS < 20ä¸‡
               req.getDowntimeTolerance() < 60 &&          // æ•…éšœæ¢å¤ < 1åˆ†é’Ÿ
               req.isHighAvailabilityRequired();           // éœ€è¦é«˜å¯ç”¨
    }
}
```

**3. Clusteré›†ç¾¤é€‚ç”¨åœºæ™¯**
```java
// é€‚ç”¨æ¡ä»¶è¯„ä¼°
public class ClusterScenario {
    public boolean isApplicable(SystemRequirement req) {
        return req.getDataSize() > 100_000_000_000L ||     // æ•°æ®é‡ > 100GB
               req.getWriteQps() > 30_000 ||               // å†™QPS > 3ä¸‡
               req.getReadQps() > 100_000 ||               // è¯»QPS > 10ä¸‡
               req.isHorizontalScalingRequired() ||        // éœ€è¦æ°´å¹³æ‰©å±•
               req.getGrowthRate() > 0.5;                  // å¹´å¢é•¿ç‡ > 50%
    }
}
```

### æ¶æ„æ¼”è¿›è·¯å¾„

**1. æ¸è¿›å¼æ¼”è¿›ç­–ç•¥**
```java
/**
 * Redisæ¶æ„æ¼”è¿›ç®¡ç†å™¨
 */
@Service
public class ArchitectureEvolutionManager {
    
    /**
     * è¯„ä¼°å½“å‰æ¶æ„æ˜¯å¦éœ€è¦å‡çº§
     */
    public EvolutionPlan evaluateEvolution(CurrentArchitecture current, SystemMetrics metrics) {
        EvolutionPlan plan = new EvolutionPlan();
        
        // 1. è¯„ä¼°æ€§èƒ½ç“¶é¢ˆ
        if (isPerformanceBottleneck(metrics)) {
            if (current.getType() == ArchitectureType.MASTER_SLAVE) {
                plan.recommendUpgrade(ArchitectureType.SENTINEL, "æ€§èƒ½ç“¶é¢ˆï¼Œå»ºè®®å‡çº§åˆ°Sentinel");
            } else if (current.getType() == ArchitectureType.SENTINEL) {
                plan.recommendUpgrade(ArchitectureType.CLUSTER, "æ€§èƒ½ç“¶é¢ˆï¼Œå»ºè®®å‡çº§åˆ°Cluster");
            }
        }
        
        // 2. è¯„ä¼°å¯ç”¨æ€§éœ€æ±‚
        if (isAvailabilityInsufficient(current, metrics)) {
            if (current.getType() == ArchitectureType.MASTER_SLAVE) {
                plan.recommendUpgrade(ArchitectureType.SENTINEL, "å¯ç”¨æ€§ä¸è¶³ï¼Œéœ€è¦è‡ªåŠ¨æ•…éšœè½¬ç§»");
            }
        }
        
        // 3. è¯„ä¼°æ‰©å±•æ€§éœ€æ±‚
        if (isScalabilityInsufficient(current, metrics)) {
            plan.recommendUpgrade(ArchitectureType.CLUSTER, "æ‰©å±•æ€§ä¸è¶³ï¼Œéœ€è¦æ°´å¹³æ‰©å±•");
        }
        
        return plan;
    }
    
    /**
     * æ‰§è¡Œæ¶æ„å‡çº§
     */
    public void executeEvolution(EvolutionPlan plan) {
        try {
            switch (plan.getTargetArchitecture()) {
                case SENTINEL:
                    upgradeToSentinel(plan);
                    break;
                case CLUSTER:
                    upgradeToCluster(plan);
                    break;
                default:
                    throw new UnsupportedOperationException("ä¸æ”¯æŒçš„æ¶æ„ç±»å‹");
            }
        } catch (Exception e) {
            logger.error("æ¶æ„å‡çº§å¤±è´¥", e);
            rollbackEvolution(plan);
        }
    }
    
    private void upgradeToSentinel(EvolutionPlan plan) {
        // 1. éƒ¨ç½²SentinelèŠ‚ç‚¹
        deploySentinelNodes();
        
        // 2. é…ç½®ä¸»ä»ç›‘æ§
        configureMasterSlaveMonitoring();
        
        // 3. åˆ‡æ¢å®¢æˆ·ç«¯è¿æ¥
        switchClientToSentinel();
        
        // 4. éªŒè¯å‡çº§ç»“æœ
        validateSentinelDeployment();
    }
    
    private void upgradeToCluster(EvolutionPlan plan) {
        // 1. åˆ›å»ºé›†ç¾¤èŠ‚ç‚¹
        createClusterNodes();
        
        // 2. åˆå§‹åŒ–é›†ç¾¤
        initializeCluster();
        
        // 3. æ•°æ®è¿ç§»
        migrateDataToCluster();
        
        // 4. åˆ‡æ¢å®¢æˆ·ç«¯
        switchClientToCluster();
        
        // 5. éªŒè¯é›†ç¾¤çŠ¶æ€
        validateClusterDeployment();
    }
}
```

**2. é›¶åœæœºå‡çº§ç­–ç•¥**
```java
/**
 * é›¶åœæœºå‡çº§å®ç°
 */
@Service
public class ZeroDowntimeUpgradeService {
    
    /**
     * ä¸»ä»åˆ°Sentinelé›¶åœæœºå‡çº§
     */
    public void upgradeToSentinelZeroDowntime() {
        try {
            // 1. åœ¨ç°æœ‰ä¸»ä»åŸºç¡€ä¸Šéƒ¨ç½²Sentinel
            List<String> sentinelNodes = deploySentinelNodesParallel();
            
            // 2. é…ç½®Sentinelç›‘æ§ç°æœ‰ä¸»ä»
            configureSentinelMonitoring(sentinelNodes);
            
            // 3. éªŒè¯Sentinelæ­£å¸¸å·¥ä½œ
            validateSentinelOperations();
            
            // 4. é€æ­¥åˆ‡æ¢å®¢æˆ·ç«¯è¿æ¥
            gradualClientMigration();
            
            // 5. æ¸…ç†æ—§é…ç½®
            cleanupOldConfiguration();
            
            logger.info("é›¶åœæœºå‡çº§åˆ°Sentinelå®Œæˆ");
            
        } catch (Exception e) {
            logger.error("é›¶åœæœºå‡çº§å¤±è´¥ï¼Œå¼€å§‹å›æ»š", e);
            rollbackToMasterSlave();
        }
    }
    
    /**
     * Sentinelåˆ°Clusteré›¶åœæœºå‡çº§
     */
    public void upgradeToClusterZeroDowntime() {
        try {
            // 1. åˆ›å»ºæ–°çš„é›†ç¾¤ç¯å¢ƒ
            ClusterEnvironment newCluster = createNewClusterEnvironment();
            
            // 2. å®æ—¶æ•°æ®åŒæ­¥
            startRealTimeDataSync(newCluster);
            
            // 3. éªŒè¯æ•°æ®ä¸€è‡´æ€§
            validateDataConsistency();
            
            // 4. åˆ‡æ¢è¯»æµé‡åˆ°æ–°é›†ç¾¤
            switchReadTrafficToCluster(newCluster);
            
            // 5. åˆ‡æ¢å†™æµé‡åˆ°æ–°é›†ç¾¤
            switchWriteTrafficToCluster(newCluster);
            
            // 6. åœæ­¢æ—§ç¯å¢ƒ
            shutdownOldEnvironment();
            
            logger.info("é›¶åœæœºå‡çº§åˆ°Clusterå®Œæˆ");
            
        } catch (Exception e) {
            logger.error("é›¶åœæœºå‡çº§å¤±è´¥ï¼Œå¼€å§‹å›æ»š", e);
            rollbackToSentinel();
        }
    }
    
    /**
     * æ¸è¿›å¼å®¢æˆ·ç«¯è¿ç§»
     */
    private void gradualClientMigration() {
        List<String> clientGroups = getClientGroups();
        
        for (String group : clientGroups) {
            try {
                // 1. åˆ‡æ¢å®¢æˆ·ç«¯ç»„åˆ°æ–°æ¶æ„
                switchClientGroup(group);
                
                // 2. ç›‘æ§åˆ‡æ¢åçš„æ€§èƒ½
                monitorPerformanceAfterSwitch(group);
                
                // 3. ç­‰å¾…ä¸€æ®µæ—¶é—´ç¡®ä¿ç¨³å®š
                Thread.sleep(60000); // ç­‰å¾…1åˆ†é’Ÿ
                
                logger.info("å®¢æˆ·ç«¯ç»„åˆ‡æ¢å®Œæˆ: {}", group);
                
            } catch (Exception e) {
                logger.error("å®¢æˆ·ç«¯ç»„åˆ‡æ¢å¤±è´¥: {}", group, e);
                // å›æ»šè¯¥å®¢æˆ·ç«¯ç»„
                rollbackClientGroup(group);
                throw e;
            }
        }
    }
}
```

### æœ€ä½³å®è·µæ€»ç»“

**1. æ¶æ„è®¾è®¡åŸåˆ™**
- **æ¸è¿›å¼æ¼”è¿›**ï¼šä»ç®€å•åˆ°å¤æ‚ï¼Œæ ¹æ®ä¸šåŠ¡éœ€æ±‚é€æ­¥å‡çº§
- **ç›‘æ§å…ˆè¡Œ**ï¼šå®Œå–„çš„ç›‘æ§ä½“ç³»æ˜¯é«˜å¯ç”¨çš„åŸºç¡€
- **è‡ªåŠ¨åŒ–è¿ç»´**ï¼šå‡å°‘äººå·¥å¹²é¢„ï¼Œæé«˜è¿ç»´æ•ˆç‡
- **å®¹é‡è§„åˆ’**ï¼šæå‰è§„åˆ’å®¹é‡ï¼Œé¿å…ä¸´æ—¶æ‰©å®¹
- **æ•…éšœæ¼”ç»ƒ**ï¼šå®šæœŸè¿›è¡Œæ•…éšœæ¼”ç»ƒï¼ŒéªŒè¯é«˜å¯ç”¨æ–¹æ¡ˆ

**2. è¿ç»´å»ºè®®**
- **æ–‡æ¡£å®Œå–„**ï¼šç»´æŠ¤è¯¦ç»†çš„æ¶æ„æ–‡æ¡£å’Œè¿ç»´æ‰‹å†Œ
- **ç‰ˆæœ¬ç®¡ç†**ï¼šç»Ÿä¸€Redisç‰ˆæœ¬ï¼Œä¾¿äºç»´æŠ¤å‡çº§
- **é…ç½®ç®¡ç†**ï¼šä½¿ç”¨é…ç½®ç®¡ç†å·¥å…·ç»Ÿä¸€ç®¡ç†é…ç½®
- **å¤‡ä»½ç­–ç•¥**ï¼šåˆ¶å®šå®Œå–„çš„æ•°æ®å¤‡ä»½å’Œæ¢å¤ç­–ç•¥
- **å®‰å…¨åŠ å›º**ï¼šé…ç½®è®¿é—®æ§åˆ¶ã€ç½‘ç»œéš”ç¦»ç­‰å®‰å…¨æªæ–½

**3. å¼€å‘å»ºè®®**
- **å®¢æˆ·ç«¯ä¼˜åŒ–**ï¼šåˆç†é…ç½®è¿æ¥æ± å’Œè¶…æ—¶å‚æ•°
- **æ•°æ®æ¨¡å‹è®¾è®¡**ï¼šé¿å…å¤§Keyå’Œçƒ­ç‚¹Key
- **ç¼“å­˜ç­–ç•¥**ï¼šè®¾è®¡åˆç†çš„ç¼“å­˜æ›´æ–°å’Œå¤±æ•ˆç­–ç•¥
- **é™çº§æ–¹æ¡ˆ**ï¼šå‡†å¤‡ç¼“å­˜é™çº§å’Œç†”æ–­æœºåˆ¶
- **æ€§èƒ½æµ‹è¯•**ï¼šå®šæœŸè¿›è¡Œæ€§èƒ½å‹æµ‹ï¼Œå‘ç°æ½œåœ¨é—®é¢˜

Redisé›†ç¾¤æ¶æ„ä¸é«˜å¯ç”¨æ–¹æ¡ˆæ˜¯æ„å»ºå¤§è§„æ¨¡åˆ†å¸ƒå¼ç³»ç»Ÿçš„é‡è¦åŸºç¡€è®¾æ–½ã€‚é€šè¿‡åˆç†é€‰æ‹©æ¶æ„æ–¹æ¡ˆã€ä¼˜åŒ–é…ç½®å‚æ•°ã€å®Œå–„ç›‘æ§ä½“ç³»ï¼Œå¯ä»¥æ„å»ºå‡ºç¨³å®šå¯é çš„Redisé«˜å¯ç”¨æœåŠ¡ï¼Œä¸ºä¸šåŠ¡ç³»ç»Ÿæä¾›å¼ºæœ‰åŠ›çš„ç¼“å­˜æ”¯æ’‘ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œéœ€è¦æ ¹æ®å…·ä½“çš„ä¸šåŠ¡åœºæ™¯å’ŒæŠ€æœ¯è¦æ±‚ï¼Œé€‰æ‹©æœ€é€‚åˆçš„é«˜å¯ç”¨æ–¹æ¡ˆï¼Œå¹¶åˆ¶å®šå®Œå–„çš„è¿ç»´ç­–ç•¥ã€‚