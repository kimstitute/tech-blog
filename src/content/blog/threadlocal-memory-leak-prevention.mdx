---
title: "ThreadLocalåŸç†ä¸å†…å­˜æ³„æ¼é˜²èŒƒå®æˆ˜"
description: "æ·±å…¥è§£æJava ThreadLocalçš„å®ç°åŸç†ã€ThreadLocalMapç»“æ„å’Œå¼±å¼•ç”¨æœºåˆ¶ã€‚ç»“åˆå®é™…é¡¹ç›®åœºæ™¯åˆ†æå†…å­˜æ³„æ¼æˆå› ï¼Œæä¾›å®Œæ•´çš„é˜²èŒƒç­–ç•¥å’Œæœ€ä½³å®è·µï¼ŒæŒæ¡çº¿ç¨‹æœ¬åœ°å­˜å‚¨çš„æ­£ç¡®ä½¿ç”¨æ–¹æ³•ã€‚"
pubDate: 2024-12-06
updatedDate: 2024-12-06
tags: ["java", "threadlocal", "memory-leak", "weak-reference", "thread-safety", "interview", "best-practices"]
categories: ["java-core"]
subject: "å¹¶å‘ç¼–ç¨‹"
draft: false
featured: true
author: "Gerrad Zhang"
location: "æ­¦æ±‰ï¼Œä¸­å›½"
---

## ğŸ¤” é—®é¢˜èƒŒæ™¯ä¸æŠ€æœ¯æ¼”è¿›

### æˆ‘ä»¬è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ï¼Œ**çº¿ç¨‹é—´æ•°æ®éš”ç¦»**æ˜¯ä¸€ä¸ªæ ¸å¿ƒæŒ‘æˆ˜ã€‚ä¼ ç»Ÿçš„åŒæ­¥æœºåˆ¶è™½ç„¶èƒ½ä¿è¯æ•°æ®ä¸€è‡´æ€§ï¼Œä½†ä¹Ÿå¸¦æ¥äº†æ€§èƒ½é—®é¢˜ï¼š

- **é”ç«äº‰å¼€é”€**ï¼šå¤šçº¿ç¨‹è®¿é—®å…±äº«å˜é‡éœ€è¦åŒæ­¥ï¼Œé€ æˆæ€§èƒ½ç“¶é¢ˆ
- **ä¸Šä¸‹æ–‡åˆ‡æ¢**ï¼šçº¿ç¨‹é˜»å¡å’Œå”¤é†’å¯¼è‡´é¢‘ç¹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢
- **æ•°æ®æ±¡æŸ“**ï¼šçº¿ç¨‹é—´å…±äº«æ•°æ®å®¹æ˜“ç›¸äº’å½±å“ï¼Œéš¾ä»¥è°ƒè¯•
- **ç¼–ç¨‹å¤æ‚æ€§**ï¼šéœ€è¦è€ƒè™‘å„ç§å¹¶å‘åœºæ™¯ï¼Œä»£ç å¤æ‚åº¦é«˜

```java
// ä¼ ç»Ÿå…±äº«å˜é‡çš„é—®é¢˜ç¤ºä¾‹
public class SharedVariableProblem {
    private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
    
    // å¤šçº¿ç¨‹ä½¿ç”¨åŒä¸€ä¸ªSimpleDateFormatå®ä¾‹
    public String formatDate(Date date) {
        // é—®é¢˜ï¼šSimpleDateFormatä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„
        // å¤šçº¿ç¨‹åŒæ—¶è°ƒç”¨å¯èƒ½äº§ç”Ÿé”™è¯¯ç»“æœæˆ–å¼‚å¸¸
        return sdf.format(date);
    }
}
```

### æ²¡æœ‰è¿™ä¸ªæŠ€æœ¯æ—¶æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ

åœ¨ThreadLocalå‡ºç°ä¹‹å‰ï¼Œå¼€å‘è€…ä¸»è¦é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°çº¿ç¨‹æ•°æ®éš”ç¦»ï¼š

**1. æ–¹æ³•å‚æ•°ä¼ é€’**
- å°†éœ€è¦çš„æ•°æ®é€šè¿‡æ–¹æ³•å‚æ•°å±‚å±‚ä¼ é€’
- **é—®é¢˜**ï¼šå‚æ•°ä¼ é€’é“¾è·¯é•¿ï¼Œä»£ç å†—ä½™ï¼Œç»´æŠ¤å›°éš¾

**2. çº¿ç¨‹åŒæ­¥æœºåˆ¶**
- ä½¿ç”¨synchronizedã€Lockç­‰åŒæ­¥æ‰€æœ‰å…±äº«èµ„æºè®¿é—®
- **é—®é¢˜**ï¼šæ€§èƒ½å¼€é”€å¤§ï¼Œå¯èƒ½äº§ç”Ÿæ­»é”

**3. çº¿ç¨‹å®‰å…¨çš„ç±»**
- æ¯æ¬¡ä½¿ç”¨éƒ½åˆ›å»ºæ–°çš„å¯¹è±¡å®ä¾‹
- **é—®é¢˜**ï¼šå¯¹è±¡åˆ›å»ºå¼€é”€å¤§ï¼ŒGCå‹åŠ›å¢åŠ 

**4. æ‰‹å·¥çº¿ç¨‹æ˜ å°„**
- ç»´æŠ¤Threadåˆ°æ•°æ®çš„æ˜ å°„å…³ç³»
- **é—®é¢˜**ï¼šå†…å­˜æ³„æ¼é£é™©é«˜ï¼Œå®ç°å¤æ‚

### æŠ€æœ¯æ¼”è¿›çš„å†å²è„‰ç»œ

**JDK 1.2 (1998)**ï¼šThreadLocalé¦–æ¬¡å¼•å…¥
- æä¾›åŸºæœ¬çš„çº¿ç¨‹æœ¬åœ°å­˜å‚¨åŠŸèƒ½
- åŸºäºThreadå†…éƒ¨çš„Mapå®ç°
- å­˜åœ¨å†…å­˜æ³„æ¼é£é™©

**JDK 1.5 (2004)**ï¼šå¼•å…¥æ³›å‹æ”¯æŒ
- `ThreadLocal<T>`æä¾›ç±»å‹å®‰å…¨
- æ”¹è¿›APIè®¾è®¡ï¼Œä½¿ç”¨æ›´åŠ ä¾¿æ·
- å¢å¼ºç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥

**JDK 1.6åŠä»¥å**ï¼šæŒç»­ä¼˜åŒ–
- ä¼˜åŒ–å¼±å¼•ç”¨æœºåˆ¶
- æ”¹è¿›å†…å­˜å›æ”¶ç­–ç•¥
- ä¸å¹¶å‘åŒ…å½¢æˆå®Œæ•´ç”Ÿæ€

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µä¸åŸç†

### åŸºç¡€æ¦‚å¿µå®šä¹‰

**ThreadLocal**æ˜¯Javaæä¾›çš„çº¿ç¨‹æœ¬åœ°å­˜å‚¨æœºåˆ¶ï¼Œä¸ºæ¯ä¸ªçº¿ç¨‹æä¾›ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œå®ç°çº¿ç¨‹é—´çš„æ•°æ®éš”ç¦»ã€‚

**æ ¸å¿ƒç‰¹æ€§**ï¼š
- **çº¿ç¨‹éš”ç¦»**ï¼šæ¯ä¸ªçº¿ç¨‹æ‹¥æœ‰ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œäº’ä¸å¹²æ‰°
- **æ— é”è®¿é—®**ï¼šçº¿ç¨‹è®¿é—®è‡ªå·±çš„å‰¯æœ¬æ— éœ€åŒæ­¥ï¼Œæ€§èƒ½ä¼˜å¼‚
- **è‡ªåŠ¨ç®¡ç†**ï¼šå˜é‡å‰¯æœ¬çš„åˆ›å»ºå’Œè®¿é—®ç”±ThreadLocalè‡ªåŠ¨å¤„ç†
- **ç±»å‹å®‰å…¨**ï¼šæ”¯æŒæ³›å‹ï¼Œæä¾›ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥

### ThreadLocalçš„å·¥ä½œåŸç†

**æ ¸å¿ƒæ¶æ„æ¼”ç¤º**ï¼š

```java
/**
 * ThreadLocalå·¥ä½œåŸç†æ¼”ç¤º
 */
public class ThreadLocalDemo {
    // æ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹çš„SimpleDateFormat
    private static final ThreadLocal<SimpleDateFormat> dateFormat = 
        ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
    
    // æ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹çš„ç”¨æˆ·ä¸Šä¸‹æ–‡
    private static final ThreadLocal<UserContext> userContext = new ThreadLocal<>();
    
    public static String formatCurrentTime() {
        // æ¯ä¸ªçº¿ç¨‹è·å–è‡ªå·±çš„SimpleDateFormatå®ä¾‹
        return dateFormat.get().format(new Date());
    }
    
    public static void setUser(String username) {
        // è®¾ç½®å½“å‰çº¿ç¨‹çš„ç”¨æˆ·ä¸Šä¸‹æ–‡
        userContext.set(new UserContext(username));
    }
    
    public static UserContext getCurrentUser() {
        // è·å–å½“å‰çº¿ç¨‹çš„ç”¨æˆ·ä¸Šä¸‹æ–‡
        return userContext.get();
    }
    
    public static void clearContext() {
        // æ¸…ç†å½“å‰çº¿ç¨‹çš„æ•°æ®ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
        userContext.remove();
    }
    
    static class UserContext {
        private final String username;
        private final long loginTime;
        
        public UserContext(String username) {
            this.username = username;
            this.loginTime = System.currentTimeMillis();
        }
        
        public String getUsername() { return username; }
        public long getLoginTime() { return loginTime; }
    }
}
```

### ThreadLocalMapè¯¦è§£

**ThreadLocalMapæ˜¯ThreadLocalçš„æ ¸å¿ƒå®ç°**ï¼š

```java
/**
 * ThreadLocalMapç»“æ„åˆ†æ
 */
public class ThreadLocalMapAnalysis {
    
    // ThreadLocalMapçš„æ ¸å¿ƒç»“æ„
    static class Entry extends WeakReference<ThreadLocal<?>> {
        Object value;  // å­˜å‚¨çš„å€¼
        
        Entry(ThreadLocal<?> k, Object v) {
            super(k);  // keyæ˜¯ThreadLocalçš„å¼±å¼•ç”¨
            value = v; // valueæ˜¯å¼ºå¼•ç”¨
        }
    }
    
    // ThreadLocalMapçš„å…³é”®ç‰¹æ€§
    public void explainStructure() {
        /*
         * 1. æ•°æ®ç»“æ„ï¼š
         *    - åŸºäºå¼€æ”¾åœ°å€æ³•çš„å“ˆå¸Œè¡¨
         *    - Entryæ•°ç»„å­˜å‚¨é”®å€¼å¯¹
         *    - çº¿æ€§æ¢æµ‹è§£å†³å“ˆå¸Œå†²çª
         * 
         * 2. å†…å­˜ç®¡ç†ï¼š
         *    - key (ThreadLocal) ä½¿ç”¨å¼±å¼•ç”¨
         *    - value ä½¿ç”¨å¼ºå¼•ç”¨
         *    - æ”¯æŒè‡ªåŠ¨æ¸…ç†è¿‡æœŸEntry
         * 
         * 3. è®¿é—®ç‰¹æ€§ï¼š
         *    - æ¯ä¸ªThreadæŒæœ‰ä¸€ä¸ªThreadLocalMap
         *    - é€šè¿‡ThreadLocalä½œä¸ºkeyè®¿é—®value
         *    - çº¿ç¨‹ç»“æŸæ—¶MapéšThreadä¸€èµ·å›æ”¶
         */
    }
    
    // å“ˆå¸Œç®—æ³•åˆ†æ
    public void analyzeHashAlgorithm() {
        /*
         * ThreadLocalMapä½¿ç”¨ç‰¹æ®Šçš„å“ˆå¸Œç®—æ³•ï¼š
         * 
         * 1. é­”æ•°ï¼š0x61c88647 (é»„é‡‘åˆ†å‰²æ•°çš„å€æ•°)
         * 2. ç›®çš„ï¼šåœ¨2çš„å¹‚æ¬¡æ–¹é•¿åº¦çš„æ•°ç»„ä¸­äº§ç”Ÿå‡åŒ€åˆ†å¸ƒ
         * 3. è®¡ç®—ï¼šthreadLocalHashCode & (len - 1)
         * 4. å†²çªè§£å†³ï¼šçº¿æ€§æ¢æµ‹æ³•
         */
        
        int HASH_INCREMENT = 0x61c88647;
        int nextHashCode = 0;
        
        // ç”ŸæˆThreadLocalçš„å“ˆå¸Œç 
        for (int i = 0; i < 5; i++) {
            int hash = nextHashCode;
            nextHashCode += HASH_INCREMENT;
            
            // è®¡ç®—åœ¨é•¿åº¦ä¸º16çš„æ•°ç»„ä¸­çš„ç´¢å¼•
            int index = hash & (16 - 1);
            System.out.println("ThreadLocal " + i + " -> Hash: " + hash + ", Index: " + index);
        }
    }
}

## ğŸ”§ å®ç°åŸç†ä¸æºç åˆ†æ

### å¼±å¼•ç”¨æœºåˆ¶è¯¦è§£

**ThreadLocalMapä½¿ç”¨å¼±å¼•ç”¨çš„å…³é”®åŸå› **ï¼š

```java
/**
 * å¼±å¼•ç”¨æœºåˆ¶åˆ†æ
 */
public class WeakReferenceAnalysis {
    
    public void explainWeakReference() {
        /*
         * ThreadLocalMap.Entryçš„è®¾è®¡ï¼š
         * 
         * static class Entry extends WeakReference<ThreadLocal<?>> {
         *     Object value;
         *     
         *     Entry(ThreadLocal<?> k, Object v) {
         *         super(k);    // keyæ˜¯ThreadLocalçš„å¼±å¼•ç”¨
         *         value = v;   // valueæ˜¯å¼ºå¼•ç”¨
         *     }
         * }
         * 
         * å¼±å¼•ç”¨çš„ä½œç”¨ï¼š
         * 1. å½“ThreadLocalå˜é‡è¢«ç½®ä¸ºnullæ—¶
         * 2. å¦‚æœåªæœ‰ThreadLocalMapæŒæœ‰ThreadLocalçš„å¼•ç”¨
         * 3. GCæ—¶å¯ä»¥å›æ”¶ThreadLocalå¯¹è±¡
         * 4. Entryçš„keyå˜ä¸ºnullï¼Œæ ‡è®°ä¸ºè¿‡æœŸEntry
         */
    }
    
    // æ¼”ç¤ºå†…å­˜æ³„æ¼åœºæ™¯
    public void demonstrateMemoryLeak() {
        ThreadLocal<byte[]> threadLocal = new ThreadLocal<>();
        
        // è®¾ç½®å¤§å¯¹è±¡
        threadLocal.set(new byte[1024 * 1024]); // 1MBæ•°æ®
        
        // å°†ThreadLocalå¼•ç”¨ç½®ä¸ºnull
        threadLocal = null;
        
        /*
         * æ­¤æ—¶çš„å†…å­˜çŠ¶æ€ï¼š
         * 1. ThreadLocalå¯¹è±¡å¯ä»¥è¢«GCå›æ”¶ï¼ˆå¼±å¼•ç”¨ï¼‰
         * 2. ä½†æ˜¯value (byte[]æ•°ç»„) ä»ç„¶è¢«Entryå¼ºå¼•ç”¨
         * 3. å¦‚æœä¸è°ƒç”¨remove()ï¼Œå†…å­˜æ³„æ¼å‘ç”Ÿ
         * 4. åªæœ‰å½“Threadç»“æŸæ—¶ï¼Œæ•´ä¸ªThreadLocalMapæ‰ä¼šè¢«å›æ”¶
         */
        
        // æ­£ç¡®çš„åšæ³•ï¼šæ‰‹åŠ¨æ¸…ç†
        // threadLocal.remove(); // åº”è¯¥åœ¨threadLocal = nullä¹‹å‰è°ƒç”¨
    }
}
```

### å†…å­˜æ³„æ¼æˆå› åˆ†æ

**å†…å­˜æ³„æ¼çš„å®Œæ•´é“¾è·¯**ï¼š

```java
/**
 * å†…å­˜æ³„æ¼æˆå› æ·±åº¦åˆ†æ
 */
public class MemoryLeakAnalysis {
    
    // åœºæ™¯1ï¼šWebåº”ç”¨ä¸­çš„å…¸å‹å†…å­˜æ³„æ¼
    public void webApplicationLeakScenario() {
        /*
         * æ³„æ¼åœºæ™¯ï¼š
         * 1. Tomcatç­‰Webå®¹å™¨ä½¿ç”¨çº¿ç¨‹æ± å¤„ç†è¯·æ±‚
         * 2. çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹é•¿æœŸå­˜æ´»
         * 3. åœ¨è¯·æ±‚å¤„ç†ä¸­ä½¿ç”¨ThreadLocalå­˜å‚¨æ•°æ®
         * 4. è¯·æ±‚ç»“æŸåæ²¡æœ‰æ¸…ç†ThreadLocal
         * 5. çº¿ç¨‹è¢«å¤ç”¨å¤„ç†ä¸‹ä¸€ä¸ªè¯·æ±‚
         * 6. ThreadLocalæ•°æ®ç´¯ç§¯ï¼Œé€ æˆå†…å­˜æ³„æ¼
         */
        
        // æ¨¡æ‹Ÿæ³„æ¼ä»£ç 
        ThreadLocal<UserSession> sessionLocal = new ThreadLocal<>();
        
        // è¯·æ±‚å¼€å§‹
        sessionLocal.set(new UserSession("user123", new Date()));
        
        // å¤„ç†è¯·æ±‚...
        
        // è¯·æ±‚ç»“æŸ - å¿˜è®°æ¸…ç†ï¼
        // sessionLocal.remove(); // è¿™è¡Œè¢«é—å¿˜äº†
    }
    
    // åœºæ™¯2ï¼šç¬¬ä¸‰æ–¹åº“çš„ThreadLocalä½¿ç”¨
    public void thirdPartyLibraryLeak() {
        /*
         * å¸¸è§æ³„æ¼æºï¼š
         * 1. æ•°æ®åº“è¿æ¥æ± ï¼ˆå¦‚HikariCPï¼‰
         * 2. æ—¥å¿—æ¡†æ¶ï¼ˆå¦‚MDCï¼‰
         * 3. å®‰å…¨æ¡†æ¶ï¼ˆå¦‚Spring Securityï¼‰
         * 4. ç›‘æ§å·¥å…·ï¼ˆå¦‚APM agentï¼‰
         * 
         * é—®é¢˜ï¼š
         * - ç¬¬ä¸‰æ–¹åº“å¯èƒ½æ²¡æœ‰æ­£ç¡®æ¸…ç†ThreadLocal
         * - åº”ç”¨ä»£ç æ— æ³•ç›´æ¥æ§åˆ¶æ¸…ç†æ—¶æœº
         * - éœ€è¦åœ¨é€‚å½“ä½ç½®æ‰‹åŠ¨æ¸…ç†
         */
    }
    
    static class UserSession {
        private final String userId;
        private final Date loginTime;
        
        public UserSession(String userId, Date loginTime) {
            this.userId = userId;
            this.loginTime = loginTime;
        }
        
        // getters...
    }
}
```

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹ä¸ä»£ç ç¤ºä¾‹

### å…·ä½“é¡¹ç›®åº”ç”¨

**åœºæ™¯1ï¼šWebåº”ç”¨ç”¨æˆ·ä¸Šä¸‹æ–‡ç®¡ç†**

```java
/**
 * Webåº”ç”¨ç”¨æˆ·ä¸Šä¸‹æ–‡ç®¡ç†
 */
@Component
public class UserContextHolder {
    
    private static final ThreadLocal<UserContext> contextHolder = new ThreadLocal<>();
    
    /**
     * è®¾ç½®ç”¨æˆ·ä¸Šä¸‹æ–‡
     */
    public static void setContext(UserContext context) {
        contextHolder.set(context);
    }
    
    /**
     * è·å–ç”¨æˆ·ä¸Šä¸‹æ–‡
     */
    public static UserContext getContext() {
        return contextHolder.get();
    }
    
    /**
     * æ¸…ç†ç”¨æˆ·ä¸Šä¸‹æ–‡ï¼ˆé‡è¦ï¼ï¼‰
     */
    public static void clearContext() {
        contextHolder.remove();
    }
    
    /**
     * ç”¨æˆ·ä¸Šä¸‹æ–‡ä¿¡æ¯
     */
    public static class UserContext {
        private final String userId;
        private final String username;
        private final Set<String> roles;
        private final String requestId;
        private final long requestTime;
        
        public UserContext(String userId, String username, Set<String> roles, String requestId) {
            this.userId = userId;
            this.username = username;
            this.roles = Collections.unmodifiableSet(new HashSet<>(roles));
            this.requestId = requestId;
            this.requestTime = System.currentTimeMillis();
        }
        
        // getters...
        public String getUserId() { return userId; }
        public String getUsername() { return username; }
        public Set<String> getRoles() { return roles; }
        public String getRequestId() { return requestId; }
        public long getRequestTime() { return requestTime; }
        
        public boolean hasRole(String role) {
            return roles.contains(role);
        }
    }
}

/**
 * Webè¿‡æ»¤å™¨ - è‡ªåŠ¨ç®¡ç†ç”¨æˆ·ä¸Šä¸‹æ–‡
 */
@Component
public class UserContextFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        
        try {
            // ä»è¯·æ±‚ä¸­æå–ç”¨æˆ·ä¿¡æ¯
            String token = httpRequest.getHeader("Authorization");
            if (token != null) {
                UserContext context = parseUserFromToken(token);
                UserContextHolder.setContext(context);
            }
            
            // ç»§ç»­å¤„ç†è¯·æ±‚
            chain.doFilter(request, response);
            
        } finally {
            // é‡è¦ï¼šè¯·æ±‚ç»“æŸåæ¸…ç†ThreadLocal
            UserContextHolder.clearContext();
        }
    }
    
    private UserContext parseUserFromToken(String token) {
        // è§£æJWT tokenæˆ–æŸ¥è¯¢æ•°æ®åº“
        // è¿™é‡Œç®€åŒ–å¤„ç†
        return new UserContext(
            "user123", 
            "å¼ ä¸‰", 
            Set.of("USER", "ADMIN"),
            UUID.randomUUID().toString()
        );
    }
}
```

**åœºæ™¯2ï¼šæ•°æ®åº“è¿æ¥ç®¡ç†**

```java
/**
 * æ•°æ®åº“è¿æ¥ç®¡ç†ï¼ˆç®€åŒ–ç‰ˆï¼‰
 */
public class DatabaseConnectionManager {
    
    private static final ThreadLocal<Connection> connectionHolder = new ThreadLocal<>();
    private static final DataSource dataSource = createDataSource();
    
    /**
     * è·å–å½“å‰çº¿ç¨‹çš„æ•°æ®åº“è¿æ¥
     */
    public static Connection getCurrentConnection() throws SQLException {
        Connection connection = connectionHolder.get();
        
        if (connection == null || connection.isClosed()) {
            connection = dataSource.getConnection();
            connectionHolder.set(connection);
        }
        
        return connection;
    }
    
    /**
     * å¼€å§‹äº‹åŠ¡
     */
    public static void beginTransaction() throws SQLException {
        Connection connection = getCurrentConnection();
        connection.setAutoCommit(false);
    }
    
    /**
     * æäº¤äº‹åŠ¡
     */
    public static void commitTransaction() throws SQLException {
        Connection connection = connectionHolder.get();
        if (connection != null) {
            connection.commit();
        }
    }
    
    /**
     * å›æ»šäº‹åŠ¡
     */
    public static void rollbackTransaction() throws SQLException {
        Connection connection = connectionHolder.get();
        if (connection != null) {
            connection.rollback();
        }
    }
    
    /**
     * å…³é—­è¿æ¥å¹¶æ¸…ç†ThreadLocal
     */
    public static void closeConnection() throws SQLException {
        Connection connection = connectionHolder.get();
        if (connection != null) {
            connection.close();
            connectionHolder.remove(); // é‡è¦ï¼šæ¸…ç†ThreadLocal
        }
    }
    
    private static DataSource createDataSource() {
        // åˆ›å»ºæ•°æ®æºçš„é€»è¾‘
        return null; // ç®€åŒ–ç¤ºä¾‹
    }
}

/**
 * äº‹åŠ¡ç®¡ç†å™¨
 */
@Component
public class TransactionManager {
    
    /**
     * æ‰§è¡Œäº‹åŠ¡æ€§æ“ä½œ
     */
    public <T> T executeInTransaction(Supplier<T> operation) throws SQLException {
        try {
            DatabaseConnectionManager.beginTransaction();
            
            T result = operation.get();
            
            DatabaseConnectionManager.commitTransaction();
            return result;
            
        } catch (Exception e) {
            DatabaseConnectionManager.rollbackTransaction();
            throw e;
        } finally {
            // ç¡®ä¿è¿æ¥è¢«å…³é—­å’Œæ¸…ç†
            DatabaseConnectionManager.closeConnection();
        }
    }
}

## ğŸ¯ é¢è¯•é«˜é¢‘é—®é¢˜ç²¾è®²

### æ ¸å¿ƒé¢è¯•é—®é¢˜è§£æ

#### 1. ThreadLocalçš„å®ç°åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
ThreadLocalé€šè¿‡åœ¨æ¯ä¸ªThreadå¯¹è±¡å†…éƒ¨ç»´æŠ¤ä¸€ä¸ªThreadLocalMapæ¥å®ç°çº¿ç¨‹éš”ç¦»ï¼š

- **æ•°æ®ç»“æ„**ï¼šThreadLocalMapæ˜¯åŸºäºå¼€æ”¾åœ°å€æ³•çš„å“ˆå¸Œè¡¨
- **å­˜å‚¨æ–¹å¼**ï¼šä»¥ThreadLocalå¯¹è±¡ä¸ºkeyï¼Œå­˜å‚¨çš„å€¼ä¸ºvalue
- **è®¿é—®æœºåˆ¶**ï¼šæ¯ä¸ªçº¿ç¨‹åªèƒ½è®¿é—®è‡ªå·±çš„ThreadLocalMap
- **å†…å­˜ç®¡ç†**ï¼škeyä½¿ç”¨å¼±å¼•ç”¨ï¼Œvalueä½¿ç”¨å¼ºå¼•ç”¨

#### 2. ThreadLocalä¸ºä»€ä¹ˆä¼šå¯¼è‡´å†…å­˜æ³„æ¼ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
ThreadLocalå†…å­˜æ³„æ¼çš„æ ¹æœ¬åŸå› æ˜¯**å¼±å¼•ç”¨key + å¼ºå¼•ç”¨value**çš„è®¾è®¡ï¼š

```java
// å†…å­˜æ³„æ¼åœºæ™¯
ThreadLocal<BigObject> threadLocal = new ThreadLocal<>();
threadLocal.set(new BigObject()); // è®¾ç½®å¤§å¯¹è±¡
threadLocal = null; // ThreadLocalå¼•ç”¨ç½®ç©º

// æ³„æ¼åˆ†æï¼š
// 1. ThreadLocalå¯¹è±¡è¢«GCå›æ”¶ï¼ˆå¼±å¼•ç”¨ï¼‰
// 2. ThreadLocalMapä¸­Entryçš„keyå˜ä¸ºnull
// 3. ä½†value (BigObject) ä»è¢«å¼ºå¼•ç”¨ï¼Œæ— æ³•å›æ”¶
// 4. å¦‚æœçº¿ç¨‹é•¿æœŸå­˜æ´»ï¼Œå†…å­˜æ³„æ¼æŒç»­
```

**é˜²èŒƒæªæ–½**ï¼š
- ä½¿ç”¨å®Œæ¯•åè°ƒç”¨`remove()`æ–¹æ³•
- ä½¿ç”¨try-finallyç¡®ä¿æ¸…ç†
- é¿å…åœ¨é•¿æœŸå­˜æ´»çš„çº¿ç¨‹ä¸­ä½¿ç”¨

#### 3. ThreadLocalçš„åº”ç”¨åœºæ™¯æœ‰å“ªäº›ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
ThreadLocalé€‚ç”¨äºä»¥ä¸‹åœºæ™¯ï¼š

**1. çº¿ç¨‹ä¸Šä¸‹æ–‡ä¼ é€’**
```java
// ç”¨æˆ·ä¸Šä¸‹æ–‡ã€è¯·æ±‚IDç­‰
private static final ThreadLocal<UserContext> userContext = new ThreadLocal<>();
```

**2. é¿å…å‚æ•°ä¼ é€’**
```java
// æ•°æ®åº“è¿æ¥ã€äº‹åŠ¡çŠ¶æ€ç­‰
private static final ThreadLocal<Connection> connectionLocal = new ThreadLocal<>();
```

**3. çº¿ç¨‹å®‰å…¨çš„å·¥å…·ç±»**
```java
// SimpleDateFormatã€Randomç­‰éçº¿ç¨‹å®‰å…¨ç±»
private static final ThreadLocal<SimpleDateFormat> dateFormat = 
    ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
```

**4. æ€§èƒ½ä¼˜åŒ–**
```java
// ç¼“å†²åŒºã€StringBuilderç­‰å¯å¤ç”¨å¯¹è±¡
private static final ThreadLocal<StringBuilder> bufferLocal = 
    ThreadLocal.withInitial(() -> new StringBuilder(1024));
```

#### 4. ThreadLocalä¸synchronizedçš„åŒºåˆ«ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š

| ç‰¹æ€§ | ThreadLocal | synchronized |
|------|------------|-------------|
| å®ç°æ–¹å¼ | æ•°æ®å‰¯æœ¬ | é”æœºåˆ¶ |
| æ€§èƒ½ | é«˜ï¼ˆæ— é”ï¼‰ | ä¸­ï¼ˆæœ‰é”ç«äº‰ï¼‰ |
| å†…å­˜å ç”¨ | é«˜ï¼ˆæ¯çº¿ç¨‹ä¸€ä»½ï¼‰ | ä½ï¼ˆå…±äº«æ•°æ®ï¼‰ |
| æ•°æ®ä¸€è‡´æ€§ | ä¸ä¿è¯ | ä¿è¯ |
| é€‚ç”¨åœºæ™¯ | çº¿ç¨‹éš”ç¦» | æ•°æ®åŒæ­¥ |

#### 5. å¦‚ä½•æ­£ç¡®ä½¿ç”¨ThreadLocalï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
æ­£ç¡®ä½¿ç”¨ThreadLocalçš„æœ€ä½³å®è·µï¼š

```java
public class ThreadLocalBestPractice {
    private static final ThreadLocal<UserSession> sessionLocal = new ThreadLocal<>();
    
    public void processRequest() {
        try {
            // 1. è®¾ç½®æ•°æ®
            sessionLocal.set(new UserSession());
            
            // 2. ä¸šåŠ¡å¤„ç†
            doBusinessLogic();
            
        } finally {
            // 3. å¿…é¡»æ¸…ç†ï¼ˆå…³é”®ï¼ï¼‰
            sessionLocal.remove();
        }
    }
    
    // æˆ–è€…ä½¿ç”¨å·¥å…·æ–¹æ³•
    public <T> T withThreadLocal(ThreadLocal<T> threadLocal, T value, Supplier<T> operation) {
        try {
            threadLocal.set(value);
            return operation.get();
        } finally {
            threadLocal.remove();
        }
    }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹

### å†…å­˜æ³„æ¼é˜²èŒƒç­–ç•¥

**1. å®Œæ•´çš„é˜²èŒƒchecklist**ï¼š

```java
/**
 * ThreadLocalå†…å­˜æ³„æ¼é˜²èŒƒç­–ç•¥
 */
public class MemoryLeakPrevention {
    
    // âœ… æ­£ç¡®çš„ThreadLocalä½¿ç”¨æ¨¡å¼
    private static final ThreadLocal<UserContext> contextLocal = new ThreadLocal<>();
    
    /**
     * æ ‡å‡†çš„ä½¿ç”¨æ¨¡å¼
     */
    public void standardPattern() {
        try {
            // è®¾ç½®æ•°æ®
            contextLocal.set(new UserContext("user123"));
            
            // ä¸šåŠ¡é€»è¾‘
            doBusinessLogic();
            
        } finally {
            // å¿…é¡»æ¸…ç†
            contextLocal.remove();
        }
    }
    
    /**
     * Webåº”ç”¨çš„Filteræ¨¡å¼
     */
    @Component
    public static class ThreadLocalCleanupFilter implements Filter {
        
        @Override
        public void doFilter(ServletRequest request, ServletResponse response, 
                           FilterChain chain) throws IOException, ServletException {
            try {
                chain.doFilter(request, response);
            } finally {
                // æ¸…ç†æ‰€æœ‰å¯èƒ½çš„ThreadLocal
                clearAllThreadLocals();
            }
        }
        
        private void clearAllThreadLocals() {
            // æ¸…ç†åº”ç”¨çº§åˆ«çš„ThreadLocal
            UserContextHolder.clearContext();
            
            // æ¸…ç†ç¬¬ä¸‰æ–¹åº“çš„ThreadLocalï¼ˆå¦‚æœå¯èƒ½ï¼‰
            clearThirdPartyThreadLocals();
        }
        
        private void clearThirdPartyThreadLocals() {
            // æ¸…ç†MDC
            org.slf4j.MDC.clear();
            
            // æ¸…ç†Spring Security Context
            // SecurityContextHolder.clearContext();
        }
    }
}
```

### å¸¸è§å‘ç‚¹è§„é¿

**1. çº¿ç¨‹æ± ç¯å¢ƒä¸‹çš„æ³¨æ„äº‹é¡¹**ï¼š
```java
/**
 * çº¿ç¨‹æ± ç¯å¢ƒä¸‹çš„ThreadLocalä½¿ç”¨
 */
public class ThreadPoolThreadLocalUsage {
    
    private static final ThreadLocal<UserSession> sessionLocal = new ThreadLocal<>();
    
    // âŒ é”™è¯¯ï¼šæ²¡æœ‰æ¸…ç†ThreadLocal
    public void badExample() {
        sessionLocal.set(new UserSession("user123"));
        // å¤„ç†ä¸šåŠ¡é€»è¾‘
        // çº¿ç¨‹è¿”å›çº¿ç¨‹æ± ï¼ŒThreadLocalæ•°æ®æ®‹ç•™
    }
    
    // âœ… æ­£ç¡®ï¼šç¡®ä¿æ¸…ç†
    public void goodExample() {
        try {
            sessionLocal.set(new UserSession("user123"));
            // å¤„ç†ä¸šåŠ¡é€»è¾‘
        } finally {
            sessionLocal.remove(); // æ¸…ç†æ•°æ®
        }
    }
}
```

## ğŸ“š æ€»ç»“ä¸æŠ€æœ¯å¯¹æ¯”

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **ThreadLocalæä¾›çº¿ç¨‹çº§åˆ«çš„æ•°æ®éš”ç¦»**ï¼Œæ¯ä¸ªçº¿ç¨‹æ‹¥æœ‰ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬
2. **åŸºäºThreadLocalMapå®ç°**ï¼Œä½¿ç”¨å¼±å¼•ç”¨keyå’Œå¼ºå¼•ç”¨value
3. **å†…å­˜æ³„æ¼é£é™©**ï¼šé•¿æœŸå­˜æ´»çš„çº¿ç¨‹+å¿˜è®°è°ƒç”¨remove()
4. **é€‚ç”¨åœºæ™¯**ï¼šç”¨æˆ·ä¸Šä¸‹æ–‡ã€æ•°æ®åº“è¿æ¥ã€çº¿ç¨‹å®‰å…¨å·¥å…·ç±»
5. **é˜²èŒƒç­–ç•¥**ï¼štry-finallyæ¨¡å¼ã€è‡ªåŠ¨æ¸…ç†Filterã€å·¥å…·ç±»å°è£…

### ä¸ç›¸å…³æŠ€æœ¯å¯¹æ¯”

| ç‰¹æ€§ | ThreadLocal | synchronized | volatile | AtomicXXX |
|------|------------|-------------|----------|-----------|
| æ•°æ®éš”ç¦» | âœ… å®Œå…¨éš”ç¦» | âŒ å…±äº«æ•°æ® | âŒ å…±äº«æ•°æ® | âŒ å…±äº«æ•°æ® |
| æ€§èƒ½ | é«˜ï¼ˆæ— é”ï¼‰ | ä¸­ï¼ˆé”ç«äº‰ï¼‰ | é«˜ï¼ˆæ— é”ï¼‰ | é«˜ï¼ˆCASï¼‰ |
| å†…å­˜å ç”¨ | é«˜ï¼ˆå‰¯æœ¬ï¼‰ | ä½ï¼ˆå…±äº«ï¼‰ | ä½ï¼ˆå…±äº«ï¼‰ | ä½ï¼ˆå…±äº«ï¼‰ |
| é€‚ç”¨åœºæ™¯ | çº¿ç¨‹éš”ç¦» | äº’æ–¥è®¿é—® | çŠ¶æ€æ ‡å¿— | è®¡æ•°å™¨ |
| å†…å­˜æ³„æ¼é£é™© | é«˜ | æ—  | æ—  | æ—  |

### é€‰æ‹©æŒ‡å—

**ä½¿ç”¨ThreadLocalçš„æ¡ä»¶**ï¼š
1. éœ€è¦çº¿ç¨‹çº§åˆ«çš„æ•°æ®éš”ç¦»
2. é¿å…å‚æ•°å±‚å±‚ä¼ é€’
3. çº¿ç¨‹å®‰å…¨ä½†æ€§èƒ½è¦æ±‚é«˜
4. æ•°æ®ç”Ÿå‘½å‘¨æœŸä¸çº¿ç¨‹ç»‘å®š

**ä¸é€‚ç”¨ThreadLocalçš„åœºæ™¯**ï¼š
- éœ€è¦çº¿ç¨‹é—´æ•°æ®å…±äº«
- çŸ­æœŸä»»åŠ¡ï¼ˆåˆ›å»ºå¼€é”€å¤§ï¼‰
- å†…å­˜æ•æ„Ÿçš„åº”ç”¨
- æ•°æ®éœ€è¦æŒä¹…åŒ–

### æŒç»­å­¦ä¹ å»ºè®®

1. **æ·±å…¥ç†è§£å†…å­˜æ¨¡å‹**ï¼šå­¦ä¹ Javaå†…å­˜ç®¡ç†å’ŒGCæœºåˆ¶
2. **å®è·µå†…å­˜åˆ†æ**ï¼šä½¿ç”¨MATã€JProfilerç­‰å·¥å…·åˆ†æå†…å­˜æ³„æ¼
3. **å…³æ³¨æ¡†æ¶å®ç°**ï¼šç ”ç©¶Springã€Hibernateç­‰æ¡†æ¶çš„ThreadLocalä½¿ç”¨
4. **ç›‘æ§å†…å­˜ä½¿ç”¨**ï¼šåœ¨ç”Ÿäº§ç¯å¢ƒä¸­ç›‘æ§ThreadLocalç›¸å…³çš„å†…å­˜æŒ‡æ ‡
5. **è·Ÿè¸ªæ–°ç‰¹æ€§**ï¼šå…³æ³¨Virtual Threadç­‰æ–°å¹¶å‘ç‰¹æ€§å¯¹ThreadLocalçš„å½±å“

---

**ä¸‹ä¸€ç¯‡é¢„å‘Š**ï¼šã€Šçº¿ç¨‹æ± åŸç†ä¸æœ€ä½³å®è·µã€‹å°†æ·±å…¥æ¢è®¨Javaçº¿ç¨‹æ± çš„æ ¸å¿ƒæœºåˆ¶ã€å‚æ•°è°ƒä¼˜å’Œåœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹çš„åº”ç”¨å®è·µã€‚