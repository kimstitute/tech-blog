---
title: "ConcurrentHashMapå¹¶å‘æœºåˆ¶æ·±åº¦è§£æ"
description: "æ·±å…¥è§£æConcurrentHashMapçš„å¹¶å‘æ§åˆ¶æœºåˆ¶ã€åˆ†æ®µé”è®¾è®¡å’ŒCASä¼˜åŒ–ç­–ç•¥ã€‚ç»“åˆå®é™…é¡¹ç›®åœºæ™¯åˆ†æé«˜å¹¶å‘ä¸‹çš„æ€§èƒ½è¡¨ç°ã€çº¿ç¨‹å®‰å…¨ä¿éšœå’Œæœ€ä½³å®è·µï¼ŒæŒæ¡Javaå¹¶å‘ç¼–ç¨‹çš„æ ¸å¿ƒæŠ€æœ¯ã€‚"
pubDate: 2024-12-07
updatedDate: 2024-12-07
tags: ["java", "concurrenthashmap", "concurrent", "cas", "segment-lock", "thread-safe", "performance", "interview", "best-practices"]
categories: ["java-core"]
subject: "é›†åˆæ¡†æ¶"
draft: false
featured: true
author: "Gerrad Zhang"
location: "æ­¦æ±‰ï¼Œä¸­å›½"
---

## ğŸ¤” é—®é¢˜èƒŒæ™¯ä¸æŠ€æœ¯æ¼”è¿›

### æˆ‘ä»¬è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

åœ¨é«˜å¹¶å‘çš„å¤šçº¿ç¨‹ç¯å¢ƒä¸­ï¼Œ**çº¿ç¨‹å®‰å…¨çš„é”®å€¼å­˜å‚¨**æ˜¯ä¸€ä¸ªå…³é”®éœ€æ±‚ã€‚ä¼ ç»Ÿçš„è§£å†³æ–¹æ¡ˆåœ¨æ€§èƒ½å’Œå®‰å…¨æ€§ä¹‹é—´å­˜åœ¨æ˜æ˜¾çš„æƒè¡¡é—®é¢˜ï¼š

- **HashMapçº¿ç¨‹ä¸å®‰å…¨**ï¼šå¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¯èƒ½å¯¼è‡´æ•°æ®ä¸¢å¤±ã€æ­»å¾ªç¯ã€æ•°æ®ä¸ä¸€è‡´ç­‰ä¸¥é‡é—®é¢˜
- **Hashtableæ€§èƒ½ä½ä¸‹**ï¼šæ‰€æœ‰æ–¹æ³•éƒ½ä½¿ç”¨synchronizedï¼Œå¹¶å‘æ€§èƒ½æå·®
- **Collections.synchronizedMapå±€é™æ€§**ï¼šè™½ç„¶çº¿ç¨‹å®‰å…¨ï¼Œä½†ä»ç„¶æ˜¯ç²—ç²’åº¦é”ï¼Œæ€§èƒ½ç“¶é¢ˆæ˜æ˜¾
- **æ‰‹å·¥å®ç°å¤æ‚**ï¼šè‡ªå·±å®ç°çº¿ç¨‹å®‰å…¨çš„å“ˆå¸Œè¡¨éœ€è¦å¤„ç†å¤æ‚çš„å¹¶å‘æ§åˆ¶é€»è¾‘

```java
// ä¼ ç»Ÿçº¿ç¨‹å®‰å…¨Mapçš„æ€§èƒ½é—®é¢˜æ¼”ç¤º
public class TraditionalThreadSafeMapProblems {
    
    /**
     * é—®é¢˜1ï¼šHashMapåœ¨å¹¶å‘ç¯å¢ƒä¸‹çš„å±é™©æ€§
     */
    public void demonstrateHashMapConcurrencyIssues() {
        Map<String, String> unsafeMap = new HashMap<>();
        
        // å¤šçº¿ç¨‹åŒæ—¶æ“ä½œHashMapå¯èƒ½å¯¼è‡´ï¼š
        // 1. æ•°æ®ä¸¢å¤±ï¼šä¸¤ä¸ªçº¿ç¨‹åŒæ—¶putï¼Œåè€…è¦†ç›–å‰è€…
        // 2. æ­»å¾ªç¯ï¼šJDK 1.7æ‰©å®¹æ—¶å¯èƒ½å½¢æˆç¯å½¢é“¾è¡¨
        // 3. æ•°æ®ä¸ä¸€è‡´ï¼šè¯»å†™æ“ä½œäº¤é”™æ‰§è¡Œ
        
        ExecutorService executor = Executors.newFixedThreadPool(10);
        
        // âŒ å±é™©æ“ä½œï¼šå¤šçº¿ç¨‹å¹¶å‘ä¿®æ”¹HashMap
        for (int i = 0; i < 1000; i++) {
            final int index = i;
            executor.submit(() -> {
                unsafeMap.put("key" + index, "value" + index);
                // å¯èƒ½å¯¼è‡´æ•°æ®ä¸¢å¤±æˆ–ç¨‹åºå´©æºƒ
            });
        }
    }
    
    /**
     * é—®é¢˜2ï¼šHashtableçš„æ€§èƒ½ç“¶é¢ˆ
     */
    public void demonstrateHashtablePerformanceIssues() {
        // Hashtableä½¿ç”¨synchronizedæ–¹æ³•ï¼Œæ€§èƒ½å·®
        Map<String, String> hashtable = new Hashtable<>();
        
        // æ‰€æœ‰æ“ä½œéƒ½éœ€è¦è·å–å¯¹è±¡é”ï¼Œå¹¶å‘åº¦ä¸º1
        ExecutorService executor = Executors.newFixedThreadPool(10);
        
        for (int i = 0; i < 10000; i++) {
            final int index = i;
            executor.submit(() -> {
                hashtable.put("key" + index, "value" + index); // synchronized
                hashtable.get("key" + index); // synchronized
            });
        }
        // æ€§èƒ½è¿œä½äºConcurrentHashMap
    }
}
```

### æ²¡æœ‰è¿™ä¸ªæŠ€æœ¯æ—¶æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ

åœ¨ConcurrentHashMapå‡ºç°ä¹‹å‰ï¼ŒJavaå¼€å‘è€…ä¸»è¦é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°çº¿ç¨‹å®‰å…¨çš„é”®å€¼æ˜ å°„ï¼š

**1. ä½¿ç”¨Hashtable**
- Java 1.0å°±å­˜åœ¨çš„çº¿ç¨‹å®‰å…¨å®ç°
- **é—®é¢˜**ï¼šæ‰€æœ‰æ–¹æ³•éƒ½æ˜¯synchronizedï¼Œå¹¶å‘æ€§èƒ½æå·®

**2. ä½¿ç”¨Collections.synchronizedMap**
- å¯¹ç°æœ‰Mapè¿›è¡ŒåŒ…è£…ï¼Œæ·»åŠ åŒæ­¥æ§åˆ¶
- **é—®é¢˜**ï¼šä»ç„¶æ˜¯ç²—ç²’åº¦é”ï¼Œå¤åˆæ“ä½œéœ€è¦é¢å¤–åŒæ­¥

**3. æ‰‹åŠ¨åŠ é”æ§åˆ¶**
- åœ¨ä¸šåŠ¡ä»£ç ä¸­æ‰‹åŠ¨æ·»åŠ synchronizedæˆ–ReentrantLock
- **é—®é¢˜**ï¼šå®¹æ˜“é—æ¼ï¼Œæ­»é”é£é™©é«˜ï¼Œä»£ç å¤æ‚åº¦å¢åŠ 

### æŠ€æœ¯æ¼”è¿›çš„å†å²è„‰ç»œ

**JDK 1.5 (2004)**ï¼šConcurrentHashMapé¦–æ¬¡å¼•å…¥
- åŸºäºåˆ†æ®µé”ï¼ˆSegmentï¼‰çš„è®¾è®¡
- å°†æ•´ä¸ªMapåˆ†ä¸ºå¤šä¸ªæ®µï¼Œæ¯ä¸ªæ®µç‹¬ç«‹åŠ é”
- å¤§å¤§æå‡äº†å¹¶å‘æ€§èƒ½ï¼Œé»˜è®¤å¹¶å‘åº¦ä¸º16

**JDK 1.8 (2014)**ï¼šé‡å¤§æ¶æ„é‡æ„
- **é©å‘½æ€§å˜åŒ–**ï¼šæ”¾å¼ƒåˆ†æ®µé”ï¼Œé‡‡ç”¨CAS + synchronized
- å¼•å…¥çº¢é»‘æ ‘ä¼˜åŒ–ï¼Œè§£å†³å“ˆå¸Œå†²çªæ¶åŒ–é—®é¢˜
- Nodeæ•°ç»„ + CAS + synchronizedçš„æ–°æ¶æ„
- å¤§å¹…æå‡å¹¶å‘æ€§èƒ½å’Œå†…å­˜æ•ˆç‡

**JDK 1.9+ (2017-ç°åœ¨)**ï¼šæŒç»­ä¼˜åŒ–
- è¿›ä¸€æ­¥ä¼˜åŒ–CASæ“ä½œå’Œå†…å­˜å±éšœ
- æ”¹è¿›æ‰©å®¹ç®—æ³•çš„å¹¶å‘æ€§èƒ½
- ä¸Stream APIå’Œå¹¶è¡Œè®¡ç®—çš„æ›´å¥½é›†æˆ

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µä¸åŸç†

### åŸºç¡€æ¦‚å¿µå®šä¹‰

**ConcurrentHashMap**æ˜¯Javaå¹¶å‘åŒ…ä¸­æä¾›çš„çº¿ç¨‹å®‰å…¨å“ˆå¸Œè¡¨å®ç°ï¼Œé€šè¿‡ç²¾å·§çš„å¹¶å‘æ§åˆ¶æœºåˆ¶ï¼Œåœ¨ä¿è¯çº¿ç¨‹å®‰å…¨çš„åŒæ—¶å®ç°äº†é«˜å¹¶å‘æ€§èƒ½ã€‚

**æ ¸å¿ƒç‰¹æ€§**ï¼š
- **çº¿ç¨‹å®‰å…¨**ï¼šå¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¯å®‰å…¨ä½¿ç”¨ï¼Œæ— éœ€å¤–éƒ¨åŒæ­¥
- **é«˜å¹¶å‘æ€§èƒ½**ï¼šé‡‡ç”¨åˆ†æ®µé”æˆ–CAS+ç»†ç²’åº¦é”ï¼Œæ”¯æŒé«˜å¹¶å‘è®¿é—®
- **å¼±ä¸€è‡´æ€§**ï¼šè¿­ä»£å™¨å…·æœ‰å¼±ä¸€è‡´æ€§ï¼Œå…è®¸å¹¶å‘ä¿®æ”¹
- **æ— é”è¯»å–**ï¼šè¯»æ“ä½œé€šå¸¸æ— éœ€åŠ é”ï¼Œæ€§èƒ½æ¥è¿‘HashMap

### JDK 1.8æ¶æ„è®¾è®¡

**ConcurrentHashMap JDK 1.8çš„æ ¸å¿ƒæ¶æ„**ï¼š

```java
/**
 * ConcurrentHashMap JDK 1.8æ ¸å¿ƒæ¶æ„åˆ†æ
 */
public class ConcurrentHashMapJDK8Architecture {
    
    /**
     * æ ¸å¿ƒæ•°æ®ç»“æ„
     */
    public void analyzeCoreDataStructure() {
        /*
         * ConcurrentHashMapçš„æ ¸å¿ƒå­—æ®µï¼š
         * 
         * public class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
         *     implements ConcurrentMap<K,V>, Serializable {
         *     
         *     // å­˜å‚¨æ•°æ®çš„æ•°ç»„
         *     transient volatile Node<K,V>[] table;
         *     
         *     // æ‰©å®¹æ—¶çš„æ–°æ•°ç»„
         *     private transient volatile Node<K,V>[] nextTable;
         *     
         *     // åŸºç¡€è®¡æ•°å€¼
         *     private transient volatile long baseCount;
         *     
         *     // æ‰©å®¹æ§åˆ¶æ ‡è¯†
         *     private transient volatile int sizeCtl;
         *     
         *     // è®¡æ•°å™¨æ•°ç»„ï¼Œç”¨äºé«˜å¹¶å‘ä¸‹çš„sizeè®¡ç®—
         *     private transient volatile CounterCell[] counterCells;
         *     
         *     // æ‰©å®¹æ—¶çš„çº¿ç¨‹æ•°æ§åˆ¶
         *     private transient volatile int transferIndex;
         * }
         */
    }
    
    /**
     * NodeèŠ‚ç‚¹ç»“æ„åˆ†æ
     */
    public void analyzeNodeStructure() {
        /*
         * åŸºæœ¬NodeèŠ‚ç‚¹ï¼ˆé“¾è¡¨èŠ‚ç‚¹ï¼‰ï¼š
         * 
         * static class Node<K,V> implements Map.Entry<K,V> {
         *     final int hash;
         *     final K key;
         *     volatile V val;        // æ³¨æ„ï¼švalæ˜¯volatileçš„
         *     volatile Node<K,V> next; // nextæŒ‡é’ˆä¹Ÿæ˜¯volatileçš„
         *     
         *     Node(int hash, K key, V val, Node<K,V> next) {
         *         this.hash = hash;
         *         this.key = key;
         *         this.val = val;
         *         this.next = next;
         *     }
         * }
         * 
         * ç‰¹æ®ŠèŠ‚ç‚¹ç±»å‹ï¼š
         * 
         * 1. TreeNodeï¼šçº¢é»‘æ ‘èŠ‚ç‚¹
         * 2. TreeBinï¼šçº¢é»‘æ ‘çš„å®¹å™¨èŠ‚ç‚¹ï¼Œå®é™…å­˜å‚¨åœ¨æ•°ç»„ä¸­
         * 3. ForwardingNodeï¼šæ‰©å®¹æ—¶çš„å ä½èŠ‚ç‚¹
         * 4. ReservationNodeï¼šè®¡ç®—æ“ä½œçš„å ä½èŠ‚ç‚¹
         */
    }
    
    /**
     * é‡è¦å¸¸é‡å®šä¹‰
     */
    public void analyzeImportantConstants() {
        /*
         * å…³é”®å¸¸é‡ï¼š
         * 
         * // æœ€å¤§å®¹é‡
         * private static final int MAXIMUM_CAPACITY = 1 << 30;
         * 
         * // é»˜è®¤åˆå§‹å®¹é‡
         * private static final int DEFAULT_CAPACITY = 16;
         * 
         * // é“¾è¡¨è½¬çº¢é»‘æ ‘çš„é˜ˆå€¼
         * static final int TREEIFY_THRESHOLD = 8;
         * 
         * // çº¢é»‘æ ‘è½¬é“¾è¡¨çš„é˜ˆå€¼
         * static final int UNTREEIFY_THRESHOLD = 6;
         * 
         * // è½¬çº¢é»‘æ ‘çš„æœ€å°æ•°ç»„å®¹é‡
         * static final int MIN_TREEIFY_CAPACITY = 64;
         * 
         * // æ‰©å®¹æ—¶æ¯ä¸ªçº¿ç¨‹å¤„ç†çš„æœ€å°æ¡¶æ•°é‡
         * private static final int MIN_TRANSFER_STRIDE = 16;
         * 
         * // ç”¨äºç”Ÿæˆæ‰©å®¹æˆ³çš„å¸¸é‡
         * private static int RESIZE_STAMP_BITS = 16;
         * 
         * // sizeCtlçš„ç‰¹æ®Šå€¼
         * static final int MOVED     = -1; // ForwardingNodeçš„hashå€¼
         * static final int TREEBIN   = -2; // TreeBinçš„hashå€¼
         * static final int RESERVED  = -3; // ReservationNodeçš„hashå€¼
         */
    }
}
```

### å¹¶å‘æ§åˆ¶æœºåˆ¶

**CAS + synchronizedçš„æ··åˆç­–ç•¥**ï¼š

```java
/**
 * ConcurrentHashMapå¹¶å‘æ§åˆ¶æœºåˆ¶è¯¦è§£
 */
public class ConcurrentHashMapConcurrencyControl {
    
    /**
     * CASæ“ä½œçš„åº”ç”¨åœºæ™¯
     */
    public void analyzeCASUsage() {
        /*
         * CASæ“ä½œä¸»è¦ç”¨äºä»¥ä¸‹åœºæ™¯ï¼š
         * 
         * 1. æ•°ç»„å…ƒç´ çš„åŸå­æ›´æ–°ï¼š
         *    - tabAt(tab, i)ï¼švolatileè¯»å–æ•°ç»„å…ƒç´ 
         *    - casTabAt(tab, i, c, v)ï¼šCASæ›´æ–°æ•°ç»„å…ƒç´ 
         *    - setTabAt(tab, i, v)ï¼švolatileå†™å…¥æ•°ç»„å…ƒç´ 
         * 
         * 2. è®¡æ•°å™¨çš„åŸå­æ›´æ–°ï¼š
         *    - baseCountçš„CASæ›´æ–°
         *    - CounterCellæ•°ç»„å…ƒç´ çš„CASæ›´æ–°
         * 
         * 3. æ‰©å®¹æ§åˆ¶çš„åŸå­æ›´æ–°ï¼š
         *    - sizeCtlçš„CASæ›´æ–°
         *    - transferIndexçš„CASæ›´æ–°
         * 
         * CASçš„ä¼˜åŠ¿ï¼š
         * - æ— é”æ“ä½œï¼Œé¿å…çº¿ç¨‹é˜»å¡
         * - æ€§èƒ½é«˜ï¼Œé€‚åˆä½ç«äº‰åœºæ™¯
         * - æ— æ­»é”é£é™©
         */
    }
    
    /**
     * synchronizedé”çš„åº”ç”¨åœºæ™¯
     */
    public void analyzeSynchronizedUsage() {
        /*
         * synchronizedé”ä¸»è¦ç”¨äºä»¥ä¸‹åœºæ™¯ï¼š
         * 
         * 1. é“¾è¡¨æ“ä½œï¼š
         *    - å¯¹é“¾è¡¨å¤´èŠ‚ç‚¹åŠ é”
         *    - ä¿è¯é“¾è¡¨ç»“æ„çš„ä¸€è‡´æ€§
         * 
         * 2. çº¢é»‘æ ‘æ“ä½œï¼š
         *    - å¯¹TreeBinèŠ‚ç‚¹åŠ é”
         *    - ä¿è¯æ ‘ç»“æ„çš„ä¸€è‡´æ€§
         * 
         * 3. æ‰©å®¹æ“ä½œï¼š
         *    - å¯¹æ­£åœ¨è¿ç§»çš„æ¡¶åŠ é”
         *    - ä¿è¯è¿ç§»è¿‡ç¨‹çš„åŸå­æ€§
         * 
         * synchronizedçš„ä¼˜åŠ¿ï¼š
         * - JVMä¼˜åŒ–æˆç†Ÿï¼Œæ€§èƒ½è‰¯å¥½
         * - é”ç²’åº¦ç»†ï¼Œåªé”å®šç‰¹å®šèŠ‚ç‚¹
         * - æ”¯æŒé”å‡çº§ï¼Œé€‚åº”ä¸åŒç«äº‰ç¨‹åº¦
         */
    }
    
    /**
     * è¯»æ“ä½œçš„æ— é”å®ç°
     */
    public void analyzeReadOperations() {
        /*
         * è¯»æ“ä½œçš„æ— é”å®ç°åŸç†ï¼š
         * 
         * 1. volatileä¿è¯å¯è§æ€§ï¼š
         *    - tableæ•°ç»„æ˜¯volatileçš„
         *    - Nodeçš„valå’Œnextå­—æ®µæ˜¯volatileçš„
         *    - ä¿è¯è¯»æ“ä½œèƒ½çœ‹åˆ°æœ€æ–°å€¼
         * 
         * 2. å†…å­˜å±éšœä¿è¯æœ‰åºæ€§ï¼š
         *    - volatileè¯»ä¼šæ’å…¥LoadLoadå’ŒLoadStoreå±éšœ
         *    - é˜²æ­¢æŒ‡ä»¤é‡æ’åº
         * 
         * 3. å¼±ä¸€è‡´æ€§è¯­ä¹‰ï¼š
         *    - è¯»æ“ä½œå¯èƒ½çœ‹åˆ°éƒ¨åˆ†æ›´æ–°çš„çŠ¶æ€
         *    - ä½†ä¿è¯æœ€ç»ˆä¸€è‡´æ€§
         * 
         * è¯»æ“ä½œæµç¨‹ï¼š
         * 1. volatileè¯»å–table[i]
         * 2. éå†é“¾è¡¨æˆ–æœç´¢çº¢é»‘æ ‘
         * 3. é€šè¿‡volatileè¯»å–è·å¾—æœ€æ–°å€¼
         */
    }
}
```

### æ‰©å®¹æœºåˆ¶è¯¦è§£

**å¤šçº¿ç¨‹åä½œæ‰©å®¹**ï¼š

```java
/**
 * ConcurrentHashMapæ‰©å®¹æœºåˆ¶åˆ†æ
 */
public class ConcurrentHashMapResizing {
    
    /**
     * æ‰©å®¹è§¦å‘æ¡ä»¶
     */
    public void analyzeResizeTrigger() {
        /*
         * æ‰©å®¹è§¦å‘æ¡ä»¶ï¼š
         * 
         * 1. å…ƒç´ æ•°é‡è¾¾åˆ°é˜ˆå€¼ï¼š
         *    - å½“å‰å…ƒç´ æ•°é‡ >= sizeCtl
         *    - sizeCtlé€šå¸¸ä¸ºå®¹é‡çš„0.75å€
         * 
         * 2. é“¾è¡¨é•¿åº¦è¿‡é•¿ï¼š
         *    - é“¾è¡¨é•¿åº¦ >= TREEIFY_THRESHOLD (8)
         *    - ä½†æ•°ç»„é•¿åº¦ < MIN_TREEIFY_CAPACITY (64)
         *    - æ­¤æ—¶é€‰æ‹©æ‰©å®¹è€Œä¸æ˜¯æ ‘åŒ–
         * 
         * 3. æ‰‹åŠ¨è§¦å‘ï¼š
         *    - è°ƒç”¨putAllç­‰æ‰¹é‡æ“ä½œ
         *    - é¢„ä¼°éœ€è¦æ›´å¤§å®¹é‡
         */
    }
    
    /**
     * å¤šçº¿ç¨‹åä½œæ‰©å®¹æœºåˆ¶
     */
    public void analyzeMultiThreadResize() {
        /*
         * å¤šçº¿ç¨‹åä½œæ‰©å®¹çš„æ ¸å¿ƒæ€æƒ³ï¼š
         * 
         * 1. æ‰©å®¹ä»»åŠ¡åˆ†ç‰‡ï¼š
         *    - å°†æ•°ç»„åˆ†ä¸ºå¤šä¸ªç‰‡æ®µï¼ˆstrideï¼‰
         *    - æ¯ä¸ªçº¿ç¨‹è´Ÿè´£ä¸€ä¸ªæˆ–å¤šä¸ªç‰‡æ®µ
         *    - æœ€å°ç‰‡æ®µå¤§å°ä¸ºMIN_TRANSFER_STRIDE (16)
         * 
         * 2. æ‰©å®¹çŠ¶æ€æ§åˆ¶ï¼š
         *    - sizeCtlç¼–ç æ‰©å®¹çŠ¶æ€å’Œå‚ä¸çº¿ç¨‹æ•°
         *    - é«˜16ä½ï¼šæ‰©å®¹æˆ³ï¼ˆresizeStampï¼‰
         *    - ä½16ä½ï¼šå‚ä¸æ‰©å®¹çš„çº¿ç¨‹æ•° + 1
         * 
         * 3. æ‰©å®¹è¿‡ç¨‹ï¼š
         *    - ç¬¬ä¸€ä¸ªçº¿ç¨‹åˆ›å»ºnextTable
         *    - åç»­çº¿ç¨‹åŠ å…¥åä½œæ‰©å®¹
         *    - ä½¿ç”¨ForwardingNodeæ ‡è®°å·²è¿ç§»çš„æ¡¶
         *    - æœ€åä¸€ä¸ªçº¿ç¨‹å®Œæˆæ‰©å®¹
         * 
         * 4. å¹¶å‘å®‰å…¨ä¿è¯ï¼š
         *    - transferIndexè®°å½•ä¸‹ä¸€ä¸ªå¾…åˆ†é…çš„æ¡¶
         *    - CASæ“ä½œåˆ†é…ä»»åŠ¡ç»™çº¿ç¨‹
         *    - ForwardingNodeæŒ‡å‘æ–°æ•°ç»„ä½ç½®
         */
    }
    
    /**
     * æ‰©å®¹è¿‡ç¨‹ä¸­çš„è¯»å†™æ“ä½œ
     */
    public void analyzeOperationsDuringResize() {
        /*
         * æ‰©å®¹è¿‡ç¨‹ä¸­çš„æ“ä½œå¤„ç†ï¼š
         * 
         * 1. è¯»æ“ä½œï¼š
         *    - é‡åˆ°ForwardingNodeæ—¶ï¼Œè½¬åˆ°nextTableæŸ¥æ‰¾
         *    - ä¿è¯è¯»æ“ä½œçš„ä¸€è‡´æ€§
         * 
         * 2. å†™æ“ä½œï¼š
         *    - å¦‚æœå‘ç°æ­£åœ¨æ‰©å®¹ï¼Œå¸®åŠ©è¿›è¡Œæ‰©å®¹
         *    - æ‰©å®¹å®Œæˆåå†è¿›è¡Œå†™æ“ä½œ
         * 
         * 3. è¿­ä»£æ“ä½œï¼š
         *    - è¿­ä»£å™¨å…·æœ‰å¼±ä¸€è‡´æ€§
         *    - å¯èƒ½éå†åˆ°æ‰©å®¹å‰åçš„ä¸åŒçŠ¶æ€
         * 
         * ä¼˜åŠ¿ï¼š
         * - æ‰©å®¹è¿‡ç¨‹ä¸­ä¸é˜»å¡è¯»å†™æ“ä½œ
         * - å¤šçº¿ç¨‹åä½œï¼Œæ‰©å®¹é€Ÿåº¦å¿«
         * - å†…å­˜ä½¿ç”¨æ•ˆç‡é«˜
         */
    }
}

## ğŸ”§ å®ç°åŸç†ä¸æºç åˆ†æ

### æ ¸å¿ƒæ“ä½œå®ç°

**ConcurrentHashMapçš„å¢åˆ æ”¹æŸ¥æ“ä½œæºç è§£æ**ï¼š

```java
/**
 * ConcurrentHashMapæ ¸å¿ƒæ“ä½œæºç åˆ†æ
 */
public class ConcurrentHashMapCoreOperations {
    
    /**
     * putæ“ä½œçš„å®Œæ•´æµç¨‹
     */
    public void analyzePutOperation() {
        /*
         * putValæ–¹æ³•çš„æ ¸å¿ƒé€»è¾‘ï¼š
         * 
         * 1. è®¡ç®—hashå€¼ï¼šspread(key.hashCode())
         * 2. è‡ªæ—‹ç›´åˆ°æˆåŠŸæ’å…¥ï¼š
         *    - å¦‚æœtableä¸ºç©ºï¼Œåˆå§‹åŒ–
         *    - å¦‚æœç›®æ ‡ä½ç½®ä¸ºç©ºï¼ŒCASæ’å…¥
         *    - å¦‚æœé‡åˆ°ForwardingNodeï¼Œå¸®åŠ©æ‰©å®¹
         *    - å¦åˆ™å¯¹å¤´èŠ‚ç‚¹åŠ é”è¿›è¡Œé“¾è¡¨/æ ‘æ“ä½œ
         * 3. æ›´æ–°è®¡æ•°å¹¶æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
         */
    }
    
    /**
     * getæ“ä½œçš„å®ç°åˆ†æ
     */
    public void analyzeGetOperation() {
        /*
         * getæ–¹æ³•çš„æ ¸å¿ƒé€»è¾‘ï¼š
         * 
         * 1. è®¡ç®—hashå€¼
         * 2. volatileè¯»å–table[i]
         * 3. æ£€æŸ¥å¤´èŠ‚ç‚¹æ˜¯å¦åŒ¹é…
         * 4. æ ¹æ®èŠ‚ç‚¹ç±»å‹é€‰æ‹©æŸ¥æ‰¾ç­–ç•¥ï¼š
         *    - æ™®é€šèŠ‚ç‚¹ï¼šéå†é“¾è¡¨
         *    - ç‰¹æ®ŠèŠ‚ç‚¹ï¼šè°ƒç”¨findæ–¹æ³•
         * 
         * å…³é”®ç‰¹ç‚¹ï¼šæ•´ä¸ªè¿‡ç¨‹æ— é”ï¼Œé€šè¿‡volatileä¿è¯å¯è§æ€§
         */
    }
    
    /**
     * è®¡æ•°æœºåˆ¶åˆ†æ
     */
    public void analyzeCountingMechanism() {
        /*
         * size()æ–¹æ³•çš„å®ç°åŸç†ï¼š
         * 
         * 1. baseCountï¼šåŸºç¡€è®¡æ•°å€¼
         * 2. counterCellsï¼šåˆ†æ•£è®¡æ•°æ•°ç»„ï¼Œå‡å°‘CASç«äº‰
         * 3. æ’å…¥æ—¶ä¼˜å…ˆæ›´æ–°baseCountï¼Œå¤±è´¥æ—¶ä½¿ç”¨counterCells
         * 4. size()æ—¶æ±‡æ€»æ‰€æœ‰è®¡æ•°å€¼
         * 
         * ä¼˜åŠ¿ï¼šé«˜å¹¶å‘ä¸‹é¿å…è®¡æ•°å™¨æˆä¸ºç“¶é¢ˆ
         */
    }
}
```

### åˆ†æ®µé” vs CAS+synchronizedå¯¹æ¯”

```java
/**
 * ConcurrentHashMapæ¶æ„æ¼”è¿›å¯¹æ¯”
 */
public class ConcurrentHashMapArchitectureComparison {
    
    /**
     * JDK 1.7 vs JDK 1.8æ€§èƒ½å¯¹æ¯”
     */
    public void performanceComparison() {
        /*
         * æ€§èƒ½å¯¹æ¯”ç»“æœï¼š
         * 
         * 1. è¯»æ“ä½œæ€§èƒ½ï¼š
         *    - JDK 1.7ï¼švolatileè¯»ï¼Œæ€§èƒ½è‰¯å¥½
         *    - JDK 1.8ï¼šå®Œå…¨æ— é”ï¼Œæ€§èƒ½æ›´ä¼˜
         * 
         * 2. å†™æ“ä½œæ€§èƒ½ï¼š
         *    - JDK 1.7ï¼šSegmenté”ï¼Œå¹¶å‘åº¦æœ‰é™
         *    - JDK 1.8ï¼šCAS+ç»†ç²’åº¦é”ï¼Œå¹¶å‘åº¦æ›´é«˜
         * 
         * 3. å†…å­˜ä½¿ç”¨ï¼š
         *    - JDK 1.7ï¼šSegmentå¯¹è±¡å¼€é”€è¾ƒå¤§
         *    - JDK 1.8ï¼šå†…å­˜ä½¿ç”¨æ›´åŠ é«˜æ•ˆ
         * 
         * 4. å“ˆå¸Œå†²çªå¤„ç†ï¼š
         *    - JDK 1.7ï¼šçº¯é“¾è¡¨ï¼Œæœ€åO(n)
         *    - JDK 1.8ï¼šçº¢é»‘æ ‘ä¼˜åŒ–ï¼Œæœ€åO(log n)
         */
    }
}
```

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹ä¸ä»£ç ç¤ºä¾‹

### å…·ä½“é¡¹ç›®åº”ç”¨

**åœºæ™¯1ï¼šé«˜å¹¶å‘è®¡æ•°å™¨å®ç°**

```java
/**
 * åŸºäºConcurrentHashMapçš„é«˜å¹¶å‘è®¡æ•°å™¨
 */
@Component
public class HighConcurrencyCounter {
    
    private final ConcurrentHashMap<String, AtomicLong> counters;
    private final int maxCounters;
    
    public HighConcurrencyCounter(int maxCounters) {
        this.maxCounters = maxCounters;
        this.counters = new ConcurrentHashMap<>(calculateInitialCapacity(maxCounters));
    }
    
    private int calculateInitialCapacity(int maxCounters) {
        return (int) (maxCounters / 0.75) + 1;
    }
    
    /**
     * å¢åŠ è®¡æ•°
     */
    public long increment(String key) {
        // ä½¿ç”¨computeIfAbsentåŸå­åœ°åˆ›å»ºè®¡æ•°å™¨
        AtomicLong counter = counters.computeIfAbsent(key, k -> new AtomicLong(0));
        return counter.incrementAndGet();
    }
    
    /**
     * è·å–è®¡æ•°å€¼
     */
    public long getCount(String key) {
        AtomicLong counter = counters.get(key);
        return counter != null ? counter.get() : 0;
    }
    
    /**
     * æ‰¹é‡è·å–è®¡æ•°
     */
    public Map<String, Long> getBatchCounts(Set<String> keys) {
        Map<String, Long> result = new HashMap<>(keys.size());
        for (String key : keys) {
            result.put(key, getCount(key));
        }
        return result;
    }
    
    /**
     * åŸå­æ€§çš„æ¡ä»¶æ›´æ–°
     */
    public long incrementIfLessThan(String key, long threshold, long delta) {
        return counters.computeIfAbsent(key, k -> new AtomicLong(0))
            .updateAndGet(current -> current < threshold ? current + delta : current);
    }
}
```

**åœºæ™¯2ï¼šåˆ†å¸ƒå¼ç¼“å­˜ç®¡ç†å™¨**

```java
/**
 * åŸºäºConcurrentHashMapçš„åˆ†å¸ƒå¼ç¼“å­˜ç®¡ç†å™¨
 */
@Component
public class DistributedCacheManager<K, V> {
    
    private final ConcurrentHashMap<K, CacheEntry<V>> localCache;
    private final RedisTemplate<String, Object> redisTemplate;
    private final String cachePrefix;
    private final long localTTL;
    
    public DistributedCacheManager(RedisTemplate<String, Object> redisTemplate,
                                 String cachePrefix, long localTTL) {
        this.localCache = new ConcurrentHashMap<>();
        this.redisTemplate = redisTemplate;
        this.cachePrefix = cachePrefix;
        this.localTTL = localTTL;
    }
    
    /**
     * å¤šçº§ç¼“å­˜è·å–
     */
    public V get(K key) {
        // L1: æœ¬åœ°ç¼“å­˜
        CacheEntry<V> localEntry = localCache.get(key);
        if (localEntry != null && !localEntry.isExpired()) {
            return localEntry.getValue();
        }
        
        // L2: Redisç¼“å­˜
        String redisKey = buildRedisKey(key);
        V value = (V) redisTemplate.opsForValue().get(redisKey);
        
        if (value != null) {
            // å›å†™åˆ°æœ¬åœ°ç¼“å­˜
            putLocal(key, value);
            return value;
        }
        
        return null;
    }
    
    /**
     * å¤šçº§ç¼“å­˜å­˜å‚¨
     */
    public void put(K key, V value) {
        putLocal(key, value);
        putRemote(key, value);
    }
    
    private void putLocal(K key, V value) {
        long expireTime = System.currentTimeMillis() + localTTL;
        CacheEntry<V> entry = new CacheEntry<>(value, expireTime);
        localCache.put(key, entry);
    }
    
    private void putRemote(K key, V value) {
        String redisKey = buildRedisKey(key);
        redisTemplate.opsForValue().set(redisKey, value, localTTL, TimeUnit.MILLISECONDS);
    }
    
    private String buildRedisKey(K key) {
        return cachePrefix + ":" + key.toString();
    }
    
    private static class CacheEntry<V> {
        private final V value;
        private final long expireTime;
        
        public CacheEntry(V value, long expireTime) {
            this.value = value;
            this.expireTime = expireTime;
        }
        
        public boolean isExpired() {
            return System.currentTimeMillis() > expireTime;
        }
        
                 public V getValue() { return value; }
     }
 }
 ```

## ğŸ¯ é¢è¯•é«˜é¢‘é—®é¢˜ç²¾è®²

### æ ¸å¿ƒé¢è¯•é—®é¢˜

**é—®é¢˜1ï¼šConcurrentHashMapçš„å®ç°åŸç†**

```java
/**
 * ConcurrentHashMapå®ç°åŸç†é¢è¯•è¦ç‚¹
 */
public class ConcurrentHashMapImplementationPrinciples {
    
    /**
     * æ ‡å‡†é¢è¯•ç­”æ¡ˆ
     */
    public void explainImplementation() {
        /*
         * ConcurrentHashMapå®ç°åŸç†ï¼š
         * 
         * 1. æ•°æ®ç»“æ„ï¼ˆJDK 1.8ï¼‰ï¼š
         *    - Nodeæ•°ç»„ + é“¾è¡¨ + çº¢é»‘æ ‘
         *    - volatile Node[] tableä¿è¯å¯è§æ€§
         *    - ç‰¹æ®ŠèŠ‚ç‚¹ï¼šForwardingNodeã€TreeBinç­‰
         * 
         * 2. å¹¶å‘æ§åˆ¶ç­–ç•¥ï¼š
         *    - CASæ“ä½œï¼šæ•°ç»„å…ƒç´ çš„åŸå­æ›´æ–°
         *    - synchronizedé”ï¼šé“¾è¡¨/æ ‘èŠ‚ç‚¹çš„ç»†ç²’åº¦é”
         *    - volatileè¯»ï¼šæ— é”çš„è¯»æ“ä½œ
         * 
         * 3. å…³é”®æœºåˆ¶ï¼š
         *    - å¤šçº¿ç¨‹åä½œæ‰©å®¹
         *    - åˆ†æ•£è®¡æ•°ï¼ˆbaseCount + counterCellsï¼‰
         *    - çº¢é»‘æ ‘ä¼˜åŒ–å“ˆå¸Œå†²çª
         * 
         * 4. æ€§èƒ½ç‰¹ç‚¹ï¼š
         *    - è¯»æ“ä½œå‡ ä¹æ— é”ï¼Œæ€§èƒ½æ¥è¿‘HashMap
         *    - å†™æ“ä½œé”ç²’åº¦ç»†ï¼Œæ”¯æŒé«˜å¹¶å‘
         *    - æ‰©å®¹ä¸é˜»å¡è¯»å†™æ“ä½œ
         */
    }
}
```

**é—®é¢˜2ï¼šConcurrentHashMap vs HashMap vs Hashtable**

```java
/**
 * ä¸‰ç§Mapå®ç°å¯¹æ¯”åˆ†æ
 */
public class MapImplementationComparison {
    
    /**
     * è¯¦ç»†å¯¹æ¯”åˆ†æ
     */
    public void compareMapImplementations() {
        /*
         * å¯¹æ¯”è¡¨æ ¼ï¼š
         * 
         * | ç‰¹æ€§ | HashMap | Hashtable | ConcurrentHashMap |
         * |------|---------|-----------|-------------------|
         * | çº¿ç¨‹å®‰å…¨ | âŒ | âœ… | âœ… |
         * | nullæ”¯æŒ | âœ… | âŒ | âŒ |
         * | å¹¶å‘æ€§èƒ½ | N/A | å·® | ä¼˜ç§€ |
         * | é”æœºåˆ¶ | æ—  | synchronizedæ–¹æ³• | CAS+ç»†ç²’åº¦é” |
         * | è¿­ä»£å™¨ | fail-fast | fail-fast | å¼±ä¸€è‡´æ€§ |
         * | ç»§æ‰¿å…³ç³» | AbstractMap | Dictionary | AbstractMap |
         * | JDKç‰ˆæœ¬ | 1.2+ | 1.0+ | 1.5+ |
         * 
         * ä½¿ç”¨åœºæ™¯ï¼š
         * - HashMapï¼šå•çº¿ç¨‹æˆ–å¤–éƒ¨åŒæ­¥
         * - Hashtableï¼šç®€å•çš„çº¿ç¨‹å®‰å…¨éœ€æ±‚ï¼ˆå·²è¿‡æ—¶ï¼‰
         * - ConcurrentHashMapï¼šé«˜å¹¶å‘åœºæ™¯
         */
    }
}
```

**é—®é¢˜3ï¼šConcurrentHashMapçš„å¼±ä¸€è‡´æ€§**

```java
/**
 * ConcurrentHashMapå¼±ä¸€è‡´æ€§åˆ†æ
 */
public class ConcurrentHashMapWeakConsistency {
    
    /**
     * å¼±ä¸€è‡´æ€§çš„è¡¨ç°
     */
    public void explainWeakConsistency() {
        /*
         * å¼±ä¸€è‡´æ€§çš„å…·ä½“è¡¨ç°ï¼š
         * 
         * 1. size()æ–¹æ³•ï¼š
         *    - è¿”å›çš„æ˜¯æŸä¸ªæ—¶é—´ç‚¹çš„è¿‘ä¼¼å€¼
         *    - åœ¨å¹¶å‘ä¿®æ”¹æ—¶å¯èƒ½ä¸å‡†ç¡®
         *    - ä½†æœ€ç»ˆä¼šè¶‹äºä¸€è‡´
         * 
         * 2. è¿­ä»£å™¨ï¼š
         *    - éå†è¿‡ç¨‹ä¸­å…è®¸å¹¶å‘ä¿®æ”¹
         *    - ä¸ä¼šæŠ›å‡ºConcurrentModificationException
         *    - å¯èƒ½çœ‹åˆ°éƒ¨åˆ†æ›´æ–°çš„çŠ¶æ€
         * 
         * 3. å¤åˆæ“ä½œï¼š
         *    - putIfAbsentã€replaceç­‰æ˜¯åŸå­çš„
         *    - ä½†å¤šä¸ªæ“ä½œä¹‹é—´ä¸ä¿è¯åŸå­æ€§
         * 
         * 4. å†…å­˜å¯è§æ€§ï¼š
         *    - é€šè¿‡volatileä¿è¯æœ€ç»ˆä¸€è‡´æ€§
         *    - ä½†å¯èƒ½å­˜åœ¨çŸ­æš‚çš„ä¸ä¸€è‡´çŠ¶æ€
         * 
         * ä¼˜åŠ¿ï¼š
         * - é¿å…äº†å¼ºä¸€è‡´æ€§çš„æ€§èƒ½å¼€é”€
         * - é€‚åˆå¤§å¤šæ•°å¹¶å‘åœºæ™¯
         * - å‡å°‘äº†é”ç«äº‰å’Œé˜»å¡
         */
    }
}
```

**é—®é¢˜4ï¼šConcurrentHashMapçš„æ‰©å®¹æœºåˆ¶**

```java
/**
 * ConcurrentHashMapæ‰©å®¹æœºåˆ¶é¢è¯•è¦ç‚¹
 */
public class ConcurrentHashMapResizeInterview {
    
    /**
     * æ‰©å®¹æœºåˆ¶è¯¦è§£
     */
    public void explainResizeMechanism() {
        /*
         * æ‰©å®¹æœºåˆ¶çš„å…³é”®ç‚¹ï¼š
         * 
         * 1. è§¦å‘æ¡ä»¶ï¼š
         *    - å…ƒç´ æ•°é‡è¶…è¿‡é˜ˆå€¼ï¼ˆcapacity * 0.75ï¼‰
         *    - é“¾è¡¨é•¿åº¦è¾¾åˆ°8ä½†æ•°ç»„é•¿åº¦å°äº64
         * 
         * 2. å¤šçº¿ç¨‹åä½œï¼š
         *    - ç¬¬ä¸€ä¸ªçº¿ç¨‹åˆå§‹åŒ–nextTable
         *    - åç»­çº¿ç¨‹å¸®åŠ©è¿ç§»æ•°æ®
         *    - ä½¿ç”¨transferIndexåˆ†é…ä»»åŠ¡
         * 
         * 3. è¿ç§»è¿‡ç¨‹ï¼š
         *    - æ¯ä¸ªçº¿ç¨‹å¤„ç†ä¸€ä¸ªstrideï¼ˆæœ€å°16ï¼‰
         *    - ä½¿ç”¨ForwardingNodeæ ‡è®°å·²è¿ç§»çš„æ¡¶
         *    - ä¿è¯è¿ç§»è¿‡ç¨‹çš„åŸå­æ€§
         * 
         * 4. å¹¶å‘è¯»å†™ï¼š
         *    - è¯»æ“ä½œé‡åˆ°ForwardingNodeæ—¶è½¬åˆ°æ–°è¡¨
         *    - å†™æ“ä½œå‘ç°æ‰©å®¹æ—¶å¸®åŠ©è¿ç§»
         *    - ä¸é˜»å¡æ­£å¸¸çš„è¯»å†™æ“ä½œ
         * 
         * 5. çŠ¶æ€æ§åˆ¶ï¼š
         *    - sizeCtlç¼–ç æ‰©å®¹çŠ¶æ€å’Œçº¿ç¨‹æ•°
         *    - é€šè¿‡CASæ“ä½œåè°ƒå¤šçº¿ç¨‹
         */
    }
}
```

**é—®é¢˜5ï¼šä¸ºä»€ä¹ˆJDK 1.8æ”¾å¼ƒåˆ†æ®µé”ï¼Ÿ**

```java
/**
 * JDK 1.8æ¶æ„å˜æ›´åŸå› åˆ†æ
 */
public class JDK8ArchitectureChangeReasons {
    
    /**
     * æ”¾å¼ƒåˆ†æ®µé”çš„åŸå› 
     */
    public void explainArchitectureChange() {
        /*
         * æ”¾å¼ƒåˆ†æ®µé”çš„ä¸»è¦åŸå› ï¼š
         * 
         * 1. å¹¶å‘åº¦é™åˆ¶ï¼š
         *    - Segmentæ•°é‡å›ºå®šï¼ˆé»˜è®¤16ï¼‰
         *    - æ— æ³•æ ¹æ®å®é™…è´Ÿè½½åŠ¨æ€è°ƒæ•´
         *    - é«˜å¹¶å‘åœºæ™¯ä¸‹æˆä¸ºç“¶é¢ˆ
         * 
         * 2. å†…å­˜å¼€é”€ï¼š
         *    - æ¯ä¸ªSegmentéƒ½æ˜¯ä¸€ä¸ªReentrantLockå¯¹è±¡
         *    - é¢å¤–çš„å†…å­˜å¼€é”€è¾ƒå¤§
         *    - å½±å“ç¼“å­˜å±€éƒ¨æ€§
         * 
         * 3. å…¨å±€æ“ä½œæ€§èƒ½ï¼š
         *    - size()éœ€è¦é”å®šæ‰€æœ‰Segment
         *    - isEmpty()ç­‰æ“ä½œæ•ˆç‡ä½
         *    - å½±å“æ•´ä½“æ€§èƒ½
         * 
         * 4. æŠ€æœ¯å‘å±•ï¼š
         *    - CASæ“ä½œçš„æˆç†Ÿå’Œä¼˜åŒ–
         *    - JVMå¯¹synchronizedçš„ä¼˜åŒ–
         *    - çº¢é»‘æ ‘è§£å†³å“ˆå¸Œå†²çªé—®é¢˜
         * 
         * æ–°æ¶æ„çš„ä¼˜åŠ¿ï¼š
         * - ç†è®ºå¹¶å‘åº¦ç­‰äºæ•°ç»„é•¿åº¦
         * - å†…å­˜ä½¿ç”¨æ›´åŠ é«˜æ•ˆ
         * - æ‰©å®¹æ€§èƒ½å¤§å¹…æå‡
         * - è¯»æ“ä½œå®Œå…¨æ— é”
         */
    }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**1. å®¹é‡è§„åˆ’ä¼˜åŒ–**

```java
/**
 * ConcurrentHashMapå®¹é‡ä¼˜åŒ–ç­–ç•¥
 */
public class ConcurrentHashMapCapacityOptimization {
    
    /**
     * æœ€ä½³å®è·µï¼šåˆç†è®¾ç½®åˆå§‹å®¹é‡
     */
    public void capacityOptimizationBestPractices() {
        // âŒ é”™è¯¯åšæ³•ï¼šä½¿ç”¨é»˜è®¤å®¹é‡
        ConcurrentHashMap<String, String> badMap = new ConcurrentHashMap<>();
        
        // âœ… æ­£ç¡®åšæ³•ï¼šé¢„ä¼°å®¹é‡
        int expectedSize = 10000;
        int initialCapacity = (int) (expectedSize / 0.75) + 1;
        ConcurrentHashMap<String, String> goodMap = new ConcurrentHashMap<>(initialCapacity);
        
        // âœ… æ›´å¥½çš„åšæ³•ï¼šè€ƒè™‘å¹¶å‘çº§åˆ«
        int concurrencyLevel = Runtime.getRuntime().availableProcessors();
        ConcurrentHashMap<String, String> betterMap = new ConcurrentHashMap<>(
            initialCapacity, 0.75f, concurrencyLevel);
    }
    
    /**
     * å¹¶å‘çº§åˆ«è°ƒä¼˜
     */
    public void concurrencyLevelTuning() {
        /*
         * å¹¶å‘çº§åˆ«è®¾ç½®å»ºè®®ï¼š
         * 
         * 1. CPUå¯†é›†å‹åº”ç”¨ï¼š
         *    concurrencyLevel = CPUæ ¸å¿ƒæ•°
         * 
         * 2. IOå¯†é›†å‹åº”ç”¨ï¼š
         *    concurrencyLevel = CPUæ ¸å¿ƒæ•° * 2
         * 
         * 3. æ··åˆå‹åº”ç”¨ï¼š
         *    æ ¹æ®å®é™…æµ‹è¯•ç»“æœè°ƒæ•´
         * 
         * æ³¨æ„ï¼šJDK 1.8ä¸­concurrencyLevelåªå½±å“åˆå§‹åŒ–
         */
    }
}
```

**2. é¿å…å¸¸è§æ€§èƒ½é™·é˜±**

```java
/**
 * ConcurrentHashMapæ€§èƒ½é™·é˜±åŠé¿å…æ–¹æ³•
 */
public class ConcurrentHashMapPerformancePitfalls {
    
    /**
     * é™·é˜±1ï¼šé¢‘ç¹çš„size()è°ƒç”¨
     */
    public void avoidFrequentSizeCalls() {
        ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
        
        // âŒ æ€§èƒ½é™·é˜±ï¼šé¢‘ç¹è°ƒç”¨size()
        for (int i = 0; i < 1000; i++) {
            map.put("key" + i, "value" + i);
            if (map.size() > 500) { // æ¯æ¬¡éƒ½è¦éå†counterCells
                // æ‰§è¡ŒæŸäº›é€»è¾‘
            }
        }
        
        // âœ… ä¼˜åŒ–æ–¹æ¡ˆï¼šä½¿ç”¨æœ¬åœ°è®¡æ•°å™¨
        AtomicInteger localCounter = new AtomicInteger(0);
        for (int i = 0; i < 1000; i++) {
            map.put("key" + i, "value" + i);
            if (localCounter.incrementAndGet() > 500) {
                // æ‰§è¡ŒæŸäº›é€»è¾‘
            }
        }
    }
    
    /**
     * é™·é˜±2ï¼šä¸å½“çš„è¿­ä»£æ“ä½œ
     */
    public void avoidInappropriateIteration() {
        ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
        
        // âŒ æ€§èƒ½é™·é˜±ï¼šåœ¨è¿­ä»£ä¸­è¿›è¡Œä¿®æ”¹
        for (Map.Entry<String, String> entry : map.entrySet()) {
            if (someCondition(entry.getValue())) {
                map.remove(entry.getKey()); // å¯èƒ½å½±å“è¿­ä»£æ€§èƒ½
            }
        }
        
        // âœ… ä¼˜åŒ–æ–¹æ¡ˆï¼šæ”¶é›†åæ‰¹é‡æ“ä½œ
        List<String> keysToRemove = map.entrySet().stream()
            .filter(entry -> someCondition(entry.getValue()))
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
        
        keysToRemove.forEach(map::remove);
    }
    
    /**
     * é™·é˜±3ï¼šå“ˆå¸Œå†²çªä¸¥é‡
     */
    public void avoidHashCollisions() {
        // âŒ æ€§èƒ½é™·é˜±ï¼šä½¿ç”¨å®¹æ˜“å†²çªçš„key
        ConcurrentHashMap<BadKey, String> badMap = new ConcurrentHashMap<>();
        
        // âœ… ä¼˜åŒ–æ–¹æ¡ˆï¼šä½¿ç”¨åˆ†å¸ƒå‡åŒ€çš„key
        ConcurrentHashMap<GoodKey, String> goodMap = new ConcurrentHashMap<>();
    }
    
    private boolean someCondition(String value) {
        return value.length() > 10;
    }
    
    // ç¤ºä¾‹ï¼šä¸å¥½çš„keyè®¾è®¡
    static class BadKey {
        private final int value;
        
        BadKey(int value) { this.value = value; }
        
        @Override
        public int hashCode() {
            return 1; // æ‰€æœ‰å¯¹è±¡éƒ½æœ‰ç›¸åŒçš„hashCode
        }
    }
    
    // ç¤ºä¾‹ï¼šå¥½çš„keyè®¾è®¡
    static class GoodKey {
        private final int value;
        
        GoodKey(int value) { this.value = value; }
        
        @Override
        public int hashCode() {
            return Integer.hashCode(value);
        }
    }
}
```

### å…³é”®æ³¨æ„äº‹é¡¹

**1. çº¿ç¨‹å®‰å…¨ä½¿ç”¨æŒ‡å—**

```java
/**
 * ConcurrentHashMapçº¿ç¨‹å®‰å…¨ä½¿ç”¨æŒ‡å—
 */
public class ConcurrentHashMapThreadSafetyGuide {
    
    /**
     * åŸå­æ“ä½œvså¤åˆæ“ä½œ
     */
    public void atomicVsCompoundOperations() {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        
        // âœ… åŸå­æ“ä½œï¼šçº¿ç¨‹å®‰å…¨
        map.put("key", 1);
        Integer value = map.get("key");
        map.putIfAbsent("key", 1);
        map.replace("key", 1, 2);
        
        // âŒ å¤åˆæ“ä½œï¼šä¸æ˜¯åŸå­çš„
        if (!map.containsKey("key")) {
            map.put("key", 1); // å¯èƒ½è¢«å…¶ä»–çº¿ç¨‹æŠ¢å…ˆ
        }
        
        // âœ… ä½¿ç”¨åŸå­æ–¹æ³•
        map.putIfAbsent("key", 1);
        
        // âŒ éåŸå­çš„è®¡æ•°æ“ä½œ
        Integer count = map.get("counter");
        map.put("counter", count == null ? 1 : count + 1);
        
        // âœ… ä½¿ç”¨computeæ–¹æ³•
        map.compute("counter", (k, v) -> v == null ? 1 : v + 1);
    }
    
    /**
     * è¿­ä»£å®‰å…¨æ€§
     */
    public void iterationSafety() {
        ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
        
        // âœ… å¼±ä¸€è‡´æ€§è¿­ä»£ï¼šå®‰å…¨ä½†å¯èƒ½çœ‹åˆ°ä¸ä¸€è‡´çŠ¶æ€
        for (Map.Entry<String, String> entry : map.entrySet()) {
            // è¿­ä»£è¿‡ç¨‹ä¸­å…¶ä»–çº¿ç¨‹çš„ä¿®æ”¹ä¸ä¼šå½±å“è¿­ä»£å™¨
            System.out.println(entry.getKey() + "=" + entry.getValue());
        }
        
        // âœ… ä½¿ç”¨Stream APIï¼šæ”¯æŒå¹¶è¡Œå¤„ç†
        map.entrySet().parallelStream()
            .filter(entry -> entry.getValue().length() > 5)
            .forEach(entry -> System.out.println(entry.getKey()));
    }
}
```

## ğŸ“š æ€»ç»“ä¸æŠ€æœ¯å¯¹æ¯”

### æ ¸å¿ƒè¦ç‚¹æ€»ç»“

**ConcurrentHashMapçš„è®¾è®¡ç²¾é«“**ï¼š

1. **å¹¶å‘æ§åˆ¶åˆ›æ–°**ï¼šCAS + synchronizedçš„æ··åˆç­–ç•¥ï¼Œå…¼é¡¾æ€§èƒ½å’Œå®‰å…¨æ€§
2. **æ¶æ„æ¼”è¿›ä¼˜åŒ–**ï¼šä»åˆ†æ®µé”åˆ°ç»†ç²’åº¦é”ï¼Œå¤§å¹…æå‡å¹¶å‘åº¦
3. **æ— é”è¯»å–**ï¼šé€šè¿‡volatileä¿è¯è¯»æ“ä½œçš„é«˜æ€§èƒ½å’Œå¯è§æ€§
4. **åä½œå¼æ‰©å®¹**ï¼šå¤šçº¿ç¨‹åä½œæ‰©å®¹ï¼Œä¸é˜»å¡æ­£å¸¸è¯»å†™æ“ä½œ
5. **å¼±ä¸€è‡´æ€§è®¾è®¡**ï¼šå¹³è¡¡ä¸€è‡´æ€§å’Œæ€§èƒ½ï¼Œé€‚åˆå¤§å¤šæ•°åœºæ™¯

### ä¸å…¶ä»–å¹¶å‘Mapå®ç°å¯¹æ¯”

| ç‰¹æ€§ | ConcurrentHashMap | Collections.synchronizedMap | ConcurrentSkipListMap |
|------|-------------------|----------------------------|----------------------|
| åº•å±‚ç»“æ„ | å“ˆå¸Œè¡¨+çº¢é»‘æ ‘ | åŒ…è£…å™¨+ç²—ç²’åº¦é” | è·³è¡¨ |
| æ—¶é—´å¤æ‚åº¦ | O(1) | O(1) | O(log n) |
| å¹¶å‘è¯»å– | æ— é” | éœ€è¦é” | æ— é” |
| å¹¶å‘å†™å…¥ | ç»†ç²’åº¦é” | ç²—ç²’åº¦é” | æ— é” |
| æœ‰åºæ€§ | æ— åº | å–å†³äºåº•å±‚Map | æœ‰åº |
| nullæ”¯æŒ | âŒ | å–å†³äºåº•å±‚Map | âŒ |
| å†…å­˜å ç”¨ | ä¸­ | ä½ | é«˜ |
| é€‚ç”¨åœºæ™¯ | é«˜å¹¶å‘æ— åºå­˜å‚¨ | ç®€å•åŒæ­¥éœ€æ±‚ | é«˜å¹¶å‘æœ‰åºå­˜å‚¨ |

### æœ€ä½³å®è·µå»ºè®®

**é€‰æ‹©ConcurrentHashMapçš„åœºæ™¯**ï¼š
- é«˜å¹¶å‘çš„é”®å€¼å­˜å‚¨éœ€æ±‚
- è¯»æ“ä½œè¿œå¤šäºå†™æ“ä½œ
- å¯¹æ•°æ®ä¸€è‡´æ€§è¦æ±‚ä¸æ˜¯ç‰¹åˆ«ä¸¥æ ¼
- éœ€è¦é«˜æ€§èƒ½çš„å¹¶å‘è®¿é—®

**æ€§èƒ½ä¼˜åŒ–è¦ç‚¹**ï¼š
- åˆç†é¢„ä¼°åˆå§‹å®¹é‡ï¼Œé¿å…é¢‘ç¹æ‰©å®¹
- é¿å…é¢‘ç¹è°ƒç”¨size()ç­‰å…¨å±€æ“ä½œ
- ä½¿ç”¨åŸå­æ–¹æ³•è€Œä¸æ˜¯å¤åˆæ“ä½œ
- é€‰æ‹©åˆé€‚çš„å¹¶å‘çº§åˆ«
- æ³¨æ„keyçš„hashCodeåˆ†å¸ƒå‡åŒ€æ€§

**çº¿ç¨‹å®‰å…¨å»ºè®®**ï¼š
- ä¼˜å…ˆä½¿ç”¨æä¾›çš„åŸå­æ–¹æ³•
- ç†è§£å¼±ä¸€è‡´æ€§çš„å«ä¹‰å’Œå½±å“
- é¿å…åœ¨è¿­ä»£ä¸­è¿›è¡Œç»“æ„æ€§ä¿®æ”¹
- åˆç†ä½¿ç”¨computeç³»åˆ—æ–¹æ³•

**ä¸å…¶ä»–æ–¹æ¡ˆå¯¹æ¯”**ï¼š
- vs HashMapï¼šéœ€è¦çº¿ç¨‹å®‰å…¨æ—¶é€‰æ‹©ConcurrentHashMap
- vs Hashtableï¼šä»»ä½•æƒ…å†µä¸‹éƒ½ä¼˜å…ˆé€‰æ‹©ConcurrentHashMap
- vs ConcurrentSkipListMapï¼šéœ€è¦æ’åºæ—¶é€‰æ‹©åè€…

ConcurrentHashMapä½œä¸ºJavaå¹¶å‘ç¼–ç¨‹çš„é‡è¦å·¥å…·ï¼Œå…¶ç²¾å¦™çš„è®¾è®¡å’ŒæŒç»­çš„ä¼˜åŒ–ä¸ºé«˜å¹¶å‘åº”ç”¨æä¾›äº†å¼ºå¤§çš„æ”¯æŒã€‚æ·±å…¥ç†è§£å…¶å®ç°åŸç†å’Œä½¿ç”¨æŠ€å·§ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬æ„å»ºæ›´é«˜æ•ˆã€æ›´å®‰å…¨çš„å¹¶å‘ç³»ç»Ÿã€‚