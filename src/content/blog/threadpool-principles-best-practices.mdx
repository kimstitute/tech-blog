---
title: "çº¿ç¨‹æ± åŸç†ä¸æœ€ä½³å®è·µæ·±åº¦è§£æ"
description: "æ·±å…¥è§£æJavaçº¿ç¨‹æ± çš„æ ¸å¿ƒåŸç†ã€ThreadPoolExecutorå‚æ•°è¯¦è§£ã€ä»»åŠ¡è°ƒåº¦æœºåˆ¶å’Œæ‹’ç»ç­–ç•¥ã€‚ç»“åˆå®é™…é¡¹ç›®åœºæ™¯åˆ†æçº¿ç¨‹æ± è°ƒä¼˜ç­–ç•¥ï¼Œæä¾›å®Œæ•´çš„ç›‘æ§æ–¹æ¡ˆå’Œæ•…éšœæ’æŸ¥æŒ‡å—ï¼ŒæŒæ¡é«˜å¹¶å‘ç³»ç»Ÿçš„çº¿ç¨‹æ± è®¾è®¡ã€‚"
pubDate: 2024-12-06
updatedDate: 2024-12-06
tags: ["java", "threadpool", "executor", "concurrent", "performance", "monitoring", "interview", "best-practices"]
categories: ["java-core"]
subject: "å¹¶å‘ç¼–ç¨‹"
draft: false
featured: true
author: "Gerrad Zhang"
location: "æ­¦æ±‰ï¼Œä¸­å›½"
---

## ğŸ¤” é—®é¢˜èƒŒæ™¯ä¸æŠ€æœ¯æ¼”è¿›

### æˆ‘ä»¬è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

åœ¨é«˜å¹¶å‘ç³»ç»Ÿä¸­ï¼Œ**çº¿ç¨‹ç®¡ç†**æ˜¯ä¸€ä¸ªæ ¸å¿ƒæŒ‘æˆ˜ã€‚ç›´æ¥åˆ›å»ºçº¿ç¨‹è™½ç„¶ç®€å•ï¼Œä½†ä¼šå¸¦æ¥ä¸¥é‡çš„æ€§èƒ½å’Œèµ„æºé—®é¢˜ï¼š

- **çº¿ç¨‹åˆ›å»ºå¼€é”€**ï¼šæ¯æ¬¡new Thread()éƒ½éœ€è¦åˆ†é…å†…å­˜ã€åˆå§‹åŒ–æ ˆç©ºé—´
- **èµ„æºæ¶ˆè€—è¿‡å¤§**ï¼šæ— é™åˆ¶åˆ›å»ºçº¿ç¨‹ä¼šè€—å°½ç³»ç»Ÿå†…å­˜å’ŒCPUèµ„æº
- **ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€**ï¼šè¿‡å¤šçº¿ç¨‹å¯¼è‡´é¢‘ç¹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œé™ä½ç³»ç»Ÿæ€§èƒ½
- **éš¾ä»¥ç®¡ç†**ï¼šçº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†å¤æ‚ï¼Œå®¹æ˜“å‡ºç°å†…å­˜æ³„æ¼
- **ç³»ç»Ÿä¸ç¨³å®š**ï¼šçªå‘æµé‡å¯èƒ½åˆ›å»ºå¤§é‡çº¿ç¨‹ï¼Œå¯¼è‡´ç³»ç»Ÿå´©æºƒ

```java
// ç›´æ¥åˆ›å»ºçº¿ç¨‹çš„é—®é¢˜ç¤ºä¾‹
public class DirectThreadProblem {
    
    // âŒ é—®é¢˜ï¼šä¸ºæ¯ä¸ªè¯·æ±‚åˆ›å»ºæ–°çº¿ç¨‹
    public void handleRequest(HttpServletRequest request) {
        new Thread(() -> {
            // å¤„ç†è¯·æ±‚é€»è¾‘
            processRequest(request);
        }).start();
        
        /*
         * é—®é¢˜åˆ†æï¼š
         * 1. é«˜å¹¶å‘æ—¶ä¼šåˆ›å»ºå¤§é‡çº¿ç¨‹
         * 2. çº¿ç¨‹åˆ›å»ºå’Œé”€æ¯å¼€é”€å·¨å¤§
         * 3. ç³»ç»Ÿèµ„æºæ— æ³•æœ‰æ•ˆæ§åˆ¶
         * 4. å¯èƒ½å¯¼è‡´OutOfMemoryError
         */
    }
    
    private void processRequest(HttpServletRequest request) {
        // ä¸šåŠ¡å¤„ç†é€»è¾‘
    }
}
```

### æ²¡æœ‰è¿™ä¸ªæŠ€æœ¯æ—¶æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ

åœ¨çº¿ç¨‹æ± å‡ºç°ä¹‹å‰ï¼Œå¼€å‘è€…ä¸»è¦é€šè¿‡ä»¥ä¸‹æ–¹å¼ç®¡ç†çº¿ç¨‹ï¼š

**1. æ‰‹åŠ¨çº¿ç¨‹ç®¡ç†**
- æ‰‹åŠ¨åˆ›å»ºã€å¯åŠ¨å’Œé”€æ¯çº¿ç¨‹
- **é—®é¢˜**ï¼šä»£ç å¤æ‚ï¼Œå®¹æ˜“å‡ºé”™ï¼Œèµ„æºç®¡ç†å›°éš¾

**2. ç®€å•çš„çº¿ç¨‹å¤ç”¨**
- åˆ›å»ºå›ºå®šæ•°é‡çš„å·¥ä½œçº¿ç¨‹ï¼Œæ‰‹åŠ¨åˆ†é…ä»»åŠ¡
- **é—®é¢˜**ï¼šå®ç°å¤æ‚ï¼Œç¼ºä¹æ ‡å‡†åŒ–ï¼Œæ‰©å±•æ€§å·®

**3. ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼**
- ä½¿ç”¨é˜Ÿåˆ—+å·¥ä½œçº¿ç¨‹çš„æ‰‹å·¥å®ç°
- **é—®é¢˜**ï¼šéœ€è¦å¤„ç†å¤æ‚çš„åŒæ­¥é€»è¾‘ï¼Œå®¹æ˜“æ­»é”

### æŠ€æœ¯æ¼”è¿›çš„å†å²è„‰ç»œ

**JDK 1.5 (2004)**ï¼šjava.util.concurrentåŒ…å¼•å…¥
- å¼•å…¥Executoræ¡†æ¶å’ŒThreadPoolExecutor
- æä¾›æ ‡å‡†åŒ–çš„çº¿ç¨‹æ± å®ç°
- æ”¯æŒå¤šç§é¢„å®šä¹‰çº¿ç¨‹æ± ç±»å‹

**JDK 1.8 (2014)**ï¼šå¹¶è¡Œæµæ”¯æŒ
- å¼•å…¥CompletableFutureå¼‚æ­¥ç¼–ç¨‹
- é»˜è®¤ForkJoinPoolæ”¯æŒå¹¶è¡Œæµ
- å¢å¼ºçº¿ç¨‹æ± ä¸Lambdaè¡¨è¾¾å¼é›†æˆ

**JDK 17+ (2021-ç°åœ¨)**ï¼šè™šæ‹Ÿçº¿ç¨‹æ—¶ä»£
- Project Loomå¼•å…¥è™šæ‹Ÿçº¿ç¨‹ï¼ˆVirtual Threadsï¼‰
- é‡æ–°å®šä¹‰é«˜å¹¶å‘ç¼–ç¨‹æ¨¡å¼
- ä¼ ç»Ÿçº¿ç¨‹æ± ä»æ˜¯æ ¸å¿ƒåŸºç¡€è®¾æ–½

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µä¸åŸç†

### åŸºç¡€æ¦‚å¿µå®šä¹‰

`çº¿ç¨‹æ± ï¼ˆThreadPoolï¼‰`æ˜¯ä¸€ç§åŸºäºæ± åŒ–æŠ€æœ¯çš„çº¿ç¨‹ç®¡ç†æœºåˆ¶ï¼Œé¢„å…ˆåˆ›å»ºä¸€å®šæ•°é‡çš„çº¿ç¨‹ï¼Œé€šè¿‡é‡å¤åˆ©ç”¨è¿™äº›çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ï¼Œé¿å…é¢‘ç¹åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹çš„å¼€é”€ã€‚

**æ ¸å¿ƒç‰¹æ€§**ï¼š
- **çº¿ç¨‹å¤ç”¨**ï¼šé¿å…é¢‘ç¹åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹çš„å¼€é”€
- **èµ„æºæ§åˆ¶**ï¼šé™åˆ¶å¹¶å‘çº¿ç¨‹æ•°é‡ï¼Œé˜²æ­¢èµ„æºè€—å°½
- **ä»»åŠ¡é˜Ÿåˆ—**ï¼šç¼“å†²å¾…æ‰§è¡Œçš„ä»»åŠ¡ï¼Œæ”¯æŒä¸åŒçš„æ’é˜Ÿç­–ç•¥
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šæä¾›å®Œæ•´çš„å¯åŠ¨ã€è¿è¡Œã€å…³é—­ç”Ÿå‘½å‘¨æœŸ

### ThreadPoolExecutoræ ¸å¿ƒæ¶æ„

**çº¿ç¨‹æ± çš„æ ¸å¿ƒç»„ä»¶**ï¼š

```java
/**
 * ThreadPoolExecutoræ ¸å¿ƒæ¶æ„æ¼”ç¤º
 */
public class ThreadPoolArchitectureDemo {
    
    /**
     * æ ‡å‡†çº¿ç¨‹æ± åˆ›å»ºç¤ºä¾‹
     */
    public ThreadPoolExecutor createThreadPool() {
        return new ThreadPoolExecutor(
            5,                          // corePoolSize: æ ¸å¿ƒçº¿ç¨‹æ•°
            10,                         // maximumPoolSize: æœ€å¤§çº¿ç¨‹æ•°
            60L,                        // keepAliveTime: ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´
            TimeUnit.SECONDS,           // unit: æ—¶é—´å•ä½
            new LinkedBlockingQueue<>(100), // workQueue: ä»»åŠ¡é˜Ÿåˆ—
            new ThreadFactoryBuilder()      // threadFactory: çº¿ç¨‹å·¥å‚
                .setNameFormat("worker-%d")
                .build(),
            new ThreadPoolExecutor.CallerRunsPolicy() // handler: æ‹’ç»ç­–ç•¥
        );
    }
    
    /**
     * çº¿ç¨‹æ± çŠ¶æ€ç®¡ç†
     */
    public void explainThreadPoolStates() {
        /*
         * çº¿ç¨‹æ± çŠ¶æ€è½¬æ¢ï¼š
         * 
         * RUNNING:   æ¥å—æ–°ä»»åŠ¡å¹¶å¤„ç†é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
         *     â†“ shutdown()
         * SHUTDOWN:  ä¸æ¥å—æ–°ä»»åŠ¡ï¼Œä½†å¤„ç†é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
         *     â†“ é˜Ÿåˆ—ä¸ºç©ºä¸”å·¥ä½œçº¿ç¨‹ä¸º0
         * TIDYING:   æ‰€æœ‰ä»»åŠ¡å·²ç»ˆæ­¢ï¼Œå·¥ä½œçº¿ç¨‹æ•°ä¸º0
         *     â†“ terminated()é’©å­æ–¹æ³•æ‰§è¡Œå®Œæ¯•
         * TERMINATED: å®Œå…¨ç»ˆæ­¢çŠ¶æ€
         * 
         * ç‰¹æ®Šè·¯å¾„ï¼š
         * RUNNING â†’ shutdownNow() â†’ STOP â†’ TIDYING â†’ TERMINATED
         */
    }
}
```

### çº¿ç¨‹æ± å·¥ä½œåŸç†

**ä»»åŠ¡æäº¤ä¸æ‰§è¡Œæµç¨‹**ï¼š

```java
/**
 * çº¿ç¨‹æ± å·¥ä½œåŸç†è¯¦è§£
 */
public class ThreadPoolWorkingPrinciple {
    
    /**
     * ä»»åŠ¡æäº¤æµç¨‹åˆ†æ
     */
    public void explainTaskSubmissionFlow() {
        /*
         * ä»»åŠ¡æäº¤æµç¨‹ï¼ˆexecuteæ–¹æ³•ï¼‰ï¼š
         * 
         * 1. æ£€æŸ¥æ ¸å¿ƒçº¿ç¨‹æ•°
         *    if (å½“å‰çº¿ç¨‹æ•° < corePoolSize) {
         *        åˆ›å»ºæ–°çš„æ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œä»»åŠ¡
         *        return;
         *    }
         * 
         * 2. å°è¯•åŠ å…¥é˜Ÿåˆ—
         *    if (é˜Ÿåˆ—æœªæ»¡) {
         *        ä»»åŠ¡åŠ å…¥é˜Ÿåˆ—ç­‰å¾…æ‰§è¡Œ
         *        // åŒé‡æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€
         *        return;
         *    }
         * 
         * 3. åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹
         *    if (å½“å‰çº¿ç¨‹æ•° < maximumPoolSize) {
         *        åˆ›å»ºæ–°çš„éæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œä»»åŠ¡
         *        return;
         *    }
         * 
         * 4. æ‰§è¡Œæ‹’ç»ç­–ç•¥
         *    handler.rejectedExecution(task, this);
         */
    }
    
    /**
     * çº¿ç¨‹å›æ”¶æœºåˆ¶
     */
    public void explainThreadRecycling() {
        /*
         * çº¿ç¨‹å›æ”¶æ¡ä»¶ï¼š
         * 
         * 1. æ ¸å¿ƒçº¿ç¨‹å›æ”¶ï¼š
         *    - é»˜è®¤æƒ…å†µä¸‹æ ¸å¿ƒçº¿ç¨‹ä¸ä¼šè¢«å›æ”¶
         *    - è®¾ç½®allowCoreThreadTimeOut(true)åå¯å›æ”¶
         * 
         * 2. éæ ¸å¿ƒçº¿ç¨‹å›æ”¶ï¼š
         *    - ç©ºé—²æ—¶é—´è¶…è¿‡keepAliveTimeè‡ªåŠ¨å›æ”¶
         *    - å›æ”¶åçº¿ç¨‹æ•°ä¸ä¼šä½äºcorePoolSize
         * 
         * 3. å›æ”¶æ—¶æœºï¼š
         *    - çº¿ç¨‹ä»é˜Ÿåˆ—è·å–ä»»åŠ¡è¶…æ—¶
         *    - æ‰§è¡ŒgetTask()æ–¹æ³•è¿”å›null
         *    - çº¿ç¨‹è‡ªç„¶ç»“æŸï¼Œä»workersé›†åˆä¸­ç§»é™¤
         */
    }
    
    /**
     * é˜Ÿåˆ—ç±»å‹ä¸ç‰¹æ€§
     */
    public void explainQueueTypes() {
        // 1. ArrayBlockingQueue - æœ‰ç•Œé˜Ÿåˆ—
        BlockingQueue<Runnable> arrayQueue = new ArrayBlockingQueue<>(100);
        /*
         * ç‰¹ç‚¹ï¼š
         * - åŸºäºæ•°ç»„å®ç°ï¼ŒFIFOé¡ºåº
         * - æœ‰ç•Œé˜Ÿåˆ—ï¼Œé˜²æ­¢å†…å­˜æº¢å‡º
         * - é˜Ÿåˆ—æ»¡æ—¶ä¼šåˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹
         */
        
        // 2. LinkedBlockingQueue - å¯é€‰æœ‰ç•Œé˜Ÿåˆ—
        BlockingQueue<Runnable> linkedQueue = new LinkedBlockingQueue<>(1000);
        /*
         * ç‰¹ç‚¹ï¼š
         * - åŸºäºé“¾è¡¨å®ç°ï¼ŒFIFOé¡ºåº
         * - å¯è®¾ç½®å®¹é‡ï¼Œé»˜è®¤Integer.MAX_VALUE
         * - Executors.newFixedThreadPool()ä½¿ç”¨æ­¤é˜Ÿåˆ—
         */
        
        // 3. SynchronousQueue - ç›´æ¥ä¼ é€’
        BlockingQueue<Runnable> syncQueue = new SynchronousQueue<>();
        /*
         * ç‰¹ç‚¹ï¼š
         * - ä¸å­˜å‚¨ä»»åŠ¡ï¼Œç›´æ¥ä¼ é€’ç»™çº¿ç¨‹
         * - é€‚åˆä»»åŠ¡å¤„ç†é€Ÿåº¦å¿«çš„åœºæ™¯
         * - Executors.newCachedThreadPool()ä½¿ç”¨æ­¤é˜Ÿåˆ—
         */
        
        // 4. PriorityBlockingQueue - ä¼˜å…ˆçº§é˜Ÿåˆ—
        BlockingQueue<Runnable> priorityQueue = new PriorityBlockingQueue<>();
        /*
         * ç‰¹ç‚¹ï¼š
         * - åŸºäºå †å®ç°ï¼Œæ”¯æŒä¼˜å…ˆçº§æ’åº
         * - ä»»åŠ¡éœ€è¦å®ç°Comparableæ¥å£
         * - é€‚åˆæœ‰ä¼˜å…ˆçº§è¦æ±‚çš„åœºæ™¯
         */
    }
}
```

### æ‹’ç»ç­–ç•¥è¯¦è§£

**å››ç§å†…ç½®æ‹’ç»ç­–ç•¥**ï¼š

```java
/**
 * æ‹’ç»ç­–ç•¥è¯¦è§£ä¸è‡ªå®šä¹‰å®ç°
 */
public class RejectionPolicyDemo {
    
    /**
     * å†…ç½®æ‹’ç»ç­–ç•¥æ¼”ç¤º
     */
    public void demonstrateBuiltinPolicies() {
        
        // 1. AbortPolicy - æŠ›å‡ºå¼‚å¸¸ï¼ˆé»˜è®¤ç­–ç•¥ï¼‰
        ThreadPoolExecutor executor1 = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2),
            new ThreadPoolExecutor.AbortPolicy()
        );
        /*
         * è¡Œä¸ºï¼šç›´æ¥æŠ›å‡ºRejectedExecutionException
         * é€‚ç”¨åœºæ™¯ï¼šå¸Œæœ›å¿«é€Ÿå¤±è´¥ï¼Œç”±è°ƒç”¨è€…å¤„ç†å¼‚å¸¸
         */
        
        // 2. CallerRunsPolicy - è°ƒç”¨è€…è¿è¡Œ
        ThreadPoolExecutor executor2 = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        /*
         * è¡Œä¸ºï¼šç”±æäº¤ä»»åŠ¡çš„çº¿ç¨‹ç›´æ¥æ‰§è¡Œä»»åŠ¡
         * é€‚ç”¨åœºæ™¯ï¼šä¿è¯ä»»åŠ¡ä¸ä¸¢å¤±ï¼Œä½†ä¼šé™ä½æäº¤é€Ÿåº¦
         */
        
        // 3. DiscardPolicy - é™é»˜ä¸¢å¼ƒ
        ThreadPoolExecutor executor3 = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2),
            new ThreadPoolExecutor.DiscardPolicy()
        );
        /*
         * è¡Œä¸ºï¼šé™é»˜ä¸¢å¼ƒä»»åŠ¡ï¼Œä¸æŠ›å‡ºå¼‚å¸¸
         * é€‚ç”¨åœºæ™¯ï¼šä»»åŠ¡å¯ä»¥ä¸¢å¤±çš„åœºæ™¯ï¼Œå¦‚æ—¥å¿—è®°å½•
         */
        
        // 4. DiscardOldestPolicy - ä¸¢å¼ƒæœ€è€ä»»åŠ¡
        ThreadPoolExecutor executor4 = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2),
            new ThreadPoolExecutor.DiscardOldestPolicy()
        );
        /*
         * è¡Œä¸ºï¼šä¸¢å¼ƒé˜Ÿåˆ—ä¸­æœ€è€çš„ä»»åŠ¡ï¼Œç„¶åé‡è¯•æäº¤
         * é€‚ç”¨åœºæ™¯ï¼šå¸Œæœ›æ‰§è¡Œæœ€æ–°çš„ä»»åŠ¡
         */
    }
    
    /**
     * è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥
     */
    public static class CustomRejectedExecutionHandler implements RejectedExecutionHandler {
        
        private static final Logger logger = LoggerFactory.getLogger(CustomRejectedExecutionHandler.class);
        
        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            // è®°å½•æ‹’ç»æ—¥å¿—
            logger.warn("Task {} rejected from {}", r.toString(), executor.toString());
            
            // å°è¯•æ”¾å…¥å¤‡ç”¨é˜Ÿåˆ—
            if (!trySubmitToBackupQueue(r)) {
                // å‘é€å‘Šè­¦é€šçŸ¥
                sendAlertNotification(r, executor);
                
                // æœ€åé€‰æ‹©ï¼šç”±è°ƒç”¨è€…æ‰§è¡Œï¼ˆä¿è¯ä»»åŠ¡ä¸ä¸¢å¤±ï¼‰
                if (!executor.isShutdown()) {
                    r.run();
                }
            }
        }
        
        private boolean trySubmitToBackupQueue(Runnable task) {
            // å°è¯•æäº¤åˆ°å¤‡ç”¨é˜Ÿåˆ—æˆ–å…¶ä»–çº¿ç¨‹æ± 
            return false; // ç®€åŒ–ç¤ºä¾‹
        }
        
        private void sendAlertNotification(Runnable task, ThreadPoolExecutor executor) {
            // å‘é€ç›‘æ§å‘Šè­¦
            logger.error("ThreadPool overload! Current pool size: {}, Queue size: {}", 
                        executor.getPoolSize(), executor.getQueue().size());
        }
    }
}
```

## ğŸ”§ å®ç°åŸç†ä¸æºç åˆ†æ

### ThreadPoolExecutoræºç æ ¸å¿ƒé€»è¾‘

**çº¿ç¨‹æ± çŠ¶æ€ç®¡ç†çš„åŸå­æ“ä½œ**ï¼š

```java
/**
 * ThreadPoolExecutoræºç æ ¸å¿ƒåˆ†æ
 */
public class ThreadPoolExecutorSourceAnalysis {
    
    /**
     * çº¿ç¨‹æ± çŠ¶æ€çš„åŸå­ç®¡ç†
     */
    public void explainAtomicStateManagement() {
        /*
         * ThreadPoolExecutorä½¿ç”¨ä¸€ä¸ªAtomicIntegeræ¥åŒæ—¶ç®¡ç†ï¼š
         * 1. çº¿ç¨‹æ± çŠ¶æ€ (é«˜3ä½)
         * 2. å·¥ä½œçº¿ç¨‹æ•° (ä½29ä½)
         * 
         * private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
         * 
         * çŠ¶æ€å€¼å®šä¹‰ï¼š
         * RUNNING    = -1 << COUNT_BITS; // 11100000...000
         * SHUTDOWN   =  0 << COUNT_BITS; // 00000000...000  
         * STOP       =  1 << COUNT_BITS; // 00100000...000
         * TIDYING    =  2 << COUNT_BITS; // 01000000...000
         * TERMINATED =  3 << COUNT_BITS; // 01100000...000
         */
    }
    
    /**
     * executeæ–¹æ³•çš„æ ¸å¿ƒé€»è¾‘
     */
    public void analyzeExecuteMethod() {
        /*
         * public void execute(Runnable command) {
         *     int c = ctl.get();
         *     
         *     // æ­¥éª¤1: æ£€æŸ¥æ ¸å¿ƒçº¿ç¨‹æ•°
         *     if (workerCountOf(c) < corePoolSize) {
         *         if (addWorker(command, true))
         *             return;
         *         c = ctl.get();
         *     }
         *     
         *     // æ­¥éª¤2: å°è¯•åŠ å…¥é˜Ÿåˆ—
         *     if (isRunning(c) && workQueue.offer(command)) {
         *         int recheck = ctl.get();
         *         if (!isRunning(recheck) && remove(command))
         *             reject(command);
         *         else if (workerCountOf(recheck) == 0)
         *             addWorker(null, false);
         *     }
         *     
         *     // æ­¥éª¤3: å°è¯•åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹
         *     else if (!addWorker(command, false))
         *         reject(command);
         * }
         */
    }
    
    /**
     * Workerå†…éƒ¨ç±»åˆ†æ
     */
    public void analyzeWorkerClass() {
        /*
         * Workerç±»ç»§æ‰¿è‡ªAQSï¼Œå®ç°äº†Runnableæ¥å£ï¼š
         * 
         * private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
         *     final Thread thread;        // å·¥ä½œçº¿ç¨‹
         *     Runnable firstTask;         // é¦–æ¬¡æ‰§è¡Œçš„ä»»åŠ¡
         *     volatile long completedTasks; // å®Œæˆçš„ä»»åŠ¡æ•°
         *     
         *     // Workeræœ¬èº«ä½œä¸ºé”ï¼Œæ§åˆ¶çº¿ç¨‹çš„ä¸­æ–­
         *     protected boolean tryAcquire(int unused) {
         *         if (compareAndSetState(0, 1)) {
         *             setExclusiveOwnerThread(Thread.currentThread());
         *             return true;
         *         }
         *         return false;
         *     }
         * }
         * 
         * è®¾è®¡å·§æ€ï¼š
         * 1. Workerç»§æ‰¿AQSå®ç°ç‹¬å é”ï¼Œé˜²æ­¢ä»»åŠ¡æ‰§è¡Œæ—¶è¢«ä¸­æ–­
         * 2. åˆå§‹state=-1ï¼Œé˜²æ­¢åœ¨runWorkerå‰è¢«ä¸­æ–­
         * 3. æ¯ä¸ªWorkeråŒ…è£…ä¸€ä¸ªThreadï¼Œå®ç°çº¿ç¨‹å¤ç”¨
         */
    }
}
```

### çº¿ç¨‹æ± çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†

**ä¼˜é›…å…³é—­æœºåˆ¶è¯¦è§£**ï¼š

```java
/**
 * çº¿ç¨‹æ± ç”Ÿå‘½å‘¨æœŸç®¡ç†
 */
public class ThreadPoolLifecycleManagement {
    
    /**
     * ä¼˜é›…å…³é—­çº¿ç¨‹æ± 
     */
    public void gracefulShutdown(ThreadPoolExecutor executor) {
        try {
            // 1. åœæ­¢æ¥æ”¶æ–°ä»»åŠ¡
            executor.shutdown();
            
            // 2. ç­‰å¾…å·²æäº¤ä»»åŠ¡å®Œæˆ
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                // 3. è¶…æ—¶åå¼ºåˆ¶å…³é—­
                List<Runnable> pendingTasks = executor.shutdownNow();
                logger.warn("å¼ºåˆ¶å…³é—­çº¿ç¨‹æ± ï¼Œæœªæ‰§è¡Œçš„ä»»åŠ¡æ•°: {}", pendingTasks.size());
                
                // 4. å†æ¬¡ç­‰å¾…ä¸€æ®µæ—¶é—´
                if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                    logger.error("çº¿ç¨‹æ± æ— æ³•æ­£å¸¸å…³é—­");
                }
            }
        } catch (InterruptedException e) {
            // 5. å½“å‰çº¿ç¨‹è¢«ä¸­æ–­ï¼Œå¼ºåˆ¶å…³é—­
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
    
    /**
     * çº¿ç¨‹æ± çŠ¶æ€æ£€æŸ¥
     */
    public void checkThreadPoolStatus(ThreadPoolExecutor executor) {
        // åŸºæœ¬çŠ¶æ€ä¿¡æ¯
        logger.info("çº¿ç¨‹æ± çŠ¶æ€æ£€æŸ¥:");
        logger.info("- æ˜¯å¦å…³é—­: {}", executor.isShutdown());
        logger.info("- æ˜¯å¦ç»ˆæ­¢: {}", executor.isTerminated());
        logger.info("- æ˜¯å¦æ­£åœ¨ç»ˆæ­¢: {}", executor.isTerminating());
        
        // çº¿ç¨‹æ•°é‡ä¿¡æ¯
        logger.info("- å½“å‰çº¿ç¨‹æ•°: {}", executor.getPoolSize());
        logger.info("- æ ¸å¿ƒçº¿ç¨‹æ•°: {}", executor.getCorePoolSize());
        logger.info("- æœ€å¤§çº¿ç¨‹æ•°: {}", executor.getMaximumPoolSize());
        logger.info("- æ´»è·ƒçº¿ç¨‹æ•°: {}", executor.getActiveCount());
        
        // ä»»åŠ¡æ‰§è¡Œä¿¡æ¯
        logger.info("- å·²å®Œæˆä»»åŠ¡æ•°: {}", executor.getCompletedTaskCount());
        logger.info("- æ€»ä»»åŠ¡æ•°: {}", executor.getTaskCount());
        logger.info("- é˜Ÿåˆ—ä¸­ä»»åŠ¡æ•°: {}", executor.getQueue().size());
    }
}
```

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹ä¸ä»£ç ç¤ºä¾‹

### å…·ä½“é¡¹ç›®åº”ç”¨

**åœºæ™¯1ï¼šWebåº”ç”¨å¼‚æ­¥ä»»åŠ¡å¤„ç†**

```java
/**
 * Webåº”ç”¨å¼‚æ­¥ä»»åŠ¡å¤„ç†çº¿ç¨‹æ± é…ç½®
 */
@Configuration
@EnableAsync
public class AsyncThreadPoolConfig {
    
    /**
     * å¼‚æ­¥ä»»åŠ¡çº¿ç¨‹æ± 
     */
    @Bean("asyncTaskExecutor")
    public ThreadPoolExecutor asyncTaskExecutor() {
        // è·å–CPUæ ¸å¿ƒæ•°
        int coreSize = Runtime.getRuntime().availableProcessors();
        
        return new ThreadPoolExecutor(
            coreSize,                           // æ ¸å¿ƒçº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•°
            coreSize * 2,                       // æœ€å¤§çº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° * 2
            60L,                                // ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(200),     // æœ‰ç•Œé˜Ÿåˆ—ï¼Œé˜²æ­¢å†…å­˜æº¢å‡º
            new ThreadFactoryBuilder()
                .setNameFormat("async-task-%d")
                .setDaemon(false)               // éå®ˆæŠ¤çº¿ç¨‹ï¼Œç¡®ä¿ä»»åŠ¡å®Œæˆ
                .build(),
            new ThreadPoolExecutor.CallerRunsPolicy() // è°ƒç”¨è€…è¿è¡Œç­–ç•¥
        );
    }
    
    /**
     * é…ç½®å¼‚æ­¥æ‰§è¡Œå™¨
     */
    @Override
    public void configureAsyncSupport(AsyncConfigurer configurer) {
        configurer.setTaskExecutor(asyncTaskExecutor());
        
        // å¼‚æ­¥å¼‚å¸¸å¤„ç†
        configurer.setAsyncUncaughtExceptionHandler(
            (throwable, method, objects) -> {
                logger.error("å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸: method={}, params={}", 
                           method.getName(), Arrays.toString(objects), throwable);
                
                // å‘é€å‘Šè­¦é€šçŸ¥
                sendAlertNotification(throwable, method);
            }
        );
    }
}

/**
 * å¼‚æ­¥ä»»åŠ¡æœåŠ¡
 */
@Service
public class AsyncTaskService {
    
    @Async("asyncTaskExecutor")
    public CompletableFuture<String> processLongRunningTask(String taskId) {
        try {
            logger.info("å¼€å§‹å¤„ç†é•¿æ—¶é—´ä»»åŠ¡: {}", taskId);
            
            // æ¨¡æ‹Ÿé•¿æ—¶é—´å¤„ç†
            Thread.sleep(5000);
            
            String result = "ä»»åŠ¡ " + taskId + " å¤„ç†å®Œæˆ";
            logger.info("ä»»åŠ¡å¤„ç†å®Œæˆ: {}", result);
            
            return CompletableFuture.completedFuture(result);
            
        } catch (Exception e) {
            logger.error("ä»»åŠ¡å¤„ç†å¤±è´¥: {}", taskId, e);
            return CompletableFuture.failedFuture(e);
        }
    }
    
    @Async("asyncTaskExecutor")
    public void sendEmailNotification(String email, String content) {
        try {
            // å‘é€é‚®ä»¶é€»è¾‘
            emailService.sendEmail(email, content);
            logger.info("é‚®ä»¶å‘é€æˆåŠŸ: {}", email);
        } catch (Exception e) {
            logger.error("é‚®ä»¶å‘é€å¤±è´¥: {}", email, e);
        }
    }
}
```

**åœºæ™¯2ï¼šæ‰¹é‡æ•°æ®å¤„ç†çº¿ç¨‹æ± **

```java
/**
 * æ‰¹é‡æ•°æ®å¤„ç†çº¿ç¨‹æ± 
 */
@Component
public class BatchDataProcessor {
    
    private final ThreadPoolExecutor batchExecutor;
    private final DataService dataService;
    
    public BatchDataProcessor(DataService dataService) {
        this.dataService = dataService;
        this.batchExecutor = createBatchExecutor();
    }
    
    private ThreadPoolExecutor createBatchExecutor() {
        return new ThreadPoolExecutor(
            4,                                  // æ ¸å¿ƒçº¿ç¨‹æ•°
            8,                                  // æœ€å¤§çº¿ç¨‹æ•°  
            300L,                               // ç©ºé—²æ—¶é—´5åˆ†é’Ÿ
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(500),      // æœ‰ç•Œé˜Ÿåˆ—
            new ThreadFactoryBuilder()
                .setNameFormat("batch-processor-%d")
                .setUncaughtExceptionHandler((t, e) -> {
                    logger.error("æ‰¹å¤„ç†çº¿ç¨‹å¼‚å¸¸: {}", t.getName(), e);
                })
                .build(),
            new CustomRejectedExecutionHandler() // è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥
        );
    }
    
    /**
     * æ‰¹é‡å¤„ç†æ•°æ®
     */
    public CompletableFuture<BatchResult> processBatchData(List<DataItem> dataItems) {
        // åˆ†æ‰¹å¤„ç†ï¼Œæ¯æ‰¹1000æ¡
        int batchSize = 1000;
        List<List<DataItem>> batches = partition(dataItems, batchSize);
        
        // æäº¤æ‰€æœ‰æ‰¹æ¬¡ä»»åŠ¡
        List<CompletableFuture<Integer>> futures = batches.stream()
            .map(batch -> CompletableFuture.supplyAsync(() -> {
                return processBatch(batch);
            }, batchExecutor))
            .collect(Collectors.toList());
        
        // ç­‰å¾…æ‰€æœ‰æ‰¹æ¬¡å®Œæˆ
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> {
                int totalProcessed = futures.stream()
                    .mapToInt(CompletableFuture::join)
                    .sum();
                
                return new BatchResult(totalProcessed, dataItems.size());
            });
    }
    
    private int processBatch(List<DataItem> batch) {
        try {
            // æ‰¹é‡å¤„ç†é€»è¾‘
            dataService.batchInsert(batch);
            logger.info("æ‰¹æ¬¡å¤„ç†å®Œæˆï¼Œæ•°é‡: {}", batch.size());
            return batch.size();
        } catch (Exception e) {
            logger.error("æ‰¹æ¬¡å¤„ç†å¤±è´¥ï¼Œæ•°é‡: {}", batch.size(), e);
            throw new RuntimeException("æ‰¹å¤„ç†å¤±è´¥", e);
        }
    }
    
    private <T> List<List<T>> partition(List<T> list, int size) {
        return IntStream.range(0, (list.size() + size - 1) / size)
            .mapToObj(i -> list.subList(i * size, Math.min((i + 1) * size, list.size())))
            .collect(Collectors.toList());
    }
    
    /**
     * è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥
     */
    private static class CustomRejectedExecutionHandler implements RejectedExecutionHandler {
        @Override
        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
            logger.warn("æ‰¹å¤„ç†ä»»åŠ¡è¢«æ‹’ç»ï¼Œå½“å‰é˜Ÿåˆ—å¤§å°: {}", executor.getQueue().size());
            
            // å°è¯•ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡æ–°æäº¤
            try {
                Thread.sleep(100);
                if (!executor.isShutdown()) {
                    executor.execute(r);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RejectedExecutionException("ä»»åŠ¡æäº¤è¢«ä¸­æ–­", e);
            }
        }
    }
    
    @PreDestroy
    public void shutdown() {
        logger.info("å¼€å§‹å…³é—­æ‰¹å¤„ç†çº¿ç¨‹æ± ");
        
        batchExecutor.shutdown();
        try {
            if (!batchExecutor.awaitTermination(60, TimeUnit.SECONDS)) {
                batchExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            batchExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        
        logger.info("æ‰¹å¤„ç†çº¿ç¨‹æ± å·²å…³é—­");
    }
}

## ğŸ¯ é¢è¯•é«˜é¢‘é—®é¢˜ç²¾è®²

### æ ¸å¿ƒé¢è¯•é—®é¢˜è§£æ

#### 1. çº¿ç¨‹æ± çš„æ ¸å¿ƒå‚æ•°æœ‰å“ªäº›ï¼Ÿå¦‚ä½•è®¾ç½®ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
ThreadPoolExecutoræœ‰7ä¸ªæ ¸å¿ƒå‚æ•°ï¼š

```java
public ThreadPoolExecutor(
    int corePoolSize,           // æ ¸å¿ƒçº¿ç¨‹æ•°
    int maximumPoolSize,        // æœ€å¤§çº¿ç¨‹æ•°
    long keepAliveTime,         // ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´
    TimeUnit unit,              // æ—¶é—´å•ä½
    BlockingQueue<Runnable> workQueue,  // ä»»åŠ¡é˜Ÿåˆ—
    ThreadFactory threadFactory,         // çº¿ç¨‹å·¥å‚
    RejectedExecutionHandler handler     // æ‹’ç»ç­–ç•¥
)
```

**å‚æ•°è®¾ç½®åŸåˆ™**ï¼š
- **CPUå¯†é›†å‹**ï¼šcorePoolSize = CPUæ ¸å¿ƒæ•° + 1
- **IOå¯†é›†å‹**ï¼šcorePoolSize = CPUæ ¸å¿ƒæ•° * 2
- **æ··åˆå‹**ï¼šæ ¹æ®å®é™…æµ‹è¯•è°ƒä¼˜

#### 2. çº¿ç¨‹æ± çš„æ‰§è¡Œæµç¨‹æ˜¯ä»€ä¹ˆï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
çº¿ç¨‹æ± ä»»åŠ¡æäº¤çš„å®Œæ•´æµç¨‹ï¼š

1. **æ£€æŸ¥æ ¸å¿ƒçº¿ç¨‹æ•°**ï¼šå½“å‰çº¿ç¨‹æ•° < corePoolSizeï¼Œåˆ›å»ºæ ¸å¿ƒçº¿ç¨‹
2. **å°è¯•åŠ å…¥é˜Ÿåˆ—**ï¼šæ ¸å¿ƒçº¿ç¨‹éƒ½å¿™ç¢Œï¼Œä»»åŠ¡è¿›å…¥é˜Ÿåˆ—ç­‰å¾…
3. **åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹**ï¼šé˜Ÿåˆ—æ»¡äº†ä¸”å½“å‰çº¿ç¨‹æ•° < maximumPoolSizeï¼Œåˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹
4. **æ‰§è¡Œæ‹’ç»ç­–ç•¥**ï¼šæ— æ³•åˆ›å»ºæ–°çº¿ç¨‹æ—¶ï¼Œæ‰§è¡Œæ‹’ç»ç­–ç•¥

#### 3. å¸¸è§çš„çº¿ç¨‹æ± ç±»å‹æœ‰å“ªäº›ï¼Ÿå„è‡ªçš„ç‰¹ç‚¹ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š

| çº¿ç¨‹æ± ç±»å‹ | æ ¸å¿ƒçº¿ç¨‹æ•° | æœ€å¤§çº¿ç¨‹æ•° | é˜Ÿåˆ—ç±»å‹ | é€‚ç”¨åœºæ™¯ |
|-----------|-----------|-----------|----------|----------|
| FixedThreadPool | n | n | LinkedBlockingQueue | å›ºå®šè´Ÿè½½ |
| CachedThreadPool | 0 | Integer.MAX_VALUE | SynchronousQueue | çŸ­ä»»åŠ¡ |
| SingleThreadExecutor | 1 | 1 | LinkedBlockingQueue | é¡ºåºæ‰§è¡Œ |
| ScheduledThreadPool | n | Integer.MAX_VALUE | DelayedWorkQueue | å®šæ—¶ä»»åŠ¡ |

**âš ï¸ æ³¨æ„**ï¼šé˜¿é‡Œå·´å·´å¼€å‘æ‰‹å†Œå»ºè®®ä¸ä½¿ç”¨Executorsåˆ›å»ºçº¿ç¨‹æ± ï¼Œè€Œæ˜¯æ‰‹åŠ¨åˆ›å»ºThreadPoolExecutorã€‚

#### 4. å¦‚ä½•åˆç†è®¾ç½®çº¿ç¨‹æ± å¤§å°ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
çº¿ç¨‹æ± å¤§å°è®¾ç½®éœ€è¦è€ƒè™‘å¤šä¸ªå› ç´ ï¼š

```java
/**
 * çº¿ç¨‹æ± å¤§å°è®¡ç®—å…¬å¼
 */
public class ThreadPoolSizeCalculation {
    
    /**
     * CPUå¯†é›†å‹ä»»åŠ¡
     * çº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° + 1
     */
    public int calculateCpuIntensivePoolSize() {
        return Runtime.getRuntime().availableProcessors() + 1;
    }
    
    /**
     * IOå¯†é›†å‹ä»»åŠ¡
     * çº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° / (1 - é˜»å¡ç³»æ•°)
     * é˜»å¡ç³»æ•° = é˜»å¡æ—¶é—´ / (é˜»å¡æ—¶é—´ + è®¡ç®—æ—¶é—´)
     */
    public int calculateIoIntensivePoolSize(double blockingCoefficient) {
        int cpuCores = Runtime.getRuntime().availableProcessors();
        return (int) (cpuCores / (1 - blockingCoefficient));
    }
    
    /**
     * å®é™…é¡¹ç›®ä¸­çš„ç»éªŒå€¼
     */
    public int calculatePracticalPoolSize() {
        int cpuCores = Runtime.getRuntime().availableProcessors();
        
        // Webåº”ç”¨å¸¸ç”¨é…ç½®
        return Math.max(cpuCores, 8);  // æœ€å°‘8ä¸ªçº¿ç¨‹
    }
}
```

#### 5. çº¿ç¨‹æ± æœ‰å“ªäº›çŠ¶æ€ï¼Ÿå¦‚ä½•è½¬æ¢ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆ**ï¼š
çº¿ç¨‹æ± æœ‰5ç§çŠ¶æ€ï¼š

- **RUNNING**ï¼šæ¥å—æ–°ä»»åŠ¡å¹¶å¤„ç†é˜Ÿåˆ—ä»»åŠ¡
- **SHUTDOWN**ï¼šä¸æ¥å—æ–°ä»»åŠ¡ï¼Œä½†å¤„ç†é˜Ÿåˆ—ä»»åŠ¡
- **STOP**ï¼šä¸æ¥å—æ–°ä»»åŠ¡ï¼Œä¸å¤„ç†é˜Ÿåˆ—ä»»åŠ¡ï¼Œä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
- **TIDYING**ï¼šæ‰€æœ‰ä»»åŠ¡å·²ç»ˆæ­¢ï¼Œçº¿ç¨‹æ•°ä¸º0
- **TERMINATED**ï¼šterminated()æ–¹æ³•æ‰§è¡Œå®Œæ¯•

**çŠ¶æ€è½¬æ¢**ï¼š
```
RUNNING â†’ shutdown() â†’ SHUTDOWN â†’ TIDYING â†’ TERMINATED
RUNNING â†’ shutdownNow() â†’ STOP â†’ TIDYING â†’ TERMINATED
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹

### çº¿ç¨‹æ± è°ƒä¼˜ç­–ç•¥

**1. å‚æ•°è°ƒä¼˜æŒ‡å—**ï¼š

```java
/**
 * çº¿ç¨‹æ± å‚æ•°è°ƒä¼˜
 */
public class ThreadPoolTuning {
    
    /**
     * ç”Ÿäº§ç¯å¢ƒçº¿ç¨‹æ± é…ç½®
     */
    public ThreadPoolExecutor createProductionThreadPool() {
        // åŸºäºç³»ç»Ÿèµ„æºåŠ¨æ€è®¡ç®—
        int cpuCores = Runtime.getRuntime().availableProcessors();
        long maxMemory = Runtime.getRuntime().maxMemory();
        
        return new ThreadPoolExecutor(
            Math.max(cpuCores, 8),              // æ ¸å¿ƒçº¿ç¨‹æ•°ï¼šæœ€å°‘8ä¸ª
            cpuCores * 4,                       // æœ€å¤§çº¿ç¨‹æ•°ï¼šCPU * 4
            300L,                               // ç©ºé—²æ—¶é—´ï¼š5åˆ†é’Ÿ
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(1000),     // æœ‰ç•Œé˜Ÿåˆ—ï¼š1000ä¸ªä»»åŠ¡
            new NamedThreadFactory("business"), // å‘½åçº¿ç¨‹å·¥å‚
            new MonitoredRejectedHandler()      // ç›‘æ§æ‹’ç»ç­–ç•¥
        );
    }
    
    /**
     * åŠ¨æ€è°ƒæ•´çº¿ç¨‹æ± å‚æ•°
     */
    public void dynamicTuning(ThreadPoolExecutor executor) {
        // ç›‘æ§æŒ‡æ ‡
        double queueUsageRate = (double) executor.getQueue().size() / 1000;
        double threadUsageRate = (double) executor.getActiveCount() / executor.getMaximumPoolSize();
        
        // é˜Ÿåˆ—ä½¿ç”¨ç‡è¿‡é«˜ï¼Œå¢åŠ çº¿ç¨‹æ•°
        if (queueUsageRate > 0.8) {
            int newMaxSize = Math.min(executor.getMaximumPoolSize() + 2, 50);
            executor.setMaximumPoolSize(newMaxSize);
            logger.info("å¢åŠ æœ€å¤§çº¿ç¨‹æ•°åˆ°: {}", newMaxSize);
        }
        
        // çº¿ç¨‹ä½¿ç”¨ç‡è¿‡ä½ï¼Œå‡å°‘æ ¸å¿ƒçº¿ç¨‹æ•°
        if (threadUsageRate < 0.2 && executor.getCorePoolSize() > 4) {
            int newCoreSize = Math.max(executor.getCorePoolSize() - 1, 4);
            executor.setCorePoolSize(newCoreSize);
            logger.info("å‡å°‘æ ¸å¿ƒçº¿ç¨‹æ•°åˆ°: {}", newCoreSize);
        }
    }
}
```

**2. ç›‘æ§ä¸å‘Šè­¦**ï¼š

```java
/**
 * çº¿ç¨‹æ± ç›‘æ§
 */
@Component
public class ThreadPoolMonitor {
    
    private final MeterRegistry meterRegistry;
    private final Map<String, ThreadPoolExecutor> threadPools = new ConcurrentHashMap<>();
    
    public ThreadPoolMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        startMonitoring();
    }
    
    /**
     * æ³¨å†Œçº¿ç¨‹æ± ç›‘æ§
     */
    public void registerThreadPool(String name, ThreadPoolExecutor executor) {
        threadPools.put(name, executor);
        
        // æ³¨å†ŒMicrometeræŒ‡æ ‡
        Gauge.builder("threadpool.core.size")
            .tag("pool", name)
            .register(meterRegistry, executor, ThreadPoolExecutor::getCorePoolSize);
            
        Gauge.builder("threadpool.active.count")
            .tag("pool", name)
            .register(meterRegistry, executor, ThreadPoolExecutor::getActiveCount);
            
        Gauge.builder("threadpool.queue.size")
            .tag("pool", name)
            .register(meterRegistry, executor, e -> e.getQueue().size());
    }
    
    /**
     * å®šæœŸç›‘æ§æ£€æŸ¥
     */
    @Scheduled(fixedDelay = 30000) // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
    public void monitorThreadPools() {
        threadPools.forEach((name, executor) -> {
            ThreadPoolMetrics metrics = collectMetrics(name, executor);
            
            // æ£€æŸ¥å‘Šè­¦æ¡ä»¶
            checkAlerts(name, metrics);
            
            // è®°å½•ç›‘æ§æ—¥å¿—
            logger.info("çº¿ç¨‹æ± ç›‘æ§ [{}]: {}", name, metrics);
        });
    }
    
    private ThreadPoolMetrics collectMetrics(String name, ThreadPoolExecutor executor) {
        return ThreadPoolMetrics.builder()
            .poolName(name)
            .coreSize(executor.getCorePoolSize())
            .maxSize(executor.getMaximumPoolSize())
            .activeCount(executor.getActiveCount())
            .poolSize(executor.getPoolSize())
            .queueSize(executor.getQueue().size())
            .completedTaskCount(executor.getCompletedTaskCount())
            .build();
    }
    
    private void checkAlerts(String name, ThreadPoolMetrics metrics) {
        // é˜Ÿåˆ—ç§¯å‹å‘Šè­¦
        if (metrics.getQueueSize() > 800) {
            sendAlert("çº¿ç¨‹æ± é˜Ÿåˆ—ç§¯å‹", name, "é˜Ÿåˆ—å¤§å°: " + metrics.getQueueSize());
        }
        
        // çº¿ç¨‹æ•°é‡å‘Šè­¦
        if (metrics.getActiveCount() >= metrics.getMaxSize() * 0.9) {
            sendAlert("çº¿ç¨‹æ± æ¥è¿‘æ»¡è½½", name, "æ´»è·ƒçº¿ç¨‹: " + metrics.getActiveCount());
        }
        
        // æ‹’ç»ä»»åŠ¡å‘Šè­¦
        long rejectedCount = getRejectedCount(name);
        if (rejectedCount > 0) {
            sendAlert("çº¿ç¨‹æ± æ‹’ç»ä»»åŠ¡", name, "æ‹’ç»æ•°é‡: " + rejectedCount);
        }
    }
}
```

### å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

**1. å†…å­˜æ³„æ¼é—®é¢˜**ï¼š

```java
/**
 * çº¿ç¨‹æ± å†…å­˜æ³„æ¼é˜²èŒƒ
 */
public class ThreadPoolMemoryLeakPrevention {
    
    /**
     * æ­£ç¡®çš„çº¿ç¨‹æ± å…³é—­
     */
    @PreDestroy
    public void shutdownThreadPools() {
        // 1. åœæ­¢æ¥æ”¶æ–°ä»»åŠ¡
        executor.shutdown();
        
        try {
            // 2. ç­‰å¾…ç°æœ‰ä»»åŠ¡å®Œæˆ
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                // 3. å¼ºåˆ¶å…³é—­
                List<Runnable> pendingTasks = executor.shutdownNow();
                logger.warn("å¼ºåˆ¶å…³é—­çº¿ç¨‹æ± ï¼Œä¸¢å¤±ä»»åŠ¡: {}", pendingTasks.size());
                
                // 4. æœ€åç­‰å¾…
                if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                    logger.error("çº¿ç¨‹æ± æ— æ³•æ­£å¸¸å…³é—­");
                }
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
    
    /**
     * é¿å…ThreadLocalæ³„æ¼
     */
    public void preventThreadLocalLeak() {
        executor.execute(() -> {
            try {
                // è®¾ç½®ThreadLocal
                UserContext.set(getCurrentUser());
                
                // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
                doBusinessLogic();
                
            } finally {
                // é‡è¦ï¼šæ¸…ç†ThreadLocal
                UserContext.clear();
            }
        });
    }
}
```

## ğŸ“š æ€»ç»“ä¸æŠ€æœ¯å¯¹æ¯”

### æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **çº¿ç¨‹æ± è§£å†³çº¿ç¨‹ç®¡ç†é—®é¢˜**ï¼šé¿å…é¢‘ç¹åˆ›å»ºé”€æ¯çº¿ç¨‹ï¼Œæä¾›èµ„æºæ§åˆ¶
2. **æ ¸å¿ƒå‚æ•°ç†è§£**ï¼šcorePoolSizeã€maximumPoolSizeã€workQueueã€rejectedHandler
3. **æ‰§è¡Œæµç¨‹æŒæ¡**ï¼šæ ¸å¿ƒçº¿ç¨‹ â†’ é˜Ÿåˆ— â†’ éæ ¸å¿ƒçº¿ç¨‹ â†’ æ‹’ç»ç­–ç•¥
4. **åˆç†å‚æ•°è®¾ç½®**ï¼šCPUå¯†é›†å‹(CPU+1)ã€IOå¯†é›†å‹(CPU*2)ã€å®é™…æµ‹è¯•è°ƒä¼˜
5. **ç›‘æ§ä¸è°ƒä¼˜**ï¼šå®æ—¶ç›‘æ§å…³é”®æŒ‡æ ‡ï¼ŒåŠ¨æ€è°ƒæ•´å‚æ•°ï¼ŒåŠæ—¶å‘Šè­¦

### çº¿ç¨‹æ± ç±»å‹é€‰æ‹©æŒ‡å—

| åœºæ™¯ç±»å‹ | æ¨èé…ç½® | æ ¸å¿ƒå‚æ•° | æ³¨æ„äº‹é¡¹ |
|---------|---------|----------|----------|
| Webè¯·æ±‚å¤„ç† | è‡ªå®šä¹‰ThreadPoolExecutor | core=CPUæ•°, max=CPU*2 | æœ‰ç•Œé˜Ÿåˆ—é˜²OOM |
| å¼‚æ­¥ä»»åŠ¡ | è‡ªå®šä¹‰ThreadPoolExecutor | æ ¹æ®ä»»åŠ¡ç‰¹æ€§è°ƒæ•´ | åˆç†æ‹’ç»ç­–ç•¥ |
| å®šæ—¶ä»»åŠ¡ | ScheduledThreadPoolExecutor | æ ¹æ®ä»»åŠ¡æ•°é‡ | æ³¨æ„ä»»åŠ¡å¼‚å¸¸å¤„ç† |
| æ‰¹é‡å¤„ç† | ForkJoinPool | è‡ªåŠ¨ç®¡ç† | é€‚åˆé€’å½’åˆ†æ²» |
| å•çº¿ç¨‹é¡ºåº | SingleThreadExecutor | å›ºå®šå•çº¿ç¨‹ | ä»»åŠ¡å¼‚å¸¸ä¼šå½±å“åç»­ |

### æœ€ä½³å®è·µæ€»ç»“

**1. åˆ›å»ºçº¿ç¨‹æ± **ï¼š
- æ‰‹åŠ¨åˆ›å»ºThreadPoolExecutorï¼Œä¸ä½¿ç”¨Executors
- åˆç†è®¾ç½®æ ¸å¿ƒå‚æ•°ï¼Œç‰¹åˆ«æ˜¯é˜Ÿåˆ—å¤§å°
- ä½¿ç”¨æœ‰æ„ä¹‰çš„çº¿ç¨‹åç§°ï¼Œä¾¿äºé—®é¢˜æ’æŸ¥

**2. ä»»åŠ¡æäº¤**ï¼š
- ä¼˜å…ˆä½¿ç”¨submit()è€Œéexecute()ï¼Œä¾¿äºå¼‚å¸¸å¤„ç†
- åˆç†è®¾è®¡ä»»åŠ¡ç²’åº¦ï¼Œé¿å…é•¿æ—¶é—´é˜»å¡
- é‡è¦ä»»åŠ¡è€ƒè™‘é‡è¯•æœºåˆ¶

**3. ç›‘æ§è¿ç»´**ï¼š
- å»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»ï¼Œå…³æ³¨å…³é”®æŒ‡æ ‡
- è®¾ç½®åˆç†çš„å‘Šè­¦é˜ˆå€¼ï¼ŒåŠæ—¶å‘ç°é—®é¢˜
- å®šæœŸåˆ†æçº¿ç¨‹æ± ä½¿ç”¨æƒ…å†µï¼ŒæŒç»­ä¼˜åŒ–

**4. èµ„æºç®¡ç†**ï¼š
- åº”ç”¨å…³é—­æ—¶æ­£ç¡®å…³é—­çº¿ç¨‹æ± 
- é¿å…ThreadLocalå†…å­˜æ³„æ¼
- åˆç†æ§åˆ¶çº¿ç¨‹æ± æ•°é‡ï¼Œé¿å…èµ„æºæµªè´¹

### æŒç»­å­¦ä¹ å»ºè®®

1. **æ·±å…¥æºç å­¦ä¹ **ï¼šç†è§£ThreadPoolExecutorçš„å®ç°ç»†èŠ‚
2. **å®è·µç›‘æ§è°ƒä¼˜**ï¼šåœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨ç›‘æ§å’Œè°ƒä¼˜æŠ€æœ¯
3. **å…³æ³¨æ–°æŠ€æœ¯**ï¼šå­¦ä¹ è™šæ‹Ÿçº¿ç¨‹(Virtual Thread)ç­‰æ–°ç‰¹æ€§
4. **æ€§èƒ½æµ‹è¯•**ï¼šé€šè¿‡å‹æµ‹éªŒè¯çº¿ç¨‹æ± é…ç½®çš„åˆç†æ€§
5. **æ¡ˆä¾‹åˆ†æ**ï¼šæ”¶é›†å’Œåˆ†æçº¿ç¨‹æ± ç›¸å…³çš„ç”Ÿäº§é—®é¢˜

---

**ä¸‹ä¸€ç¯‡é¢„å‘Š**ï¼šã€ŠJavaé›†åˆæ¡†æ¶æ·±åº¦è§£æã€‹å°†å¼€å§‹æ–°çš„ç³»åˆ—ï¼Œæ·±å…¥æ¢è®¨ArrayListã€HashMapç­‰æ ¸å¿ƒé›†åˆç±»çš„å®ç°åŸç†ã€æ€§èƒ½ç‰¹æ€§å’Œä½¿ç”¨æœ€ä½³å®è·µã€‚