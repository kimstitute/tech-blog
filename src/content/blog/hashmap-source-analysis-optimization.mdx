---
title: "HashMapæºç è§£æä¸å“ˆå¸Œå†²çªå¤„ç†å®æˆ˜"
description: "æ·±å…¥è§£æHashMapçš„åº•å±‚å®ç°åŸç†ã€å“ˆå¸Œç®—æ³•è®¾è®¡å’Œçº¢é»‘æ ‘ä¼˜åŒ–æœºåˆ¶ã€‚ç»“åˆå®é™…é¡¹ç›®åœºæ™¯åˆ†æå“ˆå¸Œå†²çªå¤„ç†ç­–ç•¥ã€æ‰©å®¹æœºåˆ¶å’Œæ€§èƒ½è°ƒä¼˜ï¼ŒæŒæ¡Javaé›†åˆæ¡†æ¶çš„æ ¸å¿ƒè®¾è®¡æ€æƒ³ã€‚"
pubDate: 2024-12-06
updatedDate: 2024-12-06
tags: ["java", "hashmap", "hash-table", "red-black-tree", "performance", "source-code", "interview", "best-practices"]
categories: ["java-core"]
subject: "é›†åˆæ¡†æ¶"
draft: false
featured: true
author: "Gerrad Zhang"
location: "æ­¦æ±‰ï¼Œä¸­å›½"
---

## ğŸ¤” é—®é¢˜èƒŒæ™¯ä¸æŠ€æœ¯æ¼”è¿›

### æˆ‘ä»¬è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

åœ¨è½¯ä»¶å¼€å‘ä¸­ï¼Œ**å¿«é€Ÿçš„é”®å€¼æŸ¥æ‰¾**æ˜¯ä¸€ä¸ªåŸºç¡€è€Œå…³é”®çš„éœ€æ±‚ã€‚ä¼ ç»Ÿçš„æ•°æ®ç»“æ„åœ¨å¤„ç†å¤§é‡æ•°æ®çš„æŸ¥æ‰¾æ“ä½œæ—¶å­˜åœ¨æ˜æ˜¾çš„æ€§èƒ½ç“¶é¢ˆï¼š

- **æ•°ç»„æŸ¥æ‰¾**ï¼šéœ€è¦éå†æ•´ä¸ªæ•°ç»„ï¼Œæ—¶é—´å¤æ‚åº¦O(n)ï¼Œæ€§èƒ½éšæ•°æ®é‡çº¿æ€§ä¸‹é™
- **æœ‰åºæ•°ç»„äºŒåˆ†æŸ¥æ‰¾**ï¼šè™½ç„¶æŸ¥æ‰¾æ•ˆç‡O(log n)ï¼Œä½†æ’å…¥åˆ é™¤éœ€è¦ç§»åŠ¨å…ƒç´ ï¼Œæˆæœ¬é«˜æ˜‚
- **é“¾è¡¨æŸ¥æ‰¾**ï¼šå¿…é¡»ä»å¤´éå†ï¼Œæ—¶é—´å¤æ‚åº¦O(n)ï¼Œä¸”ç¼“å­˜å±€éƒ¨æ€§å·®
- **å¹³è¡¡æ ‘æŸ¥æ‰¾**ï¼šæ—¶é—´å¤æ‚åº¦O(log n)ï¼Œä½†å¯¹äºç®€å•çš„é”®å€¼æŸ¥æ‰¾æ˜¾å¾—è¿‡äºå¤æ‚

```java
// ä¼ ç»ŸæŸ¥æ‰¾æ–¹å¼çš„æ€§èƒ½é—®é¢˜
public class TraditionalSearchProblems {
    
    // âŒ é—®é¢˜1ï¼šæ•°ç»„çº¿æ€§æŸ¥æ‰¾ï¼Œæ€§èƒ½éšæ•°æ®é‡çº¿æ€§ä¸‹é™
    public String findValueInArray(String[] keys, String[] values, String targetKey) {
        for (int i = 0; i < keys.length; i++) {
            if (keys[i].equals(targetKey)) {
                return values[i]; // O(n)æ—¶é—´å¤æ‚åº¦
            }
        }
        return null;
    }
    
    // âŒ é—®é¢˜2ï¼šæ‰‹å·¥å®ç°å“ˆå¸Œè¡¨å¤æ‚ä¸”å®¹æ˜“å‡ºé”™
    public class SimpleHashTable {
        private Entry[] buckets;
        
        // ç®€å•å“ˆå¸Œå‡½æ•°ï¼Œå®¹æ˜“äº§ç”Ÿå†²çª
        private int hash(String key) {
            return key.hashCode() % buckets.length; // å¯èƒ½äº§ç”Ÿè´Ÿæ•°
        }
        
        static class Entry {
            String key, value;
            Entry next;
        }
    }
}
```

### æ²¡æœ‰è¿™ä¸ªæŠ€æœ¯æ—¶æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ

åœ¨HashMapå‡ºç°ä¹‹å‰ï¼ŒJavaå¼€å‘è€…ä¸»è¦é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°é”®å€¼æ˜ å°„ï¼š

**1. Hashtableç±»**
- Java 1.0å¼•å…¥çš„çº¿ç¨‹å®‰å…¨å“ˆå¸Œè¡¨å®ç°
- **é—®é¢˜**ï¼šæ‰€æœ‰æ–¹æ³•éƒ½åŒæ­¥ï¼Œæ€§èƒ½å¼€é”€å¤§

**2. æ‰‹å·¥å®ç°å“ˆå¸Œè¡¨**
- è‡ªå·±è®¾è®¡å“ˆå¸Œå‡½æ•°å’Œå†²çªè§£å†³ç­–ç•¥
- **é—®é¢˜**ï¼šå®ç°å¤æ‚ï¼Œå®¹æ˜“å‡ºç°å“ˆå¸Œå†²çªå’Œæ€§èƒ½é—®é¢˜

**3. å…³è”æ•°ç»„æ¨¡æ‹Ÿ**
- ä½¿ç”¨ä¸¤ä¸ªå¹¶è¡Œæ•°ç»„åˆ†åˆ«å­˜å‚¨é”®å’Œå€¼
- **é—®é¢˜**ï¼šæŸ¥æ‰¾æ•ˆç‡ä½ï¼Œç»´æŠ¤æˆæœ¬é«˜

### æŠ€æœ¯æ¼”è¿›çš„å†å²è„‰ç»œ

**JDK 1.2 (1998)**ï¼šHashMapé¦–æ¬¡å¼•å…¥
- ä½œä¸ºHashtableçš„éåŒæ­¥ç‰ˆæœ¬ç™»åœº
- åŸºäºæ•°ç»„+é“¾è¡¨çš„ç»å…¸å“ˆå¸Œè¡¨å®ç°
- æ”¯æŒnullé”®å’Œnullå€¼ï¼Œæä¾›æ›´å¥½çš„çµæ´»æ€§

**JDK 1.5 (2004)**ï¼šæ³›å‹æ”¯æŒ
- `HashMap<K,V>`æ³›å‹æä¾›ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
- è‡ªåŠ¨è£…ç®±/æ‹†ç®±ç®€åŒ–åŸºæœ¬ç±»å‹æ“ä½œ

**JDK 1.8 (2014)**ï¼šçº¢é»‘æ ‘ä¼˜åŒ–
- **é‡å¤§çªç ´**ï¼šé“¾è¡¨é•¿åº¦è¶…è¿‡8æ—¶è½¬æ¢ä¸ºçº¢é»‘æ ‘
- æœ€åæƒ…å†µä¸‹æŸ¥æ‰¾æ€§èƒ½ä»O(n)æå‡åˆ°O(log n)
- å¼•å…¥æ›´é«˜æ•ˆçš„å“ˆå¸Œç®—æ³•å’Œæ‰©å®¹ç­–ç•¥

**JDK 9+ (2017-ç°åœ¨)**ï¼šæŒç»­ä¼˜åŒ–
- å†…å­˜ä½¿ç”¨ä¼˜åŒ–å’Œæ€§èƒ½å¾®è°ƒ
- ä¸Stream APIå’Œå¹¶è¡Œå¤„ç†çš„æ›´å¥½é›†æˆ

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µä¸åŸç†

### åŸºç¡€æ¦‚å¿µå®šä¹‰

**HashMap**æ˜¯Javaé›†åˆæ¡†æ¶ä¸­åŸºäºå“ˆå¸Œè¡¨å®ç°çš„é”®å€¼æ˜ å°„å®¹å™¨ï¼Œé€šè¿‡å“ˆå¸Œç®—æ³•å°†é”®æ˜ å°„åˆ°æ•°ç»„ç´¢å¼•ï¼Œå®ç°å¹³å‡O(1)æ—¶é—´å¤æ‚åº¦çš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚

**æ ¸å¿ƒç‰¹æ€§**ï¼š
- **å“ˆå¸Œæ˜ å°„**ï¼šé€šè¿‡å“ˆå¸Œå‡½æ•°å°†é”®è½¬æ¢ä¸ºæ•°ç»„ç´¢å¼•
- **å†²çªå¤„ç†**ï¼šé‡‡ç”¨é“¾åœ°å€æ³•å’Œçº¢é»‘æ ‘ä¼˜åŒ–å¤„ç†å“ˆå¸Œå†²çª
- **åŠ¨æ€æ‰©å®¹**ï¼šè´Ÿè½½å› å­è¶…è¿‡é˜ˆå€¼æ—¶è‡ªåŠ¨æ‰©å®¹ï¼Œä¿æŒæ€§èƒ½
- **nullæ”¯æŒ**ï¼šå…è®¸ä¸€ä¸ªnullé”®å’Œå¤šä¸ªnullå€¼

### HashMapæ ¸å¿ƒæ¶æ„

**åº•å±‚æ•°æ®ç»“æ„æ¼”è¿›**ï¼š

```java
/**
 * HashMapæ ¸å¿ƒæ•°æ®ç»“æ„åˆ†æï¼ˆJDK 1.8+ï¼‰
 */
public class HashMapStructureAnalysis {
    
    /**
     * HashMapçš„æ ¸å¿ƒå­—æ®µè§£æ
     */
    public void analyzeHashMapFields() {
        /*
         * public class HashMap<K,V> extends AbstractMap<K,V>
         *     implements Map<K,V>, Cloneable, Serializable {
         *     
         *     // é»˜è®¤åˆå§‹å®¹é‡ï¼ˆå¿…é¡»æ˜¯2çš„å¹‚ï¼‰
         *     static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16
         *     
         *     // æœ€å¤§å®¹é‡
         *     static final int MAXIMUM_CAPACITY = 1 << 30;
         *     
         *     // é»˜è®¤è´Ÿè½½å› å­
         *     static final float DEFAULT_LOAD_FACTOR = 0.75f;
         *     
         *     // é“¾è¡¨è½¬çº¢é»‘æ ‘çš„é˜ˆå€¼
         *     static final int TREEIFY_THRESHOLD = 8;
         *     
         *     // çº¢é»‘æ ‘è½¬é“¾è¡¨çš„é˜ˆå€¼
         *     static final int UNTREEIFY_THRESHOLD = 6;
         *     
         *     // è½¬çº¢é»‘æ ‘çš„æœ€å°æ•°ç»„å®¹é‡
         *     static final int MIN_TREEIFY_CAPACITY = 64;
         *     
         *     // å­˜å‚¨å…ƒç´ çš„æ•°ç»„
         *     transient Node<K,V>[] table;
         *     
         *     // é”®å€¼å¯¹æ•°é‡
         *     transient int size;
         *     
         *     // æ‰©å®¹é˜ˆå€¼ = capacity * loadFactor
         *     int threshold;
         *     
         *     // è´Ÿè½½å› å­
         *     final float loadFactor;
         * }
         */
    }
    
    /**
     * NodeèŠ‚ç‚¹ç»“æ„åˆ†æ
     */
    public void analyzeNodeStructure() {
        /*
         * åŸºæœ¬èŠ‚ç‚¹ç»“æ„ï¼ˆé“¾è¡¨èŠ‚ç‚¹ï¼‰ï¼š
         * 
         * static class Node<K,V> implements Map.Entry<K,V> {
         *     final int hash;    // å“ˆå¸Œå€¼ç¼“å­˜
         *     final K key;       // é”®
         *     V value;           // å€¼
         *     Node<K,V> next;    // æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
         *     
         *     Node(int hash, K key, V value, Node<K,V> next) {
         *         this.hash = hash;
         *         this.key = key;
         *         this.value = value;
         *         this.next = next;
         *     }
         * }
         * 
         * çº¢é»‘æ ‘èŠ‚ç‚¹ç»“æ„ï¼š
         * 
         * static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
         *     TreeNode<K,V> parent;  // çˆ¶èŠ‚ç‚¹
         *     TreeNode<K,V> left;    // å·¦å­èŠ‚ç‚¹
         *     TreeNode<K,V> right;   // å³å­èŠ‚ç‚¹
         *     TreeNode<K,V> prev;    // å‰é©±èŠ‚ç‚¹ï¼ˆç»´æŠ¤æ’å…¥é¡ºåºï¼‰
         *     boolean red;           // çº¢é»‘æ ‘é¢œè‰²
         * }
         */
    }
}
```

### å“ˆå¸Œç®—æ³•è®¾è®¡

**HashMapçš„å“ˆå¸Œç®—æ³•ä¼˜åŒ–**ï¼š

```java
/**
 * HashMapå“ˆå¸Œç®—æ³•æ·±åº¦åˆ†æ
 */
public class HashMapHashAlgorithm {
    
    /**
     * JDK 1.8çš„å“ˆå¸Œç®—æ³•å®ç°
     */
    public void analyzeHashFunction() {
        /*
         * HashMapçš„hashæ–¹æ³•å®ç°ï¼š
         * 
         * static final int hash(Object key) {
         *     int h;
         *     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
         * }
         * 
         * ç®—æ³•è®¾è®¡æ€æƒ³ï¼š
         * 1. è·å–keyçš„hashCode
         * 2. å°†é«˜16ä½ä¸ä½16ä½è¿›è¡Œå¼‚æˆ–è¿ç®—
         * 3. ç›®çš„ï¼šè®©é«˜ä½ä¹Ÿå‚ä¸åˆ°ç´¢å¼•è®¡ç®—ä¸­ï¼Œå‡å°‘å“ˆå¸Œå†²çª
         */
    }
    
    /**
     * ç´¢å¼•è®¡ç®—æ–¹æ³•
     */
    public void analyzeIndexCalculation() {
        /*
         * è®¡ç®—æ•°ç»„ç´¢å¼•çš„æ–¹æ³•ï¼š
         * 
         * åœ¨putValæ–¹æ³•ä¸­ï¼š
         * if ((p = tab[i = (n - 1) & hash]) == null)
         * 
         * ç´¢å¼•è®¡ç®—ï¼ši = (n - 1) & hash
         * 
         * ä¸ºä»€ä¹ˆä½¿ç”¨ä½è¿ç®—è€Œä¸æ˜¯å–æ¨¡è¿ç®—ï¼Ÿ
         * 1. æ€§èƒ½ï¼šä½è¿ç®—æ¯”å–æ¨¡è¿ç®—å¿«å¾—å¤š
         * 2. å‰æï¼šæ•°ç»„é•¿åº¦å¿…é¡»æ˜¯2çš„å¹‚ï¼Œè¿™æ ·(n-1)çš„äºŒè¿›åˆ¶å…¨æ˜¯1
         * 3. æ•ˆæœï¼š(n-1) & hash ç­‰ä»·äº hash % nï¼Œä½†æ€§èƒ½æ›´å¥½
         * 
         * ä¾‹å­ï¼š
         * å‡è®¾æ•°ç»„é•¿åº¦n=16ï¼Œåˆ™n-1=15ï¼ŒäºŒè¿›åˆ¶ä¸º1111
         * hashå€¼ä¸º25ï¼ŒäºŒè¿›åˆ¶ä¸º11001
         * è®¡ç®—ï¼š11001 & 01111 = 01001 = 9
         * ç­‰ä»·äºï¼š25 % 16 = 9
         */
    }
    
    /**
     * å“ˆå¸Œå†²çªçš„äº§ç”ŸåŸå› 
     */
    public void analyzeHashCollision() {
        /*
         * å“ˆå¸Œå†²çªçš„æ ¹æœ¬åŸå› ï¼š
         * 1. å“ˆå¸Œå‡½æ•°çš„å€¼åŸŸæœ‰é™ï¼ˆæ•°ç»„é•¿åº¦æœ‰é™ï¼‰
         * 2. é”®çš„å–å€¼èŒƒå›´é€šå¸¸è¿œå¤§äºæ•°ç»„é•¿åº¦
         * 3. æ ¹æ®é¸½ç¬¼åŸç†ï¼Œå¿…ç„¶å­˜åœ¨å¤šä¸ªé”®æ˜ å°„åˆ°åŒä¸€ä¸ªç´¢å¼•
         * 
         * HashMapå¤„ç†å†²çªçš„ç­–ç•¥æ¼”è¿›ï¼š
         * JDK 1.7åŠä¹‹å‰ï¼šçº¯é“¾åœ°å€æ³•
         * - åŒä¸€ç´¢å¼•çš„å…ƒç´ å½¢æˆé“¾è¡¨
         * - æœ€åæƒ…å†µä¸‹é€€åŒ–ä¸ºO(n)æŸ¥æ‰¾
         * 
         * JDK 1.8åŠä¹‹åï¼šé“¾è¡¨+çº¢é»‘æ ‘
         * - é“¾è¡¨é•¿åº¦â‰¤8ï¼šä½¿ç”¨é“¾è¡¨
         * - é“¾è¡¨é•¿åº¦>8ä¸”æ•°ç»„é•¿åº¦â‰¥64ï¼šè½¬æ¢ä¸ºçº¢é»‘æ ‘
         * - çº¢é»‘æ ‘èŠ‚ç‚¹æ•°â‰¤6ï¼šè½¬æ¢å›é“¾è¡¨
         */
    }
    
    /**
     * ä¸ºä»€ä¹ˆé€‰æ‹©8ä½œä¸ºæ ‘åŒ–é˜ˆå€¼ï¼Ÿ
     */
    public void explainTreeifyThreshold() {
        /*
         * é€‰æ‹©8ä½œä¸ºæ ‘åŒ–é˜ˆå€¼çš„åŸå› ï¼š
         * 
         * 1. æ³Šæ¾åˆ†å¸ƒåˆ†æï¼š
         *    åœ¨ç†æƒ³çš„å“ˆå¸Œåˆ†å¸ƒä¸‹ï¼Œé“¾è¡¨é•¿åº¦éµå¾ªæ³Šæ¾åˆ†å¸ƒ
         *    é“¾è¡¨é•¿åº¦ä¸º8çš„æ¦‚ç‡çº¦ä¸º0.00000006ï¼ˆåƒä¸‡åˆ†ä¹‹å…­ï¼‰
         *    è¿™ç§æƒ…å†µæå…¶ç½•è§ï¼Œä¸€æ—¦å‡ºç°è¯´æ˜å“ˆå¸Œå‡½æ•°æœ‰é—®é¢˜
         * 
         * 2. æ€§èƒ½å¹³è¡¡ï¼š
         *    é“¾è¡¨æŸ¥æ‰¾ï¼šO(n)ï¼Œä½†å¸¸æ•°å› å­å°ï¼Œå†…å­˜å¼€é”€å°
         *    çº¢é»‘æ ‘æŸ¥æ‰¾ï¼šO(log n)ï¼Œä½†å¸¸æ•°å› å­å¤§ï¼Œå†…å­˜å¼€é”€å¤§
         *    é•¿åº¦ä¸º8æ—¶ï¼Œçº¢é»‘æ ‘çš„æ€§èƒ½ä¼˜åŠ¿å¼€å§‹æ˜¾ç°
         * 
         * 3. é€‰æ‹©6ä½œä¸ºé€€æ ‘åŒ–é˜ˆå€¼ï¼š
         *    é¿å…åœ¨8é™„è¿‘é¢‘ç¹åœ°è¿›è¡Œæ ‘åŒ–å’Œé€€æ ‘åŒ–æ“ä½œ
         *    æä¾›ä¸€ä¸ªç¼“å†²åŒºé—´ï¼Œå‡å°‘ä¸å¿…è¦çš„ç»“æ„è½¬æ¢
         */
    }
}
```

### æ‰©å®¹æœºåˆ¶è¯¦è§£

**HashMapçš„æ‰©å®¹ç­–ç•¥**ï¼š

```java
/**
 * HashMapæ‰©å®¹æœºåˆ¶æ·±åº¦åˆ†æ
 */
public class HashMapResizeMechanism {
    
    /**
     * æ‰©å®¹è§¦å‘æ¡ä»¶
     */
    public void analyzeResizeTrigger() {
        /*
         * æ‰©å®¹è§¦å‘æ¡ä»¶ï¼š
         * 1. å½“å‰å…ƒç´ æ•°é‡ > thresholdï¼ˆé˜ˆå€¼ï¼‰
         * 2. threshold = capacity * loadFactor
         * 3. é»˜è®¤loadFactor = 0.75
         * 
         * ä¸ºä»€ä¹ˆé€‰æ‹©0.75ä½œä¸ºè´Ÿè½½å› å­ï¼Ÿ
         * 1. æ—¶é—´ä¸ç©ºé—´çš„å¹³è¡¡ï¼š
         *    - è¿‡å°ï¼šæµªè´¹ç©ºé—´ï¼Œä½†å†²çªå°‘
         *    - è¿‡å¤§ï¼šèŠ‚çœç©ºé—´ï¼Œä½†å†²çªå¤š
         * 2. æ•°å­¦åˆ†æï¼š
         *    - 0.75æ˜¯ç»è¿‡å¤§é‡æµ‹è¯•å¾—å‡ºçš„æœ€ä¼˜å€¼
         *    - åœ¨è¿™ä¸ªè´Ÿè½½å› å­ä¸‹ï¼Œå“ˆå¸Œå†²çªçš„æ¦‚ç‡ç›¸å¯¹è¾ƒä½
         *    - åŒæ—¶ç©ºé—´åˆ©ç”¨ç‡ä¹Ÿæ¯”è¾ƒåˆç†
         */
    }
    
    /**
     * æ‰©å®¹è¿‡ç¨‹åˆ†æ
     */
    public void analyzeResizeProcess() {
        /*
         * æ‰©å®¹è¿‡ç¨‹ï¼ˆresizeæ–¹æ³•ï¼‰ï¼š
         * 
         * 1. åˆ›å»ºæ–°æ•°ç»„ï¼š
         *    newCap = oldCap << 1  // å®¹é‡ç¿»å€
         *    newThr = oldThr << 1  // é˜ˆå€¼ç¿»å€
         * 
         * 2. é‡æ–°å“ˆå¸Œï¼ˆrehashï¼‰ï¼š
         *    éå†æ—§æ•°ç»„çš„æ¯ä¸ªä½ç½®
         *    å¯¹æ¯ä¸ªå…ƒç´ é‡æ–°è®¡ç®—åœ¨æ–°æ•°ç»„ä¸­çš„ä½ç½®
         * 
         * 3. JDK 1.8çš„ä¼˜åŒ–ï¼š
         *    ä¸éœ€è¦é‡æ–°è®¡ç®—hashå€¼
         *    åªéœ€è¦åˆ¤æ–­åŸhashå€¼åœ¨æ–°å¢çš„bitä½ä¸Šæ˜¯0è¿˜æ˜¯1
         *    - å¦‚æœæ˜¯0ï¼šä½ç½®ä¸å˜
         *    - å¦‚æœæ˜¯1ï¼šä½ç½® = åŸä½ç½® + åŸæ•°ç»„é•¿åº¦
         */
    }
    
    /**
     * JDK 1.8æ‰©å®¹ä¼˜åŒ–è¯¦è§£
     */
    public void explainJDK8ResizeOptimization() {
        /*
         * JDK 1.8æ‰©å®¹ä¼˜åŒ–çš„æ ¸å¿ƒæ€æƒ³ï¼š
         * 
         * åŸç†ï¼š
         * æ‰©å®¹å‰ï¼šindex = hash & (oldCap - 1)
         * æ‰©å®¹åï¼šindex = hash & (newCap - 1)
         * 
         * ç”±äºnewCap = oldCap * 2ï¼Œæ‰€ä»¥ï¼š
         * newCap - 1 = (oldCap - 1) + oldCap
         * 
         * å…³é”®è§‚å¯Ÿï¼š
         * æ–°å¢çš„bitä½å†³å®šäº†å…ƒç´ çš„æ–°ä½ç½®
         * if ((hash & oldCap) == 0) {
         *     // æ–°ä½ç½® = åŸä½ç½®
         * } else {
         *     // æ–°ä½ç½® = åŸä½ç½® + oldCap
         * }
         * 
         * ä¼˜åŠ¿ï¼š
         * 1. ä¸éœ€è¦é‡æ–°è®¡ç®—hashå€¼
         * 2. ä¸éœ€è¦é‡æ–°è¿›è¡Œç´¢å¼•è®¡ç®—
         * 3. å…ƒç´ è¦ä¹ˆåœ¨åŸä½ç½®ï¼Œè¦ä¹ˆåœ¨"åŸä½ç½®+oldCap"
         * 4. å¤§å¤§æå‡äº†æ‰©å®¹çš„æ€§èƒ½
         */
    }
}

## ğŸ”§ å®ç°åŸç†ä¸æºç åˆ†æ

### æ ¸å¿ƒæ“ä½œå®ç°

**HashMapçš„å¢åˆ æ”¹æŸ¥æ“ä½œæºç è§£æ**ï¼š

```java
/**
 * HashMapæ ¸å¿ƒæ“ä½œæºç åˆ†æ
 */
public class HashMapCoreOperations {
    
    /**
     * putæ“ä½œçš„å®Œæ•´æµç¨‹
     */
    public void analyzePutOperation() {
        /*
         * putValæ–¹æ³•çš„æ ¸å¿ƒé€»è¾‘ï¼š
         * 
         * 1. è®¡ç®—å“ˆå¸Œå€¼å’Œç´¢å¼•
         * 2. æ£€æŸ¥æ•°ç»„æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºåˆ™åˆå§‹åŒ–
         * 3. æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºç›´æ¥æ’å…¥
         * 4. å¤„ç†å“ˆå¸Œå†²çªï¼š
         *    - æ£€æŸ¥é¦–èŠ‚ç‚¹æ˜¯å¦åŒ¹é…
         *    - å¦‚æœæ˜¯çº¢é»‘æ ‘èŠ‚ç‚¹ï¼Œè°ƒç”¨æ ‘çš„æ’å…¥æ–¹æ³•
         *    - å¦‚æœæ˜¯é“¾è¡¨ï¼Œéå†é“¾è¡¨è¿›è¡Œæ’å…¥æˆ–æ›´æ–°
         * 5. æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
         */
    }
    
    /**
     * getæ“ä½œçš„å®ç°åˆ†æ
     */
    public void analyzeGetOperation() {
        /*
         * getNodeæ–¹æ³•çš„æ ¸å¿ƒé€»è¾‘ï¼š
         * 
         * 1. è®¡ç®—å“ˆå¸Œå€¼å’Œç´¢å¼•
         * 2. æ£€æŸ¥æ•°ç»„å’Œç›®æ ‡ä½ç½®
         * 3. æ£€æŸ¥é¦–èŠ‚ç‚¹æ˜¯å¦åŒ¹é…
         * 4. æ ¹æ®èŠ‚ç‚¹ç±»å‹é€‰æ‹©æŸ¥æ‰¾ç­–ç•¥ï¼š
         *    - çº¢é»‘æ ‘ï¼šè°ƒç”¨æ ‘çš„æŸ¥æ‰¾æ–¹æ³• O(log n)
         *    - é“¾è¡¨ï¼šéå†é“¾è¡¨æŸ¥æ‰¾ O(n)
         */
    }
}
```

### çº¢é»‘æ ‘ä¼˜åŒ–æœºåˆ¶

```java
/**
 * HashMapçº¢é»‘æ ‘ä¼˜åŒ–æœºåˆ¶åˆ†æ
 */
public class HashMapRedBlackTreeOptimization {
    
    /**
     * æ ‘åŒ–æ¡ä»¶åˆ†æ
     */
    public void analyzeTreeifyConditions() {
        /*
         * æ ‘åŒ–çš„å®Œæ•´æ¡ä»¶ï¼š
         * 1. é“¾è¡¨é•¿åº¦ >= TREEIFY_THRESHOLD (8)
         * 2. æ•°ç»„é•¿åº¦ >= MIN_TREEIFY_CAPACITY (64)
         * 
         * ä¸ºä»€ä¹ˆéœ€è¦ä¸¤ä¸ªæ¡ä»¶ï¼Ÿ
         * - æ¡ä»¶1ï¼šé“¾è¡¨è¿‡é•¿ï¼ŒæŸ¥æ‰¾æ•ˆç‡ä½
         * - æ¡ä»¶2ï¼šæ•°ç»„å®¹é‡è¶³å¤Ÿå¤§ï¼Œå€¼å¾—è¿›è¡Œæ ‘åŒ–
         * 
         * å¦‚æœæ•°ç»„é•¿åº¦ < 64ï¼Œä¼˜å…ˆé€‰æ‹©æ‰©å®¹è€Œä¸æ˜¯æ ‘åŒ–
         */
    }
}
```

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹ä¸ä»£ç ç¤ºä¾‹

### å…·ä½“é¡¹ç›®åº”ç”¨

**åœºæ™¯1ï¼šé«˜æ€§èƒ½ç¼“å­˜å®ç°**

```java
/**
 * åŸºäºHashMapçš„é«˜æ€§èƒ½æœ¬åœ°ç¼“å­˜å®ç°
 */
@Component
public class HighPerformanceLocalCache<K, V> {
    
    private final ConcurrentHashMap<K, CacheEntry<V>> cache;
    private final int maxSize;
    private final long defaultTTL;
    
    public HighPerformanceLocalCache(int maxSize, long defaultTTL) {
        this.maxSize = maxSize;
        this.defaultTTL = defaultTTL;
        // è®¡ç®—åˆé€‚çš„åˆå§‹å®¹é‡ï¼Œé¿å…æ‰©å®¹
        this.cache = new ConcurrentHashMap<>(calculateInitialCapacity(maxSize));
    }
    
    /**
     * è®¡ç®—åˆé€‚çš„åˆå§‹å®¹é‡
     */
    private int calculateInitialCapacity(int maxSize) {
        // è€ƒè™‘è´Ÿè½½å› å­0.75ï¼Œé¢„ç•™ç©ºé—´é¿å…æ‰©å®¹
        return (int) (maxSize / 0.75) + 1;
    }
    
    /**
     * å­˜å‚¨æ•°æ®åˆ°ç¼“å­˜
     */
    public void put(K key, V value, long ttl) {
        if (cache.size() >= maxSize) {
            evictLRU(); // LRUæ·˜æ±°
        }
        
        long expireTime = System.currentTimeMillis() + ttl;
        CacheEntry<V> entry = new CacheEntry<>(value, expireTime);
        cache.put(key, entry);
    }
    
    /**
     * ä»ç¼“å­˜è·å–æ•°æ®
     */
    public V get(K key) {
        CacheEntry<V> entry = cache.get(key);
        if (entry == null || entry.isExpired()) {
            cache.remove(key);
            return null;
        }
        
        entry.updateAccessTime();
        return entry.getValue();
    }
    
    private static class CacheEntry<V> {
        private final V value;
        private final long expireTime;
        private volatile long lastAccessTime;
        
        public CacheEntry(V value, long expireTime) {
            this.value = value;
            this.expireTime = expireTime;
            this.lastAccessTime = System.currentTimeMillis();
        }
        
        public boolean isExpired() {
            return System.currentTimeMillis() > expireTime;
        }
        
        public void updateAccessTime() {
            this.lastAccessTime = System.currentTimeMillis();
        }
        
        public V getValue() { return value; }
        public long getLastAccessTime() { return lastAccessTime; }
    }
}
```

**åœºæ™¯2ï¼šåˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ä¸€è‡´æ€§å“ˆå¸Œå®ç°**

```java
/**
 * åŸºäºHashMapçš„ä¸€è‡´æ€§å“ˆå¸Œç¯å®ç°
 */
@Component
public class ConsistentHashRing<T> {
    
    private final TreeMap<Long, T> ring = new TreeMap<>();
    private final HashMap<T, Set<Long>> nodeToHashes = new HashMap<>();
    private final int virtualNodes;
    
    public ConsistentHashRing(int virtualNodes) {
        this.virtualNodes = virtualNodes;
    }
    
    /**
     * æ·»åŠ èŠ‚ç‚¹åˆ°å“ˆå¸Œç¯
     */
    public synchronized void addNode(T node) {
        Set<Long> hashes = new HashSet<>();
        
        // ä¸ºæ¯ä¸ªç‰©ç†èŠ‚ç‚¹åˆ›å»ºå¤šä¸ªè™šæ‹ŸèŠ‚ç‚¹
        for (int i = 0; i < virtualNodes; i++) {
            String virtualNodeKey = node.toString() + "#" + i;
            long hash = hash(virtualNodeKey);
            
            ring.put(hash, node);
            hashes.add(hash);
        }
        
        nodeToHashes.put(node, hashes);
    }
    
    /**
     * æ ¹æ®keyæ‰¾åˆ°å¯¹åº”çš„èŠ‚ç‚¹
     */
    public T getNode(String key) {
        if (ring.isEmpty()) {
            return null;
        }
        
        long hash = hash(key);
        
        // åœ¨å“ˆå¸Œç¯ä¸Šé¡ºæ—¶é’ˆæŸ¥æ‰¾ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
        Map.Entry<Long, T> entry = ring.ceilingEntry(hash);
        if (entry == null) {
            entry = ring.firstEntry();
        }
        
        return entry.getValue();
    }
    
         private long hash(String input) {
         // ç®€åŒ–çš„å“ˆå¸Œå‡½æ•°å®ç°
         return input.hashCode() & 0x7FFFFFFFL;
     }
 }

## ğŸ¯ é¢è¯•é«˜é¢‘é—®é¢˜ç²¾è®²

### æ ¸å¿ƒé¢è¯•é—®é¢˜

**é—®é¢˜1ï¼šHashMapçš„åº•å±‚å®ç°åŸç†**

```java
/**
 * HashMapåº•å±‚å®ç°åŸç†é¢è¯•è¦ç‚¹
 */
public class HashMapImplementationPrinciples {
    
    /**
     * æ ‡å‡†é¢è¯•ç­”æ¡ˆ
     */
    public void explainImplementation() {
        /*
         * HashMapåº•å±‚å®ç°åŸç†ï¼š
         * 
         * 1. æ•°æ®ç»“æ„ï¼š
         *    - JDK 1.7ï¼šæ•°ç»„ + é“¾è¡¨
         *    - JDK 1.8+ï¼šæ•°ç»„ + é“¾è¡¨ + çº¢é»‘æ ‘
         * 
         * 2. å“ˆå¸Œç®—æ³•ï¼š
         *    - hash(key) = key.hashCode() ^ (key.hashCode() >>> 16)
         *    - ç›®çš„ï¼šè®©é«˜ä½å‚ä¸è¿ç®—ï¼Œå‡å°‘å“ˆå¸Œå†²çª
         * 
         * 3. ç´¢å¼•è®¡ç®—ï¼š
         *    - index = (n - 1) & hash
         *    - è¦æ±‚æ•°ç»„é•¿åº¦å¿…é¡»æ˜¯2çš„å¹‚
         * 
         * 4. å†²çªå¤„ç†ï¼š
         *    - é“¾è¡¨é•¿åº¦ â‰¤ 8ï¼šä½¿ç”¨é“¾è¡¨
         *    - é“¾è¡¨é•¿åº¦ > 8 ä¸”æ•°ç»„é•¿åº¦ â‰¥ 64ï¼šè½¬æ¢ä¸ºçº¢é»‘æ ‘
         * 
         * 5. æ‰©å®¹æœºåˆ¶ï¼š
         *    - è§¦å‘æ¡ä»¶ï¼šsize > threshold (capacity * 0.75)
         *    - æ‰©å®¹æ–¹å¼ï¼šå®¹é‡ç¿»å€ï¼Œé‡æ–°å“ˆå¸Œ
         */
    }
}
```

**é—®é¢˜2ï¼šHashMapä¸Hashtableçš„åŒºåˆ«**

```java
/**
 * HashMap vs Hashtable å¯¹æ¯”åˆ†æ
 */
public class HashMapVsHashtableComparison {
    
    /**
     * è¯¦ç»†å¯¹æ¯”åˆ†æ
     */
    public void compareHashMapAndHashtable() {
        /*
         * ä¸»è¦åŒºåˆ«ï¼š
         * 
         * 1. çº¿ç¨‹å®‰å…¨æ€§ï¼š
         *    - HashMapï¼šéçº¿ç¨‹å®‰å…¨ï¼Œæ€§èƒ½æ›´å¥½
         *    - Hashtableï¼šçº¿ç¨‹å®‰å…¨ï¼Œæ‰€æœ‰æ–¹æ³•éƒ½æ˜¯synchronized
         * 
         * 2. nullå€¼æ”¯æŒï¼š
         *    - HashMapï¼šå…è®¸ä¸€ä¸ªnullé”®å’Œå¤šä¸ªnullå€¼
         *    - Hashtableï¼šä¸å…è®¸nullé”®å’Œnullå€¼
         * 
         * 3. ç»§æ‰¿å…³ç³»ï¼š
         *    - HashMapï¼šç»§æ‰¿AbstractMapç±»
         *    - Hashtableï¼šç»§æ‰¿Dictionaryç±»
         * 
         * 4. åˆå§‹å®¹é‡ï¼š
         *    - HashMapï¼šé»˜è®¤16ï¼Œå¿…é¡»æ˜¯2çš„å¹‚
         *    - Hashtableï¼šé»˜è®¤11ï¼Œå¯ä»¥æ˜¯ä»»æ„æ­£æ•´æ•°
         * 
         * 5. æ‰©å®¹æœºåˆ¶ï¼š
         *    - HashMapï¼šå®¹é‡ç¿»å€
         *    - Hashtableï¼šå®¹é‡ç¿»å€+1
         * 
         * 6. è¿­ä»£å™¨ï¼š
         *    - HashMapï¼šfail-fastè¿­ä»£å™¨
         *    - Hashtableï¼šfail-fastè¿­ä»£å™¨ï¼ˆJDK 1.2+ï¼‰
         */
    }
}
```

**é—®é¢˜3ï¼šHashMapçš„çº¿ç¨‹å®‰å…¨é—®é¢˜åŠè§£å†³æ–¹æ¡ˆ**

```java
/**
 * HashMapçº¿ç¨‹å®‰å…¨é—®é¢˜åˆ†æ
 */
public class HashMapThreadSafetyIssues {
    
    /**
     * çº¿ç¨‹å®‰å…¨é—®é¢˜æ¼”ç¤º
     */
    public void demonstrateThreadSafetyIssues() {
        /*
         * HashMapçš„çº¿ç¨‹å®‰å…¨é—®é¢˜ï¼š
         * 
         * 1. æ•°æ®ä¸¢å¤±ï¼š
         *    - å¤šä¸ªçº¿ç¨‹åŒæ—¶putï¼Œå¯èƒ½å¯¼è‡´æ•°æ®è¦†ç›–
         *    - sizeè®¡æ•°ä¸å‡†ç¡®
         * 
         * 2. æ­»å¾ªç¯ï¼ˆJDK 1.7ï¼‰ï¼š
         *    - æ‰©å®¹æ—¶çš„é“¾è¡¨é‡æ’å¯èƒ½å½¢æˆç¯å½¢é“¾è¡¨
         *    - å¯¼è‡´getæ“ä½œæ— é™å¾ªç¯ï¼ŒCPUä½¿ç”¨ç‡100%
         * 
         * 3. æ•°æ®ä¸ä¸€è‡´ï¼š
         *    - è¯»å†™æ“ä½œäº¤é”™æ‰§è¡Œ
         *    - å¯èƒ½è¯»åˆ°ä¸å®Œæ•´çš„æ•°æ®
         */
    }
    
    /**
     * è§£å†³æ–¹æ¡ˆå¯¹æ¯”
     */
    public void threadSafetySolutions() {
        /*
         * çº¿ç¨‹å®‰å…¨è§£å†³æ–¹æ¡ˆï¼š
         * 
         * 1. Collections.synchronizedMap(HashMap)
         *    - ä¼˜ç‚¹ï¼šç®€å•æ˜“ç”¨
         *    - ç¼ºç‚¹ï¼šæ€§èƒ½è¾ƒå·®ï¼Œç²’åº¦å¤§
         * 
         * 2. Hashtable
         *    - ä¼˜ç‚¹ï¼šåŸç”Ÿçº¿ç¨‹å®‰å…¨
         *    - ç¼ºç‚¹ï¼šæ€§èƒ½å·®ï¼Œä¸å…è®¸null
         * 
         * 3. ConcurrentHashMapï¼ˆæ¨èï¼‰
         *    - ä¼˜ç‚¹ï¼šé«˜å¹¶å‘æ€§èƒ½å¥½ï¼Œåˆ†æ®µé”è®¾è®¡
         *    - JDK 1.7ï¼šSegmentåˆ†æ®µé”
         *    - JDK 1.8ï¼šCAS + synchronized
         * 
         * 4. ThreadLocal<HashMap>
         *    - ä¼˜ç‚¹ï¼šæ— é”ï¼Œæ€§èƒ½æœ€å¥½
         *    - ç¼ºç‚¹ï¼šæ•°æ®æ— æ³•å…±äº«
         */
        
        // ç¤ºä¾‹ï¼šä½¿ç”¨ConcurrentHashMap
        ConcurrentHashMap<String, String> concurrentMap = new ConcurrentHashMap<>();
        concurrentMap.put("key", "value"); // çº¿ç¨‹å®‰å…¨
    }
}
```

**é—®é¢˜4ï¼šHashMapçš„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**

```java
/**
 * HashMapæ€§èƒ½ä¼˜åŒ–ç­–ç•¥
 */
public class HashMapPerformanceOptimization {
    
    /**
     * æ€§èƒ½ä¼˜åŒ–è¦ç‚¹
     */
    public void optimizationStrategies() {
        /*
         * æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š
         * 
         * 1. åˆç†è®¾ç½®åˆå§‹å®¹é‡ï¼š
         *    - é¿å…é¢‘ç¹æ‰©å®¹
         *    - åˆå§‹å®¹é‡ = é¢„æœŸå…ƒç´ æ•°é‡ / 0.75
         * 
         * 2. é€‰æ‹©åˆé€‚çš„è´Ÿè½½å› å­ï¼š
         *    - é»˜è®¤0.75æ˜¯æ—¶é—´å’Œç©ºé—´çš„å¹³è¡¡
         *    - å†…å­˜æ•æ„Ÿï¼šå¯ä»¥è®¾ç½®ä¸º0.5
         *    - æ€§èƒ½æ•æ„Ÿï¼šå¯ä»¥è®¾ç½®ä¸º1.0
         * 
         * 3. ä¼˜åŒ–keyçš„hashCodeæ–¹æ³•ï¼š
         *    - ç¡®ä¿å“ˆå¸Œåˆ†å¸ƒå‡åŒ€
         *    - é¿å…å¤§é‡å“ˆå¸Œå†²çª
         * 
         * 4. é¿å…é¢‘ç¹çš„ç»“æ„ä¿®æ”¹ï¼š
         *    - æ‰¹é‡æ“ä½œæ›¿ä»£å•ä¸ªæ“ä½œ
         *    - ä½¿ç”¨putAllè€Œä¸æ˜¯å¤šæ¬¡put
         * 
         * 5. åˆç†ä½¿ç”¨HashMapçš„å˜ç§ï¼š
         *    - LinkedHashMapï¼šéœ€è¦ä¿æŒæ’å…¥é¡ºåº
         *    - TreeMapï¼šéœ€è¦æ’åº
         *    - ConcurrentHashMapï¼šå¤šçº¿ç¨‹ç¯å¢ƒ
         */
    }
}
```

**é—®é¢˜5ï¼šçº¢é»‘æ ‘åœ¨HashMapä¸­çš„ä½œç”¨**

```java
/**
 * çº¢é»‘æ ‘åœ¨HashMapä¸­çš„ä½œç”¨åˆ†æ
 */
public class RedBlackTreeInHashMap {
    
    /**
     * çº¢é»‘æ ‘ä¼˜åŒ–åˆ†æ
     */
    public void analyzeRedBlackTreeOptimization() {
        /*
         * çº¢é»‘æ ‘åœ¨HashMapä¸­çš„ä½œç”¨ï¼š
         * 
         * 1. è§£å†³å“ˆå¸Œå†²çªæ¶åŒ–é—®é¢˜ï¼š
         *    - JDK 1.7ï¼šæœ€åæƒ…å†µO(n)æŸ¥æ‰¾
         *    - JDK 1.8ï¼šæœ€åæƒ…å†µO(log n)æŸ¥æ‰¾
         * 
         * 2. æ ‘åŒ–æ¡ä»¶ï¼š
         *    - é“¾è¡¨é•¿åº¦ â‰¥ 8
         *    - æ•°ç»„å®¹é‡ â‰¥ 64
         * 
         * 3. é€€æ ‘åŒ–æ¡ä»¶ï¼š
         *    - çº¢é»‘æ ‘èŠ‚ç‚¹æ•° â‰¤ 6
         * 
         * 4. æ€§èƒ½æå‡ï¼š
         *    - æç«¯æƒ…å†µä¸‹çš„æ€§èƒ½ä¿éšœ
         *    - é˜²æ­¢æ¶æ„å“ˆå¸Œæ”»å‡»
         * 
         * 5. å†…å­˜å¼€é”€ï¼š
         *    - TreeNodeæ¯”Nodeå ç”¨æ›´å¤šå†…å­˜
         *    - åªåœ¨å¿…è¦æ—¶æ‰è¿›è¡Œæ ‘åŒ–
         */
    }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**1. å®¹é‡å’Œè´Ÿè½½å› å­ä¼˜åŒ–**

```java
/**
 * HashMapå®¹é‡ä¼˜åŒ–ç­–ç•¥
 */
public class HashMapCapacityOptimization {
    
    /**
     * æœ€ä½³å®è·µï¼šåˆç†è®¾ç½®åˆå§‹å®¹é‡
     */
    public void capacityOptimizationBestPractices() {
        // âŒ é”™è¯¯åšæ³•ï¼šä½¿ç”¨é»˜è®¤å®¹é‡
        Map<String, String> badMap = new HashMap<>(); // é»˜è®¤16ï¼Œå¯èƒ½é¢‘ç¹æ‰©å®¹
        
        // âœ… æ­£ç¡®åšæ³•ï¼šé¢„ä¼°å®¹é‡
        int expectedSize = 1000;
        int initialCapacity = (int) (expectedSize / 0.75) + 1;
        Map<String, String> goodMap = new HashMap<>(initialCapacity);
        
        // âœ… æ›´å¥½çš„åšæ³•ï¼šä½¿ç”¨å·¥å…·æ–¹æ³•
        Map<String, String> betterMap = new HashMap<>(calculateOptimalCapacity(expectedSize));
    }
    
    private int calculateOptimalCapacity(int expectedSize) {
        // ç¡®ä¿æ˜¯2çš„å¹‚ï¼Œä¸”è€ƒè™‘è´Ÿè½½å› å­
        int capacity = 1;
        int targetCapacity = (int) (expectedSize / 0.75) + 1;
        
        while (capacity < targetCapacity) {
            capacity <<= 1;
        }
        
        return capacity;
    }
}
```

**2. å“ˆå¸Œå‡½æ•°ä¼˜åŒ–**

```java
/**
 * è‡ªå®šä¹‰keyçš„hashCodeä¼˜åŒ–
 */
public class OptimizedHashCodeExample {
    
    /**
     * ä¼˜åŒ–çš„Userç±»hashCodeå®ç°
     */
    public static class User {
        private final String name;
        private final int age;
        private final String email;
        
        // ç¼“å­˜hashCodeï¼Œé¿å…é‡å¤è®¡ç®—
        private volatile int hashCode;
        
        @Override
        public int hashCode() {
            int result = hashCode;
            if (result == 0) {
                result = 17;
                result = 31 * result + (name != null ? name.hashCode() : 0);
                result = 31 * result + age;
                result = 31 * result + (email != null ? email.hashCode() : 0);
                hashCode = result;
            }
            return result;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            
            User user = (User) obj;
            return age == user.age &&
                   Objects.equals(name, user.name) &&
                   Objects.equals(email, user.email);
        }
    }
}
```

### å…³é”®æ³¨æ„äº‹é¡¹

**1. é¿å…å¸¸è§æ€§èƒ½é™·é˜±**

```java
/**
 * HashMapæ€§èƒ½é™·é˜±åŠé¿å…æ–¹æ³•
 */
public class HashMapPerformancePitfalls {
    
    /**
     * é™·é˜±1ï¼šé¢‘ç¹æ‰©å®¹
     */
    public void avoidFrequentResize() {
        // âŒ æ€§èƒ½é™·é˜±ï¼šé¢‘ç¹æ‰©å®¹
        Map<String, String> map = new HashMap<>(); // é»˜è®¤å®¹é‡16
        for (int i = 0; i < 10000; i++) {
            map.put("key" + i, "value" + i); // ä¼šè§¦å‘å¤šæ¬¡æ‰©å®¹
        }
        
        // âœ… ä¼˜åŒ–æ–¹æ¡ˆï¼šé¢„è®¾åˆç†å®¹é‡
        Map<String, String> optimizedMap = new HashMap<>(16384); // 2^14
        for (int i = 0; i < 10000; i++) {
            optimizedMap.put("key" + i, "value" + i); // æ— éœ€æ‰©å®¹
        }
    }
    
    /**
     * é™·é˜±2ï¼šå“ˆå¸Œå†²çªä¸¥é‡
     */
    public void avoidHashCollision() {
        // âŒ æ€§èƒ½é™·é˜±ï¼šä½¿ç”¨å®¹æ˜“å†²çªçš„key
        Map<BadKey, String> badMap = new HashMap<>();
        for (int i = 0; i < 1000; i++) {
            badMap.put(new BadKey(i), "value" + i); // æ‰€æœ‰keyçš„hashCodeéƒ½ç›¸åŒ
        }
        
        // âœ… ä¼˜åŒ–æ–¹æ¡ˆï¼šä½¿ç”¨åˆ†å¸ƒå‡åŒ€çš„key
        Map<GoodKey, String> goodMap = new HashMap<>();
        for (int i = 0; i < 1000; i++) {
            goodMap.put(new GoodKey(i), "value" + i); // hashCodeåˆ†å¸ƒå‡åŒ€
        }
    }
    
    static class BadKey {
        private final int value;
        
        BadKey(int value) { this.value = value; }
        
        @Override
        public int hashCode() {
            return 1; // æ‰€æœ‰å¯¹è±¡éƒ½æœ‰ç›¸åŒçš„hashCode
        }
        
        @Override
        public boolean equals(Object obj) {
            return obj instanceof BadKey && ((BadKey) obj).value == this.value;
        }
    }
    
    static class GoodKey {
        private final int value;
        
        GoodKey(int value) { this.value = value; }
        
        @Override
        public int hashCode() {
            return Integer.hashCode(value); // åˆ†å¸ƒå‡åŒ€çš„hashCode
        }
        
        @Override
        public boolean equals(Object obj) {
            return obj instanceof GoodKey && ((GoodKey) obj).value == this.value;
        }
    }
}
```

## ğŸ“š æ€»ç»“ä¸æŠ€æœ¯å¯¹æ¯”

### æ ¸å¿ƒè¦ç‚¹æ€»ç»“

**HashMapçš„è®¾è®¡ç²¾é«“**ï¼š

1. **å“ˆå¸Œè¡¨å®ç°**ï¼šåŸºäºæ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘çš„æ··åˆç»“æ„
2. **é«˜æ•ˆå“ˆå¸Œç®—æ³•**ï¼šé«˜ä½ä½å¼‚æˆ–è¿ç®—ï¼Œå‡å°‘å“ˆå¸Œå†²çª
3. **åŠ¨æ€æ‰©å®¹æœºåˆ¶**ï¼š2å€æ‰©å®¹ç­–ç•¥ï¼Œä¿æŒè´Ÿè½½å› å­å¹³è¡¡
4. **çº¢é»‘æ ‘ä¼˜åŒ–**ï¼šJDK 1.8çš„é‡å¤§æ”¹è¿›ï¼Œæœ€åæƒ…å†µæ€§èƒ½ä¿éšœ
5. **ä½è¿ç®—ä¼˜åŒ–**ï¼šä½¿ç”¨ä½è¿ç®—æ›¿ä»£å–æ¨¡ï¼Œæå‡è®¡ç®—æ•ˆç‡

### ä¸å…¶ä»–Mapå®ç°å¯¹æ¯”

| ç‰¹æ€§ | HashMap | LinkedHashMap | TreeMap | ConcurrentHashMap |
|------|---------|---------------|---------|-------------------|
| åº•å±‚ç»“æ„ | å“ˆå¸Œè¡¨ | å“ˆå¸Œè¡¨+åŒå‘é“¾è¡¨ | çº¢é»‘æ ‘ | å“ˆå¸Œè¡¨+CAS/é” |
| æ—¶é—´å¤æ‚åº¦ | O(1) | O(1) | O(log n) | O(1) |
| æœ‰åºæ€§ | æ— åº | æ’å…¥/è®¿é—®æœ‰åº | é”®æ’åº | æ— åº |
| çº¿ç¨‹å®‰å…¨ | âŒ | âŒ | âŒ | âœ… |
| nullæ”¯æŒ | âœ… | âœ… | âŒ(key) | âŒ |
| å†…å­˜å ç”¨ | ä½ | ä¸­ | ä¸­ | é«˜ |
| é€‚ç”¨åœºæ™¯ | é€šç”¨é”®å€¼å­˜å‚¨ | ç¼“å­˜LRU | æ’åºéœ€æ±‚ | é«˜å¹¶å‘åœºæ™¯ |

### æœ€ä½³å®è·µå»ºè®®

**é€‰æ‹©HashMapçš„åœºæ™¯**ï¼š
- éœ€è¦é«˜æ€§èƒ½çš„é”®å€¼æŸ¥æ‰¾æ“ä½œ
- å¯¹é¡ºåºæ²¡æœ‰ç‰¹æ®Šè¦æ±‚
- å•çº¿ç¨‹æˆ–å¤–éƒ¨åŒæ­¥çš„ç¯å¢ƒ
- å†…å­˜ä½¿ç”¨æ•ˆç‡è¦æ±‚è¾ƒé«˜

**æ€§èƒ½ä¼˜åŒ–è¦ç‚¹**ï¼š
- åˆç†é¢„ä¼°åˆå§‹å®¹é‡ï¼Œé¿å…é¢‘ç¹æ‰©å®¹
- ç¡®ä¿keyçš„hashCodeåˆ†å¸ƒå‡åŒ€
- é¿å…åœ¨é«˜å†²çªåœºæ™¯ä¸‹ä½¿ç”¨
- é€‰æ‹©åˆé€‚çš„è´Ÿè½½å› å­
- è€ƒè™‘ä½¿ç”¨ä¸“é—¨çš„Mapå®ç°

**çº¿ç¨‹å®‰å…¨å»ºè®®**ï¼š
- å•çº¿ç¨‹ï¼šç›´æ¥ä½¿ç”¨HashMap
- è¯»å¤šå†™å°‘ï¼šè€ƒè™‘CopyOnWriteMap
- é«˜å¹¶å‘ï¼šä½¿ç”¨ConcurrentHashMap
- ç®€å•åŒæ­¥ï¼šCollections.synchronizedMap

HashMapä½œä¸ºJavaé›†åˆæ¡†æ¶çš„æ ¸å¿ƒç»„ä»¶ï¼Œå…¶ç²¾å¦™çš„è®¾è®¡å’ŒæŒç»­çš„ä¼˜åŒ–ä¸ºJavaåº”ç”¨æä¾›äº†é«˜æ•ˆçš„é”®å€¼å­˜å‚¨èƒ½åŠ›ã€‚æ·±å…¥ç†è§£å…¶å®ç°åŸç†å’Œæ€§èƒ½ç‰¹æ€§ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬åœ¨å®é™…é¡¹ç›®ä¸­åšå‡ºæ›´å¥½çš„æŠ€æœ¯é€‰æ‹©å’Œæ€§èƒ½ä¼˜åŒ–å†³ç­–ã€‚