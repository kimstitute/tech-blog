---
title: "ArrayListæºç è§£æä¸æ€§èƒ½ä¼˜åŒ–å®æˆ˜"
description: "æ·±å…¥è§£æArrayListçš„åº•å±‚å®ç°åŸç†ã€æ‰©å®¹æœºåˆ¶å’Œè¿­ä»£å™¨è®¾è®¡ã€‚ç»“åˆå®é™…é¡¹ç›®åœºæ™¯åˆ†ææ€§èƒ½ç“¶é¢ˆä¸ä¼˜åŒ–ç­–ç•¥ï¼Œå¯¹æ¯”LinkedListç­‰é›†åˆç±»çš„é€‚ç”¨åœºæ™¯ï¼ŒæŒæ¡Javaé›†åˆæ¡†æ¶çš„æ ¸å¿ƒè®¾è®¡æ€æƒ³ã€‚"
pubDate: 2024-12-06
updatedDate: 2024-12-06
tags: ["java", "arraylist", "collections", "performance", "source-code", "optimization", "interview", "best-practices"]
categories: ["java-core"]
subject: "é›†åˆæ¡†æ¶"
draft: false
featured: true
author: "Gerrad Zhang"
location: "æ­¦æ±‰ï¼Œä¸­å›½"
---

## ğŸ¤” é—®é¢˜èƒŒæ™¯ä¸æŠ€æœ¯æ¼”è¿›

### æˆ‘ä»¬è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

åœ¨Javaå¼€å‘ä¸­ï¼Œ**åŠ¨æ€æ•°ç»„ç®¡ç†**æ˜¯ä¸€ä¸ªåŸºç¡€éœ€æ±‚ã€‚åŸç”Ÿæ•°ç»„è™½ç„¶æ€§èƒ½ä¼˜å¼‚ï¼Œä½†å­˜åœ¨æ˜æ˜¾çš„å±€é™æ€§ï¼š

- **å›ºå®šé•¿åº¦**ï¼šæ•°ç»„åˆ›å»ºåé•¿åº¦ä¸å¯å˜ï¼Œæ— æ³•åŠ¨æ€è°ƒæ•´å¤§å°
- **ç±»å‹é™åˆ¶**ï¼šåªèƒ½å­˜å‚¨åŒä¸€ç±»å‹çš„å…ƒç´ ï¼Œç¼ºä¹æ³›å‹æ”¯æŒ
- **æ“ä½œå¤æ‚**ï¼šæ’å…¥ã€åˆ é™¤æ“ä½œéœ€è¦æ‰‹åŠ¨ç§»åŠ¨å…ƒç´ ï¼Œä»£ç å†—ä½™
- **è¾¹ç•Œæ£€æŸ¥**ï¼šéœ€è¦æ‰‹åŠ¨å¤„ç†æ•°ç»„è¶Šç•Œé—®é¢˜ï¼Œå®¹æ˜“å‡ºé”™
- **å†…å­˜æµªè´¹**ï¼šé¢„åˆ†é…å›ºå®šå¤§å°å¯èƒ½é€ æˆå†…å­˜æµªè´¹æˆ–ä¸è¶³

```java
// åŸç”Ÿæ•°ç»„çš„å±€é™æ€§ç¤ºä¾‹
public class ArrayLimitations {
    
    // âŒ é—®é¢˜ï¼šå›ºå®šé•¿åº¦ï¼Œæ— æ³•åŠ¨æ€æ‰©å®¹
    public void fixedSizeIssue() {
        String[] names = new String[10]; // å›ºå®š10ä¸ªå…ƒç´ 
        
        // å¦‚æœéœ€è¦å­˜å‚¨ç¬¬11ä¸ªå…ƒç´ ï¼Œå¿…é¡»åˆ›å»ºæ–°æ•°ç»„
        if (currentSize >= names.length) {
            String[] newNames = new String[names.length * 2];
            System.arraycopy(names, 0, newNames, 0, names.length);
            names = newNames; // æ‰‹åŠ¨æ‰©å®¹ï¼Œä»£ç å¤æ‚
        }
    }
    
    // âŒ é—®é¢˜ï¼šæ’å…¥åˆ é™¤æ“ä½œå¤æ‚
    public void insertDeleteComplexity() {
        int[] numbers = {1, 2, 3, 4, 5};
        
        // åœ¨ç´¢å¼•2ä½ç½®æ’å…¥å…ƒç´ 99
        int insertIndex = 2;
        int newValue = 99;
        
        // éœ€è¦æ‰‹åŠ¨ç§»åŠ¨å…ƒç´ 
        for (int i = numbers.length - 1; i > insertIndex; i--) {
            numbers[i] = numbers[i - 1];
        }
        numbers[insertIndex] = newValue;
    }
}
```

### æ²¡æœ‰è¿™ä¸ªæŠ€æœ¯æ—¶æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ

åœ¨ArrayListå‡ºç°ä¹‹å‰ï¼ŒJavaå¼€å‘è€…ä¸»è¦é€šè¿‡ä»¥ä¸‹æ–¹å¼ç®¡ç†åŠ¨æ€æ•°ç»„ï¼š

**1. Vectorç±»**
- Java 1.0å°±å­˜åœ¨çš„åŠ¨æ€æ•°ç»„å®ç°
- **é—®é¢˜**ï¼šæ‰€æœ‰æ–¹æ³•éƒ½æ˜¯synchronizedï¼Œæ€§èƒ½å¼€é”€å¤§

**2. æ‰‹å·¥åŠ¨æ€æ•°ç»„**
- è‡ªå·±å®ç°æ•°ç»„æ‰©å®¹å’Œå…ƒç´ ç®¡ç†é€»è¾‘
- **é—®é¢˜**ï¼šä»£ç å¤æ‚ï¼Œå®¹æ˜“å‡ºbugï¼Œç¼ºä¹æ ‡å‡†åŒ–

**3. é“¾è¡¨ç»“æ„**
- ä½¿ç”¨è‡ªå®šä¹‰çš„é“¾è¡¨èŠ‚ç‚¹ç®¡ç†å…ƒç´ 
- **é—®é¢˜**ï¼šéšæœºè®¿é—®æ€§èƒ½å·®ï¼Œå†…å­˜å¼€é”€å¤§

### æŠ€æœ¯æ¼”è¿›çš„å†å²è„‰ç»œ

**JDK 1.2 (1998)**ï¼šCollections Frameworkå¼•å…¥
- ArrayListä½œä¸ºVectorçš„éåŒæ­¥ç‰ˆæœ¬ç™»åœº
- å¼•å…¥æ³›å‹å‰èº«çš„Object[]å­˜å‚¨ï¼Œéœ€è¦æ‰‹åŠ¨ç±»å‹è½¬æ¢
- æä¾›Iteratoræ¥å£ï¼Œç»Ÿä¸€é›†åˆéå†æ–¹å¼

**JDK 1.5 (2004)**ï¼šæ³›å‹æ”¯æŒ
- `ArrayList<T>`æä¾›ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
- è‡ªåŠ¨è£…ç®±/æ‹†ç®±ç®€åŒ–åŸºæœ¬ç±»å‹æ“ä½œ
- å¢å¼ºforå¾ªç¯(for-each)æ”¯æŒ

**JDK 1.8 (2014)**ï¼šLambdaä¸Stream
- Lambdaè¡¨è¾¾å¼å’ŒStream APIé›†æˆ
- å¹¶è¡Œæµå¤„ç†æ”¯æŒ
- å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼å¼•å…¥

**JDK 9+ (2017-ç°åœ¨)**ï¼šæŒç»­ä¼˜åŒ–
- æ¨¡å—ç³»ç»Ÿæ”¯æŒï¼Œæ›´å¥½çš„å°è£…æ€§
- æŒç»­çš„æ€§èƒ½ä¼˜åŒ–å’Œå†…å­˜ä½¿ç”¨æ”¹è¿›
- ä¸æ–°çš„å¹¶å‘ç‰¹æ€§é›†æˆ

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µä¸åŸç†

### åŸºç¡€æ¦‚å¿µå®šä¹‰

**ArrayList**æ˜¯Javaé›†åˆæ¡†æ¶ä¸­åŸºäºåŠ¨æ€æ•°ç»„å®ç°çš„å¯å˜é•¿åº¦åˆ—è¡¨ï¼Œæä¾›äº†å¯¹å…ƒç´ çš„éšæœºè®¿é—®ã€åŠ¨æ€æ‰©å®¹å’Œç±»å‹å®‰å…¨çš„æ“ä½œã€‚

**æ ¸å¿ƒç‰¹æ€§**ï¼š
- **åŠ¨æ€æ‰©å®¹**ï¼šæ ¹æ®éœ€è¦è‡ªåŠ¨è°ƒæ•´åº•å±‚æ•°ç»„å¤§å°
- **éšæœºè®¿é—®**ï¼šåŸºäºç´¢å¼•çš„O(1)æ—¶é—´å¤æ‚åº¦è®¿é—®
- **ç±»å‹å®‰å…¨**ï¼šæ³›å‹æ”¯æŒæä¾›ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
- **æœ‰åºæ€§**ï¼šä¿æŒå…ƒç´ æ’å…¥é¡ºåºï¼Œæ”¯æŒé‡å¤å…ƒç´ 

### ArrayListæ ¸å¿ƒæ¶æ„

**åº•å±‚æ•°æ®ç»“æ„**ï¼š

```java
/**
 * ArrayListæ ¸å¿ƒæ•°æ®ç»“æ„åˆ†æ
 */
public class ArrayListStructureAnalysis {
    
    /**
     * ArrayListçš„æ ¸å¿ƒå­—æ®µï¼ˆç®€åŒ–ç‰ˆæºç åˆ†æï¼‰
     */
    public void analyzeArrayListFields() {
        /*
         * public class ArrayList<E> extends AbstractList<E>
         *         implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
         *     
         *     // é»˜è®¤åˆå§‹å®¹é‡
         *     private static final int DEFAULT_CAPACITY = 10;
         *     
         *     // ç©ºæ•°ç»„å®ä¾‹ï¼Œç”¨äºç©ºå®ä¾‹
         *     private static final Object[] EMPTY_ELEMENTDATA = {};
         *     
         *     // é»˜è®¤å¤§å°çš„ç©ºæ•°ç»„å®ä¾‹
         *     private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
         *     
         *     // å­˜å‚¨ArrayListå…ƒç´ çš„æ•°ç»„ç¼“å†²åŒº
         *     transient Object[] elementData;
         *     
         *     // ArrayListçš„å¤§å°ï¼ˆåŒ…å«çš„å…ƒç´ æ•°é‡ï¼‰
         *     private int size;
         *     
         *     // æ•°ç»„æœ€å¤§å®¹é‡
         *     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
         * }
         */
    }
    
    /**
     * ArrayListçš„ä¸‰ç§æ„é€ æ–¹å¼
     */
    public void demonstrateConstructors() {
        // 1. é»˜è®¤æ„é€ å™¨ - å»¶è¿Ÿåˆå§‹åŒ–
        ArrayList<String> list1 = new ArrayList<>();
        /*
         * åˆå§‹æ—¶elementDataæŒ‡å‘DEFAULTCAPACITY_EMPTY_ELEMENTDATA
         * é¦–æ¬¡æ·»åŠ å…ƒç´ æ—¶æ‰åˆ†é…DEFAULT_CAPACITY(10)å¤§å°çš„æ•°ç»„
         */
        
        // 2. æŒ‡å®šåˆå§‹å®¹é‡
        ArrayList<String> list2 = new ArrayList<>(20);
        /*
         * ç›´æ¥åˆ›å»ºæŒ‡å®šå¤§å°çš„æ•°ç»„
         * å¦‚æœinitialCapacity > 0ï¼Œåˆ›å»ºè¯¥å¤§å°çš„æ•°ç»„
         * å¦‚æœinitialCapacity == 0ï¼Œä½¿ç”¨EMPTY_ELEMENTDATA
         */
        
        // 3. ä»å…¶ä»–é›†åˆåˆ›å»º
        List<String> sourceList = Arrays.asList("a", "b", "c");
        ArrayList<String> list3 = new ArrayList<>(sourceList);
        /*
         * å°†æºé›†åˆè½¬æ¢ä¸ºæ•°ç»„ï¼Œç„¶åå¤åˆ¶åˆ°æ–°çš„ArrayListä¸­
         * å¦‚æœæºé›†åˆä¸ºç©ºï¼Œä½¿ç”¨EMPTY_ELEMENTDATA
         */
    }
}
```

### æ‰©å®¹æœºåˆ¶è¯¦è§£

**ArrayListæœ€æ ¸å¿ƒçš„ç‰¹æ€§ä¹‹ä¸€**ï¼š

```java
/**
 * ArrayListæ‰©å®¹æœºåˆ¶æ·±åº¦åˆ†æ
 */
public class ArrayListGrowthMechanism {
    
    /**
     * æ‰©å®¹è§¦å‘æ¡ä»¶å’Œæµç¨‹
     */
    public void analyzeGrowthProcess() {
        /*
         * æ‰©å®¹è§¦å‘æ—¶æœºï¼š
         * 1. è°ƒç”¨add()æ–¹æ³•æ—¶ï¼Œsize >= elementData.length
         * 2. è°ƒç”¨addAll()æ–¹æ³•æ—¶ï¼Œsize + æ–°å¢å…ƒç´ æ•°é‡ > elementData.length
         * 3. è°ƒç”¨ensureCapacity()æ–¹æ³•æ‰‹åŠ¨è§¦å‘
         * 
         * æ‰©å®¹æµç¨‹ï¼š
         * 1. è®¡ç®—æ–°å®¹é‡ï¼šé€šå¸¸æ˜¯åŸå®¹é‡çš„1.5å€
         * 2. åˆ›å»ºæ–°æ•°ç»„ï¼šä½¿ç”¨Arrays.copyOf()
         * 3. å¤åˆ¶å…ƒç´ ï¼šå°†åŸæ•°ç»„å…ƒç´ å¤åˆ¶åˆ°æ–°æ•°ç»„
         * 4. æ›´æ–°å¼•ç”¨ï¼šelementDataæŒ‡å‘æ–°æ•°ç»„
         */
    }
    
    /**
     * æ‰©å®¹ç®—æ³•è¯¦è§£
     */
    public void explainGrowthAlgorithm() {
        /*
         * æ ¸å¿ƒæ‰©å®¹æ–¹æ³•grow()çš„é€»è¾‘ï¼š
         * 
         * private Object[] grow(int minCapacity) {
         *     int oldCapacity = elementData.length;
         *     int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5å€æ‰©å®¹
         *     
         *     if (newCapacity - minCapacity <= 0) {
         *         if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
         *             return new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
         *         if (minCapacity < 0) // overflow
         *             throw new OutOfMemoryError();
         *         return new Object[minCapacity];
         *     }
         *     
         *     return (newCapacity - MAX_ARRAY_SIZE <= 0)
         *         ? new Object[newCapacity]
         *         : hugeCapacity(minCapacity);
         * }
         * 
         * æ‰©å®¹ç­–ç•¥åˆ†æï¼š
         * 1. æ­£å¸¸æƒ…å†µï¼šnewCapacity = oldCapacity * 1.5
         * 2. é¦–æ¬¡æ‰©å®¹ï¼šä»ç©ºæ•°ç»„æ‰©å®¹åˆ°DEFAULT_CAPACITY(10)
         * 3. è¶…å¤§å®¹é‡ï¼šæ¥è¿‘Integer.MAX_VALUEæ—¶çš„ç‰¹æ®Šå¤„ç†
         */
    }
    
    /**
     * æ‰©å®¹æ€§èƒ½åˆ†æ
     */
    public void analyzeGrowthPerformance() {
        /*
         * æ—¶é—´å¤æ‚åº¦åˆ†æï¼š
         * 1. å•æ¬¡æ‰©å®¹ï¼šO(n) - éœ€è¦å¤åˆ¶æ‰€æœ‰ç°æœ‰å…ƒç´ 
         * 2. æ‘Šè¿˜åˆ†æï¼šO(1) - å¹³å‡æ¯æ¬¡addæ“ä½œçš„æ—¶é—´å¤æ‚åº¦
         * 
         * ç©ºé—´å¤æ‚åº¦ï¼š
         * 1. é¢å¤–ç©ºé—´ï¼šä¸´æ—¶éœ€è¦2å€çš„å†…å­˜ç©ºé—´ï¼ˆæ–°æ—§æ•°ç»„åŒæ—¶å­˜åœ¨ï¼‰
         * 2. å†…å­˜åˆ©ç”¨ç‡ï¼šæœ€åæƒ…å†µä¸‹åªä½¿ç”¨äº†50%çš„å®¹é‡
         * 
         * æ€§èƒ½ä¼˜åŒ–å»ºè®®ï¼š
         * 1. é¢„ä¼°å®¹é‡ï¼šæ„é€ æ—¶æŒ‡å®šåˆç†çš„åˆå§‹å®¹é‡
         * 2. æ‰‹åŠ¨æ‰©å®¹ï¼šä½¿ç”¨ensureCapacity()é¢„åˆ†é…ç©ºé—´
         * 3. æ‰¹é‡æ“ä½œï¼šä½¿ç”¨addAll()è€Œéå¤šæ¬¡add()
         */
    }
}
```

### æ ¸å¿ƒæ“ä½œå®ç°

**å¢åˆ æ”¹æŸ¥æ“ä½œçš„å®ç°åŸç†**ï¼š

```java
/**
 * ArrayListæ ¸å¿ƒæ“ä½œå®ç°åˆ†æ
 */
public class ArrayListOperations {
    
    /**
     * æ·»åŠ å…ƒç´ æ“ä½œåˆ†æ
     */
    public void analyzeAddOperations() {
        /*
         * 1. add(E e) - å°¾éƒ¨æ·»åŠ 
         * public boolean add(E e) {
         *     modCount++;                    // ä¿®æ”¹æ¬¡æ•°+1ï¼Œç”¨äºfail-fast
         *     add(e, elementData, size);     // è°ƒç”¨å†…éƒ¨addæ–¹æ³•
         *     return true;
         * }
         * 
         * private void add(E e, Object[] elementData, int s) {
         *     if (s == elementData.length)
         *         elementData = grow();      // å®¹é‡ä¸è¶³æ—¶æ‰©å®¹
         *     elementData[s] = e;           // ç›´æ¥èµ‹å€¼
         *     size = s + 1;                 // æ›´æ–°size
         * }
         * 
         * æ—¶é—´å¤æ‚åº¦ï¼š
         * - æœ€å¥½æƒ…å†µï¼šO(1) - å®¹é‡å……è¶³æ—¶
         * - æœ€åæƒ…å†µï¼šO(n) - éœ€è¦æ‰©å®¹æ—¶
         * - å¹³å‡æƒ…å†µï¼šO(1) - æ‘Šè¿˜åˆ†æ
         */
        
        /*
         * 2. add(int index, E element) - æŒ‡å®šä½ç½®æ’å…¥
         * public void add(int index, E element) {
         *     rangeCheckForAdd(index);       // è¾¹ç•Œæ£€æŸ¥
         *     modCount++;
         *     final int s;
         *     Object[] elementData;
         *     if ((s = size) == (elementData = this.elementData).length)
         *         elementData = grow();      // æ‰©å®¹æ£€æŸ¥
         *     System.arraycopy(elementData, index,
         *                      elementData, index + 1,
         *                      s - index);   // ç§»åŠ¨å…ƒç´ 
         *     elementData[index] = element;  // æ’å…¥æ–°å…ƒç´ 
         *     size = s + 1;
         * }
         * 
         * æ—¶é—´å¤æ‚åº¦ï¼šO(n) - éœ€è¦ç§»åŠ¨indexåçš„æ‰€æœ‰å…ƒç´ 
         */
    }
    
    /**
     * åˆ é™¤å…ƒç´ æ“ä½œåˆ†æ
     */
    public void analyzeRemoveOperations() {
        /*
         * 1. remove(int index) - æŒ‰ç´¢å¼•åˆ é™¤
         * public E remove(int index) {
         *     Objects.checkIndex(index, size);  // è¾¹ç•Œæ£€æŸ¥
         *     final Object[] es = elementData;
         *     @SuppressWarnings("unchecked") E oldValue = (E) es[index];
         *     fastRemove(es, index);             // å¿«é€Ÿåˆ é™¤
         *     return oldValue;
         * }
         * 
         * private void fastRemove(Object[] es, int i) {
         *     modCount++;
         *     final int newSize;
         *     if ((newSize = size - 1) > i)
         *         System.arraycopy(es, i + 1, es, i, newSize - i); // ç§»åŠ¨å…ƒç´ 
         *     es[size = newSize] = null;         // æ¸…é™¤å¼•ç”¨ï¼Œé¿å…å†…å­˜æ³„æ¼
         * }
         * 
         * æ—¶é—´å¤æ‚åº¦ï¼šO(n) - éœ€è¦ç§»åŠ¨indexåçš„æ‰€æœ‰å…ƒç´ 
         */
        
        /*
         * 2. remove(Object o) - æŒ‰å¯¹è±¡åˆ é™¤
         * public boolean remove(Object o) {
         *     final Object[] es = elementData;
         *     final int size = this.size;
         *     int i = 0;
         *     found: {
         *         if (o == null) {
         *             for (; i < size; i++)
         *                 if (es[i] == null)
         *                     break found;
         *         } else {
         *             for (; i < size; i++)
         *                 if (o.equals(es[i]))  // ä½¿ç”¨equalsæ¯”è¾ƒ
         *                     break found;
         *         }
         *         return false;
         *     }
         *     fastRemove(es, i);
         *     return true;
         * }
         * 
         * æ—¶é—´å¤æ‚åº¦ï¼šO(n) - éœ€è¦éå†æŸ¥æ‰¾ + å¯èƒ½çš„å…ƒç´ ç§»åŠ¨
         */
    }
    
    /**
     * æŸ¥è¯¢æ“ä½œåˆ†æ
     */
    public void analyzeGetOperations() {
        /*
         * 1. get(int index) - éšæœºè®¿é—®
         * public E get(int index) {
         *     Objects.checkIndex(index, size);  // è¾¹ç•Œæ£€æŸ¥
         *     return elementData(index);         // ç›´æ¥æ•°ç»„è®¿é—®
         * }
         * 
         * E elementData(int index) {
         *     return (E) elementData[index];     // O(1)æ—¶é—´å¤æ‚åº¦
         * }
         * 
         * æ—¶é—´å¤æ‚åº¦ï¼šO(1) - æ•°ç»„éšæœºè®¿é—®çš„ä¼˜åŠ¿
         */
        
        /*
         * 2. indexOf(Object o) - æŸ¥æ‰¾å…ƒç´ ä½ç½®
         * public int indexOf(Object o) {
         *     return indexOfRange(o, 0, size);
         * }
         * 
         * int indexOfRange(Object o, int start, int end) {
         *     Object[] es = elementData;
         *     if (o == null) {
         *         for (int i = start; i < end; i++) {
         *             if (es[i] == null) {
         *                 return i;
         *             }
         *         }
         *     } else {
         *         for (int i = start; i < end; i++) {
         *             if (o.equals(es[i])) {  // çº¿æ€§æŸ¥æ‰¾
         *                 return i;
         *             }
         *         }
         *     }
         *     return -1;
         * }
         * 
         * æ—¶é—´å¤æ‚åº¦ï¼šO(n) - æœ€åæƒ…å†µéœ€è¦éå†æ•´ä¸ªæ•°ç»„
         */
    }
}

## ğŸ”§ å®ç°åŸç†ä¸æºç åˆ†æ

### fail-fastæœºåˆ¶è¯¦è§£

**ArrayListçš„å¹¶å‘å®‰å…¨ä¿éšœ**ï¼š

```java
/**
 * fail-fastæœºåˆ¶å®ç°åˆ†æ
 */
public class FailFastMechanism {
    
    /**
     * Iteratorçš„fail-fastå®ç°
     */
    public void analyzeIteratorFailFast() {
        /*
         * ArrayListçš„å†…éƒ¨Iteratorç±»ï¼š
         * 
         * private class Itr implements Iterator<E> {
         *     int cursor;       // ä¸‹ä¸€ä¸ªè¦è¿”å›çš„å…ƒç´ ç´¢å¼•
         *     int lastRet = -1; // æœ€åä¸€ä¸ªè¿”å›çš„å…ƒç´ ç´¢å¼•
         *     int expectedModCount = modCount; // æœŸæœ›çš„ä¿®æ”¹æ¬¡æ•°
         *     
         *     public E next() {
         *         checkForComodification(); // æ£€æŸ¥å¹¶å‘ä¿®æ”¹
         *         int i = cursor;
         *         if (i >= size)
         *             throw new NoSuchElementException();
         *         Object[] elementData = ArrayList.this.elementData;
         *         if (i >= elementData.length)
         *             throw new ConcurrentModificationException();
         *         cursor = i + 1;
         *         return (E) elementData[lastRet = i];
         *     }
         *     
         *     final void checkForComodification() {
         *         if (modCount != expectedModCount)
         *             throw new ConcurrentModificationException();
         *     }
         * }
         */
    }
}
```

### å†…å­˜ç®¡ç†æœºåˆ¶

```java
/**
 * ArrayListå†…å­˜ç®¡ç†åˆ†æ
 */
public class ArrayListMemoryManagement {
    
    /**
     * å†…å­˜ä¼˜åŒ–ç­–ç•¥
     */
    public void memoryOptimizationStrategies() {
        // 1. åˆç†è®¾ç½®åˆå§‹å®¹é‡
        int expectedSize = 1000;
        ArrayList<String> optimizedList = new ArrayList<>(expectedSize);
        
        // 2. ä½¿ç”¨trimToSize()é‡Šæ”¾å¤šä½™ç©ºé—´
        ArrayList<String> list = new ArrayList<>();
        // ... æ·»åŠ å’Œåˆ é™¤æ“ä½œ
        list.trimToSize(); // å°†å®¹é‡è°ƒæ•´ä¸ºå½“å‰å¤§å°
        
        // 3. æ‰¹é‡æ“ä½œä¼˜åŒ–
        List<String> sourceData = getSourceData();
        ArrayList<String> targetList = new ArrayList<>(sourceData.size());
        targetList.addAll(sourceData); // æ¯”å¤šæ¬¡add()æ›´é«˜æ•ˆ
    }
}
```

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹ä¸ä»£ç ç¤ºä¾‹

### å…·ä½“é¡¹ç›®åº”ç”¨

**åœºæ™¯1ï¼šå¤§æ•°æ®é‡å¤„ç†ä¼˜åŒ–**

```java
/**
 * å¤§æ•°æ®é‡ArrayListå¤„ç†ä¼˜åŒ–
 */
@Service
public class LargeDataProcessor {
    
    /**
     * ä¼˜åŒ–åï¼šé«˜æ€§èƒ½å®ç°
     */
    public List<ProcessedData> processDataOptimized(List<RawData> rawDataList) {
        if (rawDataList == null || rawDataList.isEmpty()) {
            return Collections.emptyList();
        }
        
        // âœ… ä¼˜åŒ–1ï¼šé¢„è®¾åˆç†å®¹é‡ï¼Œé¿å…æ‰©å®¹
        int estimatedSize = (int) (rawDataList.size() * 0.8);
        List<ProcessedData> result = new ArrayList<>(estimatedSize);
        
        // âœ… ä¼˜åŒ–2ï¼šä½¿ç”¨Stream APIå¹¶è¡Œå¤„ç†
        List<ProcessedData> processedData = rawDataList.parallelStream()
            .filter(this::isValidData)
            .map(this::processData)
            .collect(Collectors.toCollection(() -> new ArrayList<>(estimatedSize)));
        
        return processedData;
    }
    
    /**
     * æ‰¹é‡å¤„ç†ä¼˜åŒ–
     */
    public List<ProcessedData> processBatchData(List<RawData> rawDataList, int batchSize) {
        List<ProcessedData> result = new ArrayList<>(rawDataList.size());
        
        // åˆ†æ‰¹å¤„ç†ï¼Œé¿å…å†…å­˜å‹åŠ›
        for (int i = 0; i < rawDataList.size(); i += batchSize) {
            int endIndex = Math.min(i + batchSize, rawDataList.size());
            List<RawData> batch = rawDataList.subList(i, endIndex);
            
            List<ProcessedData> batchResult = processBatch(batch);
            result.addAll(batchResult);
        }
        
        // ä¼˜åŒ–ï¼šé‡Šæ”¾å¤šä½™å®¹é‡
        if (result.size() < result.size() * 0.75) {
            ((ArrayList<ProcessedData>) result).trimToSize();
        }
        
        return result;
    }
}
```

**åœºæ™¯2ï¼šåˆ†é¡µæŸ¥è¯¢ç»“æœç®¡ç†**

```java
/**
 * åˆ†é¡µæŸ¥è¯¢ç»“æœç®¡ç†
 */
@Service
public class PagedResultManager<T> {
    
    private final ArrayList<T> allResults;
    private final int pageSize;
    
    public PagedResultManager(int pageSize) {
        this.pageSize = pageSize;
        this.allResults = new ArrayList<>();
    }
    
    /**
     * æ·»åŠ æŸ¥è¯¢ç»“æœé¡µ
     */
    public void addPage(List<T> pageData) {
        if (pageData != null && !pageData.isEmpty()) {
            // é¢„åˆ†é…ç©ºé—´é¿å…é¢‘ç¹æ‰©å®¹
            allResults.ensureCapacity(allResults.size() + pageData.size());
            allResults.addAll(pageData);
        }
    }
    
    /**
     * è·å–æŒ‡å®šé¡µçš„æ•°æ®
     */
    public List<T> getPage(int pageNumber) {
        int startIndex = pageNumber * pageSize;
        int endIndex = Math.min(startIndex + pageSize, allResults.size());
        
        if (startIndex >= allResults.size()) {
            return Collections.emptyList();
        }
        
        // è¿”å›è§†å›¾ï¼Œé¿å…æ•°æ®å¤åˆ¶
        return allResults.subList(startIndex, endIndex);
    }
    
    /**
     * è·å–åˆ†é¡µç»Ÿè®¡ä¿¡æ¯
     */
    public PageInfo getPageInfo() {
        int totalElements = allResults.size();
        int totalPages = (int) Math.ceil((double) totalElements / pageSize);
        
                 return PageInfo.builder()
             .totalElements(totalElements)
             .totalPages(totalPages)
             .pageSize(pageSize)
             .build();
     }
 }
 ```

## ğŸ¯ é¢è¯•é«˜é¢‘é—®é¢˜ç²¾è®²

### æ ¸å¿ƒé¢è¯•é—®é¢˜

**é—®é¢˜1ï¼šArrayListå’ŒLinkedListçš„åŒºåˆ«åŠé€‰æ‹©åœºæ™¯**

```java
/**
 * ArrayList vs LinkedList å¯¹æ¯”åˆ†æ
 */
public class ArrayListVsLinkedListComparison {
    
    /**
     * æ€§èƒ½å¯¹æ¯”æµ‹è¯•
     */
    public void performanceComparison() {
        int size = 100000;
        
        // ArrayListæ€§èƒ½æµ‹è¯•
        List<Integer> arrayList = new ArrayList<>(size);
        long startTime = System.nanoTime();
        
        // 1. é¡ºåºæ·»åŠ æµ‹è¯•
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
        }
        long arrayListAddTime = System.nanoTime() - startTime;
        
        // 2. éšæœºè®¿é—®æµ‹è¯•
        startTime = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            int randomIndex = (int) (Math.random() * size);
            arrayList.get(randomIndex);
        }
        long arrayListGetTime = System.nanoTime() - startTime;
        
        // 3. ä¸­é—´æ’å…¥æµ‹è¯•
        startTime = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            arrayList.add(size / 2, i);
        }
        long arrayListInsertTime = System.nanoTime() - startTime;
        
        /*
         * æ€§èƒ½å¯¹æ¯”ç»“æœåˆ†æï¼š
         * 
         * ArrayListä¼˜åŠ¿ï¼š
         * 1. éšæœºè®¿é—®ï¼šO(1) vs LinkedListçš„O(n)
         * 2. å†…å­˜å ç”¨ï¼šåªå­˜å‚¨å…ƒç´ ï¼ŒLinkedListéœ€è¦é¢å¤–çš„prev/nextæŒ‡é’ˆ
         * 3. ç¼“å­˜å‹å¥½ï¼šè¿ç»­å†…å­˜å¸ƒå±€ï¼ŒCPUç¼“å­˜å‘½ä¸­ç‡é«˜
         * 
         * LinkedListä¼˜åŠ¿ï¼š
         * 1. æ’å…¥/åˆ é™¤ï¼šO(1) vs ArrayListçš„O(n)ï¼ˆéœ€è¦ç§»åŠ¨å…ƒç´ ï¼‰
         * 2. æ— éœ€é¢„åˆ†é…ï¼šåŠ¨æ€åˆ†é…ï¼Œä¸ä¼šæµªè´¹å†…å­˜
         * 3. æ— æ‰©å®¹å¼€é”€ï¼šä¸éœ€è¦å¤åˆ¶æ•´ä¸ªæ•°ç»„
         * 
         * é€‰æ‹©å»ºè®®ï¼š
         * - é¢‘ç¹éšæœºè®¿é—®ï¼šé€‰æ‹©ArrayList
         * - é¢‘ç¹æ’å…¥/åˆ é™¤ï¼šé€‰æ‹©LinkedList
         * - å†…å­˜æ•æ„Ÿï¼šé€‰æ‹©ArrayList
         * - ä¸ç¡®å®šå¤§å°ä¸”å˜åŒ–é¢‘ç¹ï¼šé€‰æ‹©LinkedList
         */
    }
}
```

**é—®é¢˜2ï¼šArrayListçš„æ‰©å®¹æœºåˆ¶è¯¦è§£**

```java
/**
 * ArrayListæ‰©å®¹æœºåˆ¶é¢è¯•è¦ç‚¹
 */
public class ArrayListGrowthMechanismInterview {
    
    /**
     * æ‰©å®¹æœºåˆ¶æ ¸å¿ƒè¦ç‚¹
     */
    public void explainGrowthMechanism() {
        /*
         * é¢è¯•æ ‡å‡†ç­”æ¡ˆï¼š
         * 
         * 1. è§¦å‘æ¡ä»¶ï¼š
         *    - å½“å‰sizeè¾¾åˆ°elementData.lengthæ—¶è§¦å‘æ‰©å®¹
         *    - è°ƒç”¨ensureCapacity()æ‰‹åŠ¨è§¦å‘
         * 
         * 2. æ‰©å®¹ç®—æ³•ï¼š
         *    - æ–°å®¹é‡ = åŸå®¹é‡ + (åŸå®¹é‡ >> 1) = åŸå®¹é‡ * 1.5
         *    - é¦–æ¬¡æ‰©å®¹ï¼šç©ºæ•°ç»„æ‰©å®¹åˆ°DEFAULT_CAPACITY(10)
         *    - æœ€å¤§å®¹é‡ï¼šInteger.MAX_VALUE - 8
         * 
         * 3. æ‰©å®¹è¿‡ç¨‹ï¼š
         *    - è®¡ç®—æ–°å®¹é‡
         *    - åˆ›å»ºæ–°æ•°ç»„ï¼šArrays.copyOf(elementData, newCapacity)
         *    - å¤åˆ¶å…ƒç´ ï¼šSystem.arraycopy()
         *    - æ›´æ–°å¼•ç”¨ï¼šelementDataæŒ‡å‘æ–°æ•°ç»„
         * 
         * 4. æ€§èƒ½å½±å“ï¼š
         *    - æ—¶é—´å¤æ‚åº¦ï¼šO(n) - éœ€è¦å¤åˆ¶æ‰€æœ‰å…ƒç´ 
         *    - ç©ºé—´å¤æ‚åº¦ï¼šä¸´æ—¶éœ€è¦2å€å†…å­˜
         *    - æ‘Šè¿˜åˆ†æï¼šå¹³å‡O(1)
         * 
         * 5. ä¼˜åŒ–å»ºè®®ï¼š
         *    - é¢„ä¼°åˆå§‹å®¹é‡ï¼šnew ArrayList<>(expectedSize)
         *    - æ‰‹åŠ¨æ‰©å®¹ï¼šensureCapacity(expectedSize)
         *    - æ‰¹é‡æ“ä½œï¼šä½¿ç”¨addAll()è€Œéå¤šæ¬¡add()
         */
    }
}
```

**é—®é¢˜3ï¼šArrayListçš„çº¿ç¨‹å®‰å…¨é—®é¢˜åŠè§£å†³æ–¹æ¡ˆ**

```java
/**
 * ArrayListçº¿ç¨‹å®‰å…¨é—®é¢˜åˆ†æ
 */
public class ArrayListThreadSafetyAnalysis {
    
    /**
     * çº¿ç¨‹å®‰å…¨é—®é¢˜æ¼”ç¤º
     */
    public void demonstrateThreadSafetyIssues() {
        ArrayList<Integer> list = new ArrayList<>();
        
        /*
         * é—®é¢˜1ï¼šæ•°æ®ç«äº‰
         * å¤šä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹ArrayListå¯èƒ½å¯¼è‡´ï¼š
         * - æ•°æ®ä¸¢å¤±
         * - æ•°ç»„è¶Šç•Œ
         * - æ­»å¾ªç¯ï¼ˆåœ¨æ‰©å®¹è¿‡ç¨‹ä¸­ï¼‰
         * 
         * é—®é¢˜2ï¼šfail-fastæœºåˆ¶
         * Iteratoråœ¨æ£€æµ‹åˆ°å¹¶å‘ä¿®æ”¹æ—¶æŠ›å‡ºConcurrentModificationException
         */
    }
    
    /**
     * çº¿ç¨‹å®‰å…¨è§£å†³æ–¹æ¡ˆ
     */
    public void threadSafetySolutions() {
        /*
         * è§£å†³æ–¹æ¡ˆå¯¹æ¯”ï¼š
         * 
         * 1. Collections.synchronizedList()
         *    - åŸç†ï¼šä¸ºæ¯ä¸ªæ–¹æ³•æ·»åŠ synchronized
         *    - ä¼˜ç‚¹ï¼šç®€å•æ˜“ç”¨
         *    - ç¼ºç‚¹ï¼šæ€§èƒ½è¾ƒå·®ï¼Œè¿­ä»£æ—¶ä»éœ€æ‰‹åŠ¨åŒæ­¥
         * 
         * 2. Vector
         *    - åŸç†ï¼šæ‰€æœ‰æ–¹æ³•éƒ½æ˜¯synchronized
         *    - ä¼˜ç‚¹ï¼šå®Œå…¨çº¿ç¨‹å®‰å…¨
         *    - ç¼ºç‚¹ï¼šæ€§èƒ½å¼€é”€å¤§ï¼Œå·²è¿‡æ—¶
         * 
         * 3. CopyOnWriteArrayList
         *    - åŸç†ï¼šå†™æ—¶å¤åˆ¶ï¼Œè¯»å†™åˆ†ç¦»
         *    - ä¼˜ç‚¹ï¼šè¯»æ“ä½œæ— é”ï¼Œæ€§èƒ½å¥½
         *    - ç¼ºç‚¹ï¼šå†™æ“ä½œå¼€é”€å¤§ï¼Œå†…å­˜å ç”¨é«˜
         * 
         * 4. æ‰‹åŠ¨åŒæ­¥
         *    - ä½¿ç”¨ReentrantReadWriteLockç­‰é”æœºåˆ¶
         *    - æ ¹æ®å…·ä½“åœºæ™¯é€‰æ‹©åˆé€‚çš„åŒæ­¥ç­–ç•¥
         */
        
        // ç¤ºä¾‹ï¼šä½¿ç”¨CopyOnWriteArrayList
        List<String> threadSafeList = new CopyOnWriteArrayList<>();
        threadSafeList.add("thread-safe");
    }
}
```

**é—®é¢˜4ï¼šArrayListçš„å†…å­˜æ³„æ¼é£é™©**

```java
/**
 * ArrayListå†…å­˜æ³„æ¼åˆ†æ
 */
public class ArrayListMemoryLeakAnalysis {
    
    /**
     * å†…å­˜æ³„æ¼åœºæ™¯åˆ†æ
     */
    public void analyzeMemoryLeakScenarios() {
        /*
         * åœºæ™¯1ï¼šå®¹é‡è¿œå¤§äºå®é™…ä½¿ç”¨
         * ArrayList<String> list = new ArrayList<>(10000);
         * list.add("single item"); // æµªè´¹å¤§é‡å†…å­˜
         * 
         * è§£å†³ï¼šä½¿ç”¨trimToSize()è°ƒæ•´å®¹é‡
         * 
         * åœºæ™¯2ï¼šsubListæŒæœ‰åŸåˆ—è¡¨å¼•ç”¨
         * List<String> subList = largeList.subList(0, 10);
         * // subListæŒæœ‰largeListå¼•ç”¨ï¼Œå¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼
         * 
         * è§£å†³ï¼šåˆ›å»ºæ–°çš„ArrayList
         * List<String> newList = new ArrayList<>(subList);
         * 
         * åœºæ™¯3ï¼šåˆ é™¤å…ƒç´ åä¸æ¸…ç†å¼•ç”¨
         * åœ¨è‡ªå®šä¹‰çš„ç±»ä¼¼ArrayListå®ç°ä¸­ï¼Œ
         * åˆ é™¤å…ƒç´ åæ²¡æœ‰å°†å¯¹åº”ä½ç½®è®¾ä¸ºnull
         * 
         * è§£å†³ï¼šåŠæ—¶æ¸…ç†å¯¹è±¡å¼•ç”¨
         */
    }
}
```

**é—®é¢˜5ï¼šArrayListä¸Arrayçš„æ€§èƒ½å¯¹æ¯”**

```java
/**
 * ArrayList vs Array æ€§èƒ½å¯¹æ¯”
 */
public class ArrayListVsArrayPerformance {
    
    /**
     * æ€§èƒ½å¯¹æ¯”åˆ†æ
     */
    public void performanceAnalysis() {
        /*
         * è®¿é—®æ€§èƒ½ï¼š
         * - Arrayï¼šç›´æ¥å†…å­˜è®¿é—®ï¼Œæœ€å¿«
         * - ArrayListï¼šéœ€è¦è¾¹ç•Œæ£€æŸ¥å’Œç±»å‹è½¬æ¢ï¼Œç•¥æ…¢
         * 
         * å†…å­˜å ç”¨ï¼š
         * - Arrayï¼šåªå­˜å‚¨å…ƒç´ æœ¬èº«
         * - ArrayListï¼šé¢å¤–çš„å¯¹è±¡å¤´ã€sizeå­—æ®µã€å¯èƒ½çš„ç©ºä½™å®¹é‡
         * 
         * æ“ä½œä¾¿åˆ©æ€§ï¼š
         * - Arrayï¼šå›ºå®šå¤§å°ï¼Œæ“ä½œå¤æ‚
         * - ArrayListï¼šåŠ¨æ€å¤§å°ï¼Œæ“ä½œç®€ä¾¿
         * 
         * ç±»å‹å®‰å…¨ï¼š
         * - Arrayï¼šç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
         * - ArrayListï¼šæ³›å‹æä¾›ç±»å‹å®‰å…¨
         * 
         * é€‰æ‹©å»ºè®®ï¼š
         * - æ€§èƒ½æ•æ„Ÿä¸”å¤§å°å›ºå®šï¼šä½¿ç”¨Array
         * - éœ€è¦åŠ¨æ€è°ƒæ•´å¤§å°ï¼šä½¿ç”¨ArrayList
         * - éœ€è¦ä¸°å¯Œçš„æ“ä½œæ–¹æ³•ï¼šä½¿ç”¨ArrayList
         */
    }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**1. å®¹é‡é¢„ä¼°ä¸åˆå§‹åŒ–ä¼˜åŒ–**

```java
/**
 * ArrayListå®¹é‡ä¼˜åŒ–ç­–ç•¥
 */
public class ArrayListCapacityOptimization {
    
    /**
     * æœ€ä½³å®è·µï¼šåˆç†è®¾ç½®åˆå§‹å®¹é‡
     */
    public void capacityOptimizationBestPractices() {
        // âŒ é”™è¯¯åšæ³•ï¼šä½¿ç”¨é»˜è®¤å®¹é‡
        List<String> badList = new ArrayList<>(); // é»˜è®¤å®¹é‡10ï¼Œå¯èƒ½é¢‘ç¹æ‰©å®¹
        
        // âœ… æ­£ç¡®åšæ³•ï¼šé¢„ä¼°å®¹é‡
        int expectedSize = calculateExpectedSize();
        List<String> goodList = new ArrayList<>(expectedSize);
        
        // âœ… æ›´å¥½çš„åšæ³•ï¼šç•™æœ‰ä½™é‡
        List<String> betterList = new ArrayList<>((int) (expectedSize * 1.2));
        
        // âœ… æ‰¹é‡æ“ä½œä¼˜åŒ–
        List<String> sourceData = getSourceData();
        List<String> targetList = new ArrayList<>(sourceData.size());
        targetList.addAll(sourceData); // æ¯”é€ä¸ªadd()æ•ˆç‡é«˜
    }
    
    /**
     * åŠ¨æ€å®¹é‡è°ƒæ•´
     */
    public void dynamicCapacityAdjustment(List<String> list) {
        // é¢„åˆ†é…å®¹é‡é¿å…æ‰©å®¹
        if (list instanceof ArrayList) {
            ((ArrayList<String>) list).ensureCapacity(expectedAdditionalSize);
        }
        
        // é‡Šæ”¾å¤šä½™å®¹é‡
        if (list.size() < list.size() * 0.5) {
            ((ArrayList<String>) list).trimToSize();
        }
    }
}
```

**2. éå†æ€§èƒ½ä¼˜åŒ–**

```java
/**
 * ArrayListéå†æ€§èƒ½ä¼˜åŒ–
 */
public class ArrayListIterationOptimization {
    
    /**
     * ä¸åŒéå†æ–¹å¼çš„æ€§èƒ½å¯¹æ¯”
     */
    public void iterationPerformanceComparison(List<String> list) {
        // æ–¹å¼1ï¼šä¼ ç»Ÿforå¾ªç¯ - æœ€å¿«
        for (int i = 0; i < list.size(); i++) {
            String item = list.get(i);
            processItem(item);
        }
        
        // æ–¹å¼2ï¼šå¢å¼ºforå¾ªç¯ - æ¨è
        for (String item : list) {
            processItem(item);
        }
        
        // æ–¹å¼3ï¼šIterator - å®‰å…¨ä½†ç¨æ…¢
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            processItem(iterator.next());
        }
        
        // æ–¹å¼4ï¼šStream API - åŠŸèƒ½å¼ºå¤§ä½†æœ‰å¼€é”€
        list.stream()
            .filter(Objects::nonNull)
            .forEach(this::processItem);
        
        // æ–¹å¼5ï¼šå¹¶è¡ŒStream - é€‚åˆCPUå¯†é›†å‹ä»»åŠ¡
        list.parallelStream()
            .filter(Objects::nonNull)
            .forEach(this::processItem);
    }
    
    private void processItem(String item) {
        // å¤„ç†é€»è¾‘
    }
}
```

### å…³é”®æ³¨æ„äº‹é¡¹

**1. é¿å…å¸¸è§æ€§èƒ½é™·é˜±**

```java
/**
 * ArrayListæ€§èƒ½é™·é˜±åŠé¿å…æ–¹æ³•
 */
public class ArrayListPerformancePitfalls {
    
    /**
     * é™·é˜±1ï¼šé¢‘ç¹çš„ä¸­é—´æ’å…¥/åˆ é™¤
     */
    public void avoidFrequentMiddleOperations() {
        List<String> list = new ArrayList<>();
        
        // âŒ æ€§èƒ½é™·é˜±ï¼šé¢‘ç¹ä¸­é—´æ’å…¥
        for (int i = 0; i < 1000; i++) {
            list.add(0, "item" + i); // æ¯æ¬¡éƒ½è¦ç§»åŠ¨æ‰€æœ‰å…ƒç´ 
        }
        
        // âœ… ä¼˜åŒ–æ–¹æ¡ˆï¼šä½¿ç”¨LinkedListæˆ–æ‰¹é‡æ“ä½œ
        LinkedList<String> linkedList = new LinkedList<>();
        for (int i = 0; i < 1000; i++) {
            linkedList.addFirst("item" + i); // O(1)æ“ä½œ
        }
    }
    
    /**
     * é™·é˜±2ï¼šåœ¨å¾ªç¯ä¸­è°ƒç”¨size()æ–¹æ³•
     */
    public void avoidRepeatedSizeCall(List<String> list) {
        // âŒ æ€§èƒ½é™·é˜±ï¼šé‡å¤è°ƒç”¨size()
        for (int i = 0; i < list.size(); i++) { // æ¯æ¬¡éƒ½è°ƒç”¨size()
            processItem(list.get(i));
        }
        
        // âœ… ä¼˜åŒ–æ–¹æ¡ˆï¼šç¼“å­˜sizeå€¼
        int size = list.size();
        for (int i = 0; i < size; i++) {
            processItem(list.get(i));
        }
    }
    
    /**
     * é™·é˜±3ï¼šä¸å¿…è¦çš„è‡ªåŠ¨è£…ç®±/æ‹†ç®±
     */
    public void avoidUnnecessaryBoxing() {
        // âŒ æ€§èƒ½é™·é˜±ï¼šé¢‘ç¹è£…ç®±æ‹†ç®±
        List<Integer> numbers = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            numbers.add(i); // int -> Integerè£…ç®±
        }
        
        int sum = 0;
        for (Integer num : numbers) {
            sum += num; // Integer -> intæ‹†ç®±
        }
        
        // âœ… ä¼˜åŒ–æ–¹æ¡ˆï¼šä½¿ç”¨åŸºæœ¬ç±»å‹æ•°ç»„æˆ–ä¸“é—¨çš„é›†åˆ
        int[] primitiveArray = new int[10000];
        for (int i = 0; i < 10000; i++) {
            primitiveArray[i] = i; // æ— è£…ç®±å¼€é”€
        }
    }
}
```

## ğŸ“š æ€»ç»“ä¸æŠ€æœ¯å¯¹æ¯”

### æ ¸å¿ƒè¦ç‚¹æ€»ç»“

**ArrayListçš„è®¾è®¡ç²¾é«“**ï¼š

1. **åŠ¨æ€æ•°ç»„å®ç°**ï¼šåŸºäºObject[]æ•°ç»„ï¼Œæä¾›åŠ¨æ€æ‰©å®¹èƒ½åŠ›
2. **1.5å€æ‰©å®¹ç­–ç•¥**ï¼šå¹³è¡¡å†…å­˜ä½¿ç”¨å’Œæ‰©å®¹é¢‘ç‡çš„æœ€ä¼˜è§£
3. **fail-fastæœºåˆ¶**ï¼šé€šè¿‡modCountæ£€æµ‹å¹¶å‘ä¿®æ”¹ï¼Œä¿è¯è¿­ä»£å®‰å…¨
4. **éšæœºè®¿é—®ä¼˜åŠ¿**ï¼šO(1)æ—¶é—´å¤æ‚åº¦çš„ç´¢å¼•è®¿é—®
5. **å†…å­˜è¿ç»­æ€§**ï¼šè‰¯å¥½çš„ç¼“å­˜å±€éƒ¨æ€§ï¼Œæå‡è®¿é—®æ€§èƒ½

### ä¸å…¶ä»–é›†åˆç±»å‹å¯¹æ¯”

| ç‰¹æ€§ | ArrayList | LinkedList | Vector | CopyOnWriteArrayList |
|------|-----------|------------|--------|----------------------|
| åº•å±‚ç»“æ„ | åŠ¨æ€æ•°ç»„ | åŒå‘é“¾è¡¨ | åŠ¨æ€æ•°ç»„ | åŠ¨æ€æ•°ç»„ |
| éšæœºè®¿é—® | O(1) | O(n) | O(1) | O(1) |
| æ’å…¥/åˆ é™¤(ä¸­é—´) | O(n) | O(1) | O(n) | O(n) |
| æ’å…¥/åˆ é™¤(æœ«å°¾) | O(1) | O(1) | O(1) | O(n) |
| çº¿ç¨‹å®‰å…¨ | âŒ | âŒ | âœ… | âœ… |
| å†…å­˜å ç”¨ | ä½ | é«˜ | ä½ | é«˜ |
| é€‚ç”¨åœºæ™¯ | é€šç”¨åœºæ™¯ | é¢‘ç¹æ’å…¥åˆ é™¤ | çº¿ç¨‹å®‰å…¨éœ€æ±‚ | è¯»å¤šå†™å°‘ |

### æœ€ä½³å®è·µå»ºè®®

**é€‰æ‹©ArrayListçš„åœºæ™¯**ï¼š
- éœ€è¦é¢‘ç¹çš„éšæœºè®¿é—®æ“ä½œ
- ä¸»è¦åœ¨æœ«å°¾è¿›è¡Œæ’å…¥/åˆ é™¤æ“ä½œ
- å¯¹å†…å­˜ä½¿ç”¨æ•ˆç‡æœ‰è¦æ±‚
- ä¸éœ€è¦çº¿ç¨‹å®‰å…¨ä¿è¯

**æ€§èƒ½ä¼˜åŒ–è¦ç‚¹**ï¼š
- åˆç†é¢„ä¼°åˆå§‹å®¹é‡ï¼Œé¿å…é¢‘ç¹æ‰©å®¹
- ä½¿ç”¨æ‰¹é‡æ“ä½œæ›¿ä»£å¤šæ¬¡å•ä¸ªæ“ä½œ
- é¿å…åœ¨å¾ªç¯ä¸­è¿›è¡Œä¸­é—´æ’å…¥/åˆ é™¤
- åŠæ—¶è°ƒç”¨trimToSize()é‡Šæ”¾å¤šä½™ç©ºé—´
- é€‰æ‹©åˆé€‚çš„éå†æ–¹å¼

**å†…å­˜ç®¡ç†å»ºè®®**ï¼š
- æ³¨æ„å®¹é‡ä¸å®é™…å¤§å°çš„å·®å¼‚
- é¿å…é•¿æœŸæŒæœ‰å¤§å®¹é‡ä½†å°‘å…ƒç´ çš„ArrayList
- è°¨æ…ä½¿ç”¨subList()ï¼Œé¿å…å†…å­˜æ³„æ¼
- åœ¨åˆé€‚çš„æ—¶æœºè°ƒç”¨clear()å’ŒtrimToSize()

ArrayListä½œä¸ºJavaé›†åˆæ¡†æ¶çš„æ ¸å¿ƒç»„ä»¶ï¼Œå…¶ç®€æ´è€Œé«˜æ•ˆçš„è®¾è®¡ä¸ºJavaå¼€å‘æä¾›äº†å¼ºå¤§çš„åŠ¨æ€æ•°ç»„æ”¯æŒã€‚æ·±å…¥ç†è§£å…¶å®ç°åŸç†å’Œæ€§èƒ½ç‰¹æ€§ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬åœ¨å®é™…é¡¹ç›®ä¸­åšå‡ºæ›´å¥½çš„æŠ€æœ¯é€‰æ‹©å’Œæ€§èƒ½ä¼˜åŒ–å†³ç­–ã€‚