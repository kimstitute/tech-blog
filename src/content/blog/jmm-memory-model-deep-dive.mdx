---
title: "Javaå†…å­˜æ¨¡å‹(JMM)åº•å±‚åŸç†ä¸å†…å­˜äº¤äº’æ“ä½œè¯¦è§£"
description: "æ·±å…¥å‰–æJavaå†…å­˜æ¨¡å‹çš„åº•å±‚æŠ½è±¡æœºåˆ¶ï¼Œè¯¦è§£8ç§å†…å­˜äº¤äº’æ“ä½œçš„å·¥ä½œåŸç†å’Œæ‰§è¡Œè§„åˆ™ã€‚ç»“åˆå¤šçº¿ç¨‹åœºæ™¯åˆ†æä¸»å†…å­˜ä¸å·¥ä½œå†…å­˜çš„æ•°æ®æµè½¬è¿‡ç¨‹ï¼Œä¸ºç†è§£volatileã€synchronizedç­‰å¹¶å‘æœºåˆ¶å¥ å®šç†è®ºåŸºç¡€ã€‚"
pubDate: 2024-12-06
updatedDate: 2024-12-06
tags: ["java", "jmm", "memory-model", "concurrency", "thread-safety", "performance", "interview"]
categories: ["java-core"]
subject: "å¹¶å‘ç¼–ç¨‹"
draft: false
featured: true
author: "Gerrad Zhang"
location: "æ­¦æ±‰ï¼Œä¸­å›½"
---

## ğŸ¤” é—®é¢˜èƒŒæ™¯ä¸æŠ€æœ¯æ¼”è¿›

### æˆ‘ä»¬è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

åœ¨ç°ä»£å¤šæ ¸CPUæ¶æ„ä¸‹ï¼Œæ¯ä¸ªCPUæ ¸å¿ƒéƒ½æœ‰è‡ªå·±çš„ç¼“å­˜å±‚æ¬¡ç»“æ„ï¼Œè¿™å¸¦æ¥äº†å¤æ‚çš„**å†…å­˜ä¸€è‡´æ€§é—®é¢˜**ï¼š

- **ç¼“å­˜å±‚æ¬¡å¤æ‚**ï¼šL1ã€L2ã€L3ç¼“å­˜ä»¥åŠä¸»å†…å­˜å½¢æˆå¤šå±‚å­˜å‚¨ä½“ç³»
- **æ•°æ®ä¸ä¸€è‡´**ï¼šåŒä¸€å˜é‡åœ¨ä¸åŒCPUç¼“å­˜ä¸­å¯èƒ½æœ‰ä¸åŒçš„å€¼
- **æ“ä½œåŸå­æ€§**ï¼šçœ‹ä¼¼ç®€å•çš„æ“ä½œåœ¨ç¡¬ä»¶å±‚é¢å¯èƒ½è¢«æ‹†åˆ†æˆå¤šä¸ªæ­¥éª¤
- **æŒ‡ä»¤é‡æ’åº**ï¼šç¼–è¯‘å™¨å’ŒCPUä¸ºäº†æ€§èƒ½ä¼˜åŒ–ä¼šé‡æ–°æ’åˆ—æŒ‡ä»¤æ‰§è¡Œé¡ºåº

```java
// å¤šæ ¸CPUç¯å¢ƒä¸‹çš„å…¸å‹é—®é¢˜
public class MemoryConsistencyProblem {
    private int sharedCounter = 0;
    
    // CPUæ ¸å¿ƒ1æ‰§è¡Œ
    public void incrementOnCore1() {
        sharedCounter++;  // çœ‹ä¼¼åŸå­ï¼Œå®é™…åŒ…å«ï¼šè¯»å–â†’è®¡ç®—â†’å†™å›
    }
    
    // CPUæ ¸å¿ƒ2åŒæ—¶æ‰§è¡Œ
    public void incrementOnCore2() {
        sharedCounter++;  // å¯èƒ½è¯»å–åˆ°è¿‡æœŸå€¼ï¼Œå¯¼è‡´æ•°æ®ä¸¢å¤±
    }
    
    // æœŸæœ›ç»“æœï¼š2ï¼Œå®é™…å¯èƒ½ï¼š1
}
```

### æ²¡æœ‰è¿™ä¸ªæŠ€æœ¯æ—¶æ˜¯æ€ä¹ˆåšçš„ï¼Ÿ

åœ¨JMMè§„èŒƒåŒ–ä¹‹å‰ï¼ŒJavaçš„å†…å­˜æ¨¡å‹å­˜åœ¨è¯¸å¤šé—®é¢˜ï¼š

**1. å¹³å°ç›¸å…³çš„å†…å­˜è¯­ä¹‰**
```java
// ä¸åŒå¹³å°ä¸Šè¡Œä¸ºä¸ä¸€è‡´
public class PlatformDependentBehavior {
    private boolean flag = false;
    private int data = 0;
    
    public void writer() {
        data = 42;
        flag = true;  // åœ¨æŸäº›å¹³å°ä¸Šå¯èƒ½é‡æ’åº
    }
    
    public void reader() {
        if (flag) {
            // dataçš„å€¼åœ¨ä¸åŒå¹³å°ä¸Šå¯èƒ½ä¸åŒ
            System.out.println(data);
        }
    }
}
```

**2. åŒæ­¥æœºåˆ¶è¿‡åº¦ä½¿ç”¨**
```java
// ä¸ºäº†ä¿è¯æ­£ç¡®æ€§ï¼Œè¿‡åº¦ä½¿ç”¨synchronized
public class OverSynchronized {
    private int value = 0;
    
    // å³ä½¿æ˜¯ç®€å•è¯»å–ä¹Ÿè¦åŒæ­¥
    public synchronized int getValue() {
        return value;
    }
    
    // ç®€å•å†™å…¥ä¹Ÿè¦åŒæ­¥
    public synchronized void setValue(int newValue) {
        this.value = newValue;
    }
}
```

**3. æ‰‹å·¥å†…å­˜å±éšœç®¡ç†**
```java
// ç›´æ¥ä½¿ç”¨CPUæŒ‡ä»¤ï¼Œå¤æ‚ä¸”æ˜“é”™
public class ManualMemoryBarrier {
    private int data = 0;
    
    public void unsafeWrite() {
        data = 42;
        // éœ€è¦æ‰‹å·¥æ’å…¥å†…å­˜å±éšœæŒ‡ä»¤
        // asm volatile("mfence" ::: "memory");  // x86æ±‡ç¼–
    }
}
```

### æŠ€æœ¯æ¼”è¿›çš„å†å²è„‰ç»œ

**JDK 1.0-1.4 (1996-2002)**ï¼šå†…å­˜æ¨¡å‹æ··ä¹±æœŸ
- ç¼ºä¹ç»Ÿä¸€çš„å†…å­˜æ¨¡å‹è§„èŒƒ
- ä¸åŒJVMå®ç°è¡Œä¸ºå·®å¼‚å·¨å¤§
- å¹¶å‘ç¨‹åºçš„æ­£ç¡®æ€§æ— æ³•ä¿è¯

**JDK 1.5 (2004)**ï¼šJSR-133é‡æ–°å®šä¹‰JMM
- å¼•å…¥ç»Ÿä¸€çš„Javaå†…å­˜æ¨¡å‹
- å®šä¹‰happens-beforeå…³ç³»
- è§„èŒƒåŒ–volatileå’Œsynchronizedè¯­ä¹‰

**JDK 1.6åŠä»¥å**ï¼šæŒç»­ä¼˜åŒ–å’Œå®Œå–„
- æ”¹è¿›JMMçš„æ€§èƒ½å®ç°
- å¢å¼ºå¹¶å‘å·¥å…·ç±»åº“
- æä¾›æ›´ç²¾ç»†çš„å†…å­˜æ§åˆ¶æœºåˆ¶

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µä¸åŸç†

### Javaå†…å­˜æ¨¡å‹çš„è®¾è®¡ç›®æ ‡

JMMçš„è®¾è®¡éœ€è¦å¹³è¡¡ä¸‰ä¸ªå…³é”®ç›®æ ‡ï¼š

**1. æ­£ç¡®æ€§**ï¼šä¿è¯å¤šçº¿ç¨‹ç¨‹åºçš„æ­£ç¡®æ‰§è¡Œ
**2. æ€§èƒ½**ï¼šå…è®¸ç¼–è¯‘å™¨å’ŒCPUè¿›è¡Œå¿…è¦çš„ä¼˜åŒ–
**3. æ˜“ç”¨æ€§**ï¼šä¸ºå¼€å‘è€…æä¾›ç®€æ´çš„ç¼–ç¨‹æ¨¡å‹

```java
/**
 * JMMè®¾è®¡ç›®æ ‡çš„ä½“ç°
 */
public class JMMDesignGoals {
    private int a = 0;
    private volatile boolean ready = false;
    
    // æ­£ç¡®æ€§ï¼šé€šè¿‡happens-beforeä¿è¯
    public void producer() {
        a = 42;          // 1. æ™®é€šå†™æ“ä½œ
        ready = true;    // 2. volatileå†™æ“ä½œ
        // happens-beforeä¿è¯ï¼š1 happens-before 2
    }
    
    // æ€§èƒ½ï¼šå…è®¸ç¼–è¯‘å™¨ä¼˜åŒ–éå…³é”®è·¯å¾„
    public void consumer() {
        if (ready) {     // 3. volatileè¯»æ“ä½œ
            // æ˜“ç”¨æ€§ï¼šå¼€å‘è€…åªéœ€å…³æ³¨volatileè¯­ä¹‰
            System.out.println(a);  // 4. ä¿è¯çœ‹åˆ°a=42
        }
    }
}
```

### å†…å­˜æ¨¡å‹çš„æŠ½è±¡æ¶æ„

JMMå®šä¹‰äº†ä¸€ä¸ªæŠ½è±¡çš„å†…å­˜æ¶æ„ï¼Œç‹¬ç«‹äºå…·ä½“çš„ç¡¬ä»¶å®ç°ï¼š

```java
/**
 * JMMæŠ½è±¡æ¶æ„ç¤ºæ„
 */
public class JMMArchitecture {
    // ä¸»å†…å­˜ï¼šæ‰€æœ‰çº¿ç¨‹å…±äº«çš„å†…å­˜åŒºåŸŸ
    // å­˜å‚¨æ‰€æœ‰å˜é‡çš„ä¸»å‰¯æœ¬
    
    // å·¥ä½œå†…å­˜ï¼šæ¯ä¸ªçº¿ç¨‹ç§æœ‰çš„å†…å­˜åŒºåŸŸ
    // å­˜å‚¨è¯¥çº¿ç¨‹ä½¿ç”¨çš„å˜é‡çš„å‰¯æœ¬
    
    private int sharedVariable = 0;  // ä¸»å†…å­˜ä¸­çš„å˜é‡
    
    public void threadOperation() {
        // çº¿ç¨‹çš„å·¥ä½œå†…å­˜æ“ä½œæµç¨‹ï¼š
        
        // 1. ä»ä¸»å†…å­˜è¯»å–å˜é‡åˆ°å·¥ä½œå†…å­˜
        int localCopy = sharedVariable;  // read + load
        
        // 2. åœ¨å·¥ä½œå†…å­˜ä¸­è¿›è¡Œè®¡ç®—
        localCopy = localCopy + 1;       // use + assign
        
        // 3. å°†ç»“æœå†™å›ä¸»å†…å­˜
        sharedVariable = localCopy;      // store + write
    }
}
```

## ğŸ”§ 8ç§å†…å­˜äº¤äº’æ“ä½œè¯¦è§£

### æ“ä½œåˆ†ç±»ä¸å®šä¹‰

JMMå®šä¹‰äº†8ç§åŸå­æ€§çš„å†…å­˜äº¤äº’æ“ä½œï¼Œç”¨äºæè¿°å˜é‡åœ¨ä¸»å†…å­˜å’Œå·¥ä½œå†…å­˜ä¹‹é—´çš„ä¼ è¾“ï¼š

#### ä¸»å†…å­˜æ“ä½œ
- **read**ï¼šä»ä¸»å†…å­˜è¯»å–å˜é‡å€¼
- **write**ï¼šå‘ä¸»å†…å­˜å†™å…¥å˜é‡å€¼
- **lock**ï¼šé”å®šä¸»å†…å­˜å˜é‡ï¼ˆç‹¬å è®¿é—®ï¼‰
- **unlock**ï¼šè§£é”ä¸»å†…å­˜å˜é‡

#### å·¥ä½œå†…å­˜æ“ä½œ  
- **load**ï¼šå°†readçš„å€¼è½½å…¥å·¥ä½œå†…å­˜å˜é‡
- **store**ï¼šå°†å·¥ä½œå†…å­˜å˜é‡å€¼ä¼ é€ç»™ä¸»å†…å­˜
- **use**ï¼šå°†å·¥ä½œå†…å­˜å˜é‡å€¼ä¼ é€’ç»™æ‰§è¡Œå¼•æ“
- **assign**ï¼šå°†æ‰§è¡Œå¼•æ“çš„å€¼èµ‹ç»™å·¥ä½œå†…å­˜å˜é‡

### è¯¦ç»†æ“ä½œæµç¨‹

```java
/**
 * å†…å­˜äº¤äº’æ“ä½œçš„å®Œæ•´æµç¨‹æ¼”ç¤º
 */
public class MemoryOperationFlow {
    private volatile int volatileVar = 0;
    private int normalVar = 0;
    
    /**
     * æ™®é€šå˜é‡çš„è¯»æ“ä½œæµç¨‹
     */
    public int readNormalVariable() {
        // æ“ä½œåºåˆ—ï¼šread â†’ load â†’ use
        return normalVar;
        /*
         * 1. read: ä»ä¸»å†…å­˜è¯»å–normalVarçš„å€¼
         * 2. load: å°†è¯»å–çš„å€¼è½½å…¥å·¥ä½œå†…å­˜çš„normalVarå‰¯æœ¬
         * 3. use: ä»å·¥ä½œå†…å­˜è¯»å–å€¼ä¾›æ‰§è¡Œå¼•æ“ä½¿ç”¨
         */
    }
    
    /**
     * æ™®é€šå˜é‡çš„å†™æ“ä½œæµç¨‹
     */
    public void writeNormalVariable(int value) {
        // æ“ä½œåºåˆ—ï¼šassign â†’ store â†’ write
        normalVar = value;
        /*
         * 1. assign: å°†valueèµ‹å€¼ç»™å·¥ä½œå†…å­˜çš„normalVarå‰¯æœ¬
         * 2. store: å°†å·¥ä½œå†…å­˜çš„å€¼ä¼ é€åˆ°ä¸»å†…å­˜ï¼ˆå¯èƒ½å»¶è¿Ÿï¼‰
         * 3. write: å°†ä¼ é€çš„å€¼å†™å…¥ä¸»å†…å­˜çš„normalVarï¼ˆå¯èƒ½å»¶è¿Ÿï¼‰
         */
    }
    
    /**
     * volatileå˜é‡çš„è¯»æ“ä½œæµç¨‹
     */
    public int readVolatileVariable() {
        // æ“ä½œåºåˆ—ï¼šread â†’ load â†’ useï¼ˆç«‹å³æ‰§è¡Œï¼‰
        return volatileVar;
        /*
         * volatileè¯»çš„ç‰¹æ®Šæ€§ï¼š
         * - readå’Œloadå¿…é¡»è¿ç»­æ‰§è¡Œ
         * - ç›´æ¥ä»ä¸»å†…å­˜è¯»å–æœ€æ–°å€¼
         * - ä¸å…è®¸é‡æ’åº
         */
    }
    
    /**
     * volatileå˜é‡çš„å†™æ“ä½œæµç¨‹
     */
    public void writeVolatileVariable(int value) {
        // æ“ä½œåºåˆ—ï¼šassign â†’ store â†’ writeï¼ˆç«‹å³æ‰§è¡Œï¼‰
        volatileVar = value;
        /*
         * volatileå†™çš„ç‰¹æ®Šæ€§ï¼š
         * - assignã€storeã€writeå¿…é¡»è¿ç»­æ‰§è¡Œ
         * - ç«‹å³åˆ·æ–°åˆ°ä¸»å†…å­˜
         * - ä¸å…è®¸é‡æ’åº
         */
    }
}
```

### æ“ä½œè§„åˆ™ä¸çº¦æŸ

JMMä¸ºè¿™8ç§æ“ä½œå®šä¹‰äº†ä¸¥æ ¼çš„æ‰§è¡Œè§„åˆ™ï¼š

```java
/**
 * å†…å­˜æ“ä½œè§„åˆ™æ¼”ç¤º
 */
public class MemoryOperationRules {
    private int data = 0;
    private volatile boolean flag = false;
    
    /**
     * è§„åˆ™1ï¼šreadå’Œloadå¿…é¡»æˆå¯¹å‡ºç°
     */
    public void rule1_ReadLoadPair() {
        // âœ… æ­£ç¡®ï¼šreadå’Œloadæˆå¯¹
        int temp = data;  // readä¸»å†…å­˜ â†’ loadå·¥ä½œå†…å­˜ â†’ use
        
        // âŒ é”™è¯¯ï¼šä¸èƒ½åªreadä¸loadï¼Œæˆ–åªloadä¸read
        // è¿™åœ¨JMMå±‚é¢æ˜¯ä¸å…è®¸çš„
    }
    
    /**
     * è§„åˆ™2ï¼šstoreå’Œwriteå¿…é¡»æˆå¯¹å‡ºç°
     */
    public void rule2_StoreWritePair() {
        // âœ… æ­£ç¡®ï¼šassignã€storeã€writeæŒ‰åºæ‰§è¡Œ
        data = 42;  // assignå·¥ä½œå†…å­˜ â†’ storeä¼ é€ â†’ writeä¸»å†…å­˜
        
        // âŒ é”™è¯¯ï¼šä¸èƒ½åªstoreä¸write
        // å·¥ä½œå†…å­˜çš„ä¿®æ”¹å¿…é¡»æœ€ç»ˆå†™å…¥ä¸»å†…å­˜
    }
    
    /**
     * è§„åˆ™3ï¼švolatileå˜é‡çš„ç‰¹æ®Šçº¦æŸ
     */
    public void rule3_VolatileConstraints() {
        // volatileå†™ï¼šç¦æ­¢ä¸å‰é¢çš„è¯»å†™é‡æ’åº
        data = 100;      // æ™®é€šå†™
        flag = true;     // volatileå†™ - ä¸èƒ½é‡æ’åºåˆ°dataå†™ä¹‹å‰
        
        // volatileè¯»ï¼šç¦æ­¢ä¸åé¢çš„è¯»å†™é‡æ’åº
        if (flag) {      // volatileè¯»
            System.out.println(data);  // æ™®é€šè¯» - ä¸èƒ½é‡æ’åºåˆ°flagè¯»ä¹‹å‰
        }
    }
    
    /**
     * è§„åˆ™4ï¼šlock/unlockçš„äº’æ–¥æ€§
     */
    public synchronized void rule4_LockUnlockMutex() {
        // lockæ“ä½œï¼šè·å¾—å˜é‡çš„ç‹¬å è®¿é—®æƒ
        // åœ¨synchronizedå—ä¸­ï¼Œå…¶ä»–çº¿ç¨‹æ— æ³•lockåŒä¸€å˜é‡
        data = data + 1;
        // unlockæ“ä½œï¼šé‡Šæ”¾å˜é‡çš„ç‹¬å è®¿é—®æƒ
    }
}
```

## ğŸ’¡ å®æˆ˜æ¡ˆä¾‹ä¸ä»£ç ç¤ºä¾‹

### æ¡ˆä¾‹1ï¼šç†è§£æ•°æ®ç«äº‰

```java
/**
 * æ•°æ®ç«äº‰çš„å†…å­˜æ“ä½œåˆ†æ
 */
public class DataRaceAnalysis {
    private int counter = 0;
    
    /**
     * çº¿ç¨‹1çš„æ“ä½œåºåˆ—
     */
    public void thread1Increment() {
        // counter++ çš„å†…å­˜æ“ä½œåˆ†è§£ï¼š
        
        // 1. è¯»å–æ“ä½œ
        // read: ä»ä¸»å†…å­˜è¯»å–counterå€¼(å‡è®¾ä¸º5)
        // load: å°†å€¼5è½½å…¥çº¿ç¨‹1çš„å·¥ä½œå†…å­˜
        // use: å°†å€¼5ä¼ é€’ç»™æ‰§è¡Œå¼•æ“
        
        // 2. è®¡ç®—æ“ä½œ
        // æ‰§è¡Œå¼•æ“è®¡ç®—: 5 + 1 = 6
        
        // 3. å†™å…¥æ“ä½œ  
        // assign: å°†å€¼6èµ‹ç»™çº¿ç¨‹1å·¥ä½œå†…å­˜çš„counter
        // store: å°†å€¼6ä¼ é€åˆ°ä¸»å†…å­˜ï¼ˆå¯èƒ½å»¶è¿Ÿï¼‰
        // write: å°†å€¼6å†™å…¥ä¸»å†…å­˜çš„counterï¼ˆå¯èƒ½å»¶è¿Ÿï¼‰
        counter++;
    }
    
    /**
     * çº¿ç¨‹2çš„å¹¶å‘æ“ä½œ
     */
    public void thread2Increment() {
        // å¦‚æœçº¿ç¨‹2åœ¨çº¿ç¨‹1çš„store/writeä¹‹å‰æ‰§è¡Œread/load
        // é‚£ä¹ˆçº¿ç¨‹2ä¹Ÿä¼šè¯»å–åˆ°æ—§å€¼5ï¼Œè®¡ç®—ç»“æœä¹Ÿæ˜¯6
        // æœ€ç»ˆä¸¤ä¸ªçº¿ç¨‹çš„å†™å…¥éƒ½æ˜¯6ï¼Œè€Œä¸æ˜¯æœŸæœ›çš„7
        counter++;
    }
    
    /**
     * ä½¿ç”¨volatileè§£å†³æ•°æ®ç«äº‰çš„å¯è§æ€§é—®é¢˜
     */
    private volatile int volatileCounter = 0;
    
    public void safeRead() {
        // volatileè¯»ä¿è¯ï¼š
        // - ç›´æ¥ä»ä¸»å†…å­˜è¯»å–æœ€æ–°å€¼
        // - read/loadæ“ä½œä¸å¯å»¶è¿Ÿ
        int value = volatileCounter;
    }
    
    public void safeWrite() {
        // volatileå†™ä¿è¯ï¼š
        // - assign/store/writeæ“ä½œä¸å¯å»¶è¿Ÿ
        // - ç«‹å³åˆ·æ–°åˆ°ä¸»å†…å­˜
        volatileCounter = 42;
    }
}
```

### æ¡ˆä¾‹2ï¼šåŒé‡æ£€æŸ¥é”å®šçš„å†…å­˜æ“ä½œ

```java
/**
 * åŒé‡æ£€æŸ¥é”å®šçš„å†…å­˜æ“ä½œåˆ†æ
 */
public class DoubleCheckedLocking {
    private volatile Singleton instance;
    
    public Singleton getInstance() {
        // ç¬¬ä¸€æ¬¡æ£€æŸ¥ï¼ˆvolatileè¯»ï¼‰
        if (instance == null) {  
            // å†…å­˜æ“ä½œï¼šread â†’ load â†’ use
            // volatileè¯»ç¡®ä¿çœ‹åˆ°æœ€æ–°çš„instanceå€¼
            
            synchronized (this) {
                // ç¬¬äºŒæ¬¡æ£€æŸ¥ï¼ˆvolatileè¯»ï¼‰
                if (instance == null) {
                    // å¯¹è±¡åˆ›å»ºçš„å†…å­˜æ“ä½œåˆ†è§£ï¼š
                    instance = new Singleton();
                    /*
                     * è¿™ä¸ªæ“ä½œåŒ…å«ä¸‰ä¸ªæ­¥éª¤ï¼š
                     * 1. åˆ†é…å†…å­˜ç©ºé—´
                     * 2. åˆå§‹åŒ–å¯¹è±¡  
                     * 3. å°†å¼•ç”¨æŒ‡å‘å†…å­˜ç©ºé—´
                     * 
                     * volatileç¡®ä¿è¿™ä¸‰ä¸ªæ­¥éª¤ä¸ä¼šé‡æ’åº
                     * é˜²æ­¢å…¶ä»–çº¿ç¨‹çœ‹åˆ°æœªåˆå§‹åŒ–çš„å¯¹è±¡
                     */
                }
            }
        }
        return instance;
    }
    
    /**
     * é”™è¯¯çš„å®ç°ï¼ˆä¸ä½¿ç”¨volatileï¼‰
     */
    private Singleton brokenInstance;
    
    public Singleton getBrokenInstance() {
        if (brokenInstance == null) {
            synchronized (this) {
                if (brokenInstance == null) {
                    // å±é™©ï¼šå¯èƒ½å‘ç”ŸæŒ‡ä»¤é‡æ’åº
                    brokenInstance = new Singleton();
                    /*
                     * å¯èƒ½çš„é‡æ’åºï¼š
                     * 1. åˆ†é…å†…å­˜ç©ºé—´
                     * 3. å°†å¼•ç”¨æŒ‡å‘å†…å­˜ç©ºé—´ï¼ˆæå‰æ‰§è¡Œï¼‰
                     * 2. åˆå§‹åŒ–å¯¹è±¡ï¼ˆå»¶åæ‰§è¡Œï¼‰
                     * 
                     * å…¶ä»–çº¿ç¨‹å¯èƒ½çœ‹åˆ°énullä½†æœªåˆå§‹åŒ–çš„å¯¹è±¡ï¼
                     */
                }
            }
        }
        return brokenInstance;
    }
    
    private static class Singleton {
        private final String data = "initialized";
        
        public String getData() {
            return data;
        }
    }
}
```

### æ¡ˆä¾‹3ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼çš„å†…å­˜è¯­ä¹‰

```java
/**
 * ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼çš„å†…å­˜æ“ä½œåˆ†æ
 */
public class ProducerConsumerMemorySemantics {
    private String data = null;
    private volatile boolean ready = false;
    
    /**
     * ç”Ÿäº§è€…çº¿ç¨‹
     */
    public void producer() {
        // æ­¥éª¤1ï¼šå‡†å¤‡æ•°æ®ï¼ˆæ™®é€šå†™ï¼‰
        data = "Hello World";
        /*
         * å†…å­˜æ“ä½œï¼š
         * assign: å°†"Hello World"èµ‹ç»™å·¥ä½œå†…å­˜çš„data
         * store: ä¼ é€åˆ°ä¸»å†…å­˜ï¼ˆå¯èƒ½å»¶è¿Ÿï¼‰
         * write: å†™å…¥ä¸»å†…å­˜ï¼ˆå¯èƒ½å»¶è¿Ÿï¼‰
         */
        
        // æ­¥éª¤2ï¼šè®¾ç½®æ ‡å¿—ï¼ˆvolatileå†™ï¼‰
        ready = true;
        /*
         * volatileå†™çš„å†…å­˜æ“ä½œï¼š
         * assign: å°†trueèµ‹ç»™å·¥ä½œå†…å­˜çš„ready
         * store: ç«‹å³ä¼ é€åˆ°ä¸»å†…å­˜
         * write: ç«‹å³å†™å…¥ä¸»å†…å­˜
         * 
         * å…³é”®ï¼švolatileå†™ä¼šå¼ºåˆ¶å‰é¢çš„æ™®é€šå†™ä¹Ÿåˆ·æ–°åˆ°ä¸»å†…å­˜
         * è¿™ç¡®ä¿äº†dataçš„å†™å…¥åœ¨readyå†™å…¥ä¹‹å‰å®Œæˆ
         */
    }
    
    /**
     * æ¶ˆè´¹è€…çº¿ç¨‹
     */
    public void consumer() {
        // æ­¥éª¤1ï¼šæ£€æŸ¥æ ‡å¿—ï¼ˆvolatileè¯»ï¼‰
        if (ready) {
        /*
         * volatileè¯»çš„å†…å­˜æ“ä½œï¼š
         * read: ä»ä¸»å†…å­˜è¯»å–readyçš„æœ€æ–°å€¼
         * load: è½½å…¥å·¥ä½œå†…å­˜
         * use: ä¼ é€’ç»™æ‰§è¡Œå¼•æ“
         * 
         * å…³é”®ï¼švolatileè¯»ä¼šå¼ºåˆ¶åé¢çš„æ™®é€šè¯»ä¹Ÿä»ä¸»å†…å­˜è¯»å–
         */
            
            // æ­¥éª¤2ï¼šè¯»å–æ•°æ®ï¼ˆæ™®é€šè¯»ï¼‰
            String result = data;
            /*
             * ç”±äºhappens-beforeå…³ç³»ï¼š
             * producerçš„dataå†™ happens-before readyå†™
             * readyå†™ happens-before readyè¯»
             * readyè¯» happens-before dataè¯»
             * 
             * å› æ­¤ä¿è¯çœ‹åˆ°data = "Hello World"
             */
            System.out.println(result);
        }
    }
}
```

## ğŸ¯ é¢è¯•é«˜é¢‘é—®é¢˜ç²¾è®²

### æ ¸å¿ƒé¢è¯•é—®é¢˜

**Q1ï¼šä»€ä¹ˆæ˜¯Javaå†…å­˜æ¨¡å‹ï¼Ÿå®ƒè§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿ**

**A1ï¼šè¯¦ç»†è§£ç­”**
```java
/**
 * JMMè§£å†³çš„æ ¸å¿ƒé—®é¢˜æ¼”ç¤º
 */
public class JMMProblemSolution {
    // é—®é¢˜ï¼šæ²¡æœ‰JMMæ—¶çš„ä¸ç¡®å®šè¡Œä¸º
    private int value = 0;
    private boolean flag = false;
    
    // çº¿ç¨‹1
    public void problematicWriter() {
        value = 42;      // å¯èƒ½è¢«é‡æ’åº
        flag = true;     // åˆ°flagå†™ä¹‹å
    }
    
    // çº¿ç¨‹2  
    public void problematicReader() {
        if (flag) {      // å¯èƒ½çœ‹åˆ°flag=true
            // ä½†valueå¯èƒ½è¿˜æ˜¯0ï¼
            assert value == 42; // å¯èƒ½å¤±è´¥
        }
    }
    
    // è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨JMMè§„èŒƒçš„volatile
    private volatile boolean volatileFlag = false;
    
    public void correctWriter() {
        value = 42;           // æ™®é€šå†™
        volatileFlag = true;  // volatileå†™ï¼Œç¦æ­¢é‡æ’åº
    }
    
    public void correctReader() {
        if (volatileFlag) {   // volatileè¯»
            // ç”±äºhappens-beforeï¼Œä¿è¯çœ‹åˆ°value=42
            assert value == 42; // æ€»æ˜¯æˆåŠŸ
        }
    }
}
```

**Q2ï¼šè¯¦ç»†è¯´æ˜8ç§å†…å­˜äº¤äº’æ“ä½œåŠå…¶çº¦æŸè§„åˆ™**

**A2ï¼šæ“ä½œåˆ†ç±»ä¸è§„åˆ™**
```java
/**
 * 8ç§å†…å­˜æ“ä½œçš„åˆ†ç±»å’Œè§„åˆ™
 */
public class MemoryOperationRules {
    
    /**
     * ä¸»å†…å­˜æ“ä½œï¼ˆ4ç§ï¼‰
     */
    public void mainMemoryOperations() {
        /*
         * 1. read: ä»ä¸»å†…å­˜è¯»å–å˜é‡å€¼åˆ°å†…å­˜æ€»çº¿
         * 2. write: å°†å†…å­˜æ€»çº¿çš„å€¼å†™å…¥ä¸»å†…å­˜å˜é‡
         * 3. lock: é”å®šä¸»å†…å­˜å˜é‡ï¼Œç‹¬å è®¿é—®
         * 4. unlock: è§£é”ä¸»å†…å­˜å˜é‡ï¼Œé‡Šæ”¾ç‹¬å 
         */
    }
    
    /**
     * å·¥ä½œå†…å­˜æ“ä½œï¼ˆ4ç§ï¼‰
     */
    public void workingMemoryOperations() {
        /*
         * 1. load: å°†å†…å­˜æ€»çº¿çš„å€¼è½½å…¥å·¥ä½œå†…å­˜å˜é‡
         * 2. store: å°†å·¥ä½œå†…å­˜å˜é‡å€¼ä¼ é€åˆ°å†…å­˜æ€»çº¿
         * 3. use: å°†å·¥ä½œå†…å­˜å˜é‡å€¼ä¼ é€’ç»™æ‰§è¡Œå¼•æ“
         * 4. assign: å°†æ‰§è¡Œå¼•æ“çš„å€¼èµ‹ç»™å·¥ä½œå†…å­˜å˜é‡
         */
    }
    
    /**
     * å…³é”®çº¦æŸè§„åˆ™
     */
    public void constraintRules() {
        /*
         * è§„åˆ™1ï¼šread-loadé…å¯¹
         * - readæ“ä½œåå¿…é¡»è·Ÿéšloadæ“ä½œ
         * - loadæ“ä½œå‰å¿…é¡»æœ‰readæ“ä½œ
         * 
         * è§„åˆ™2ï¼šstore-writeé…å¯¹  
         * - storeæ“ä½œåå¿…é¡»è·Ÿéšwriteæ“ä½œ
         * - writeæ“ä½œå‰å¿…é¡»æœ‰storeæ“ä½œ
         * 
         * è§„åˆ™3ï¼švolatileå˜é‡çº¦æŸ
         * - volatileè¯»ï¼šread-loadè¿ç»­æ‰§è¡Œï¼Œä¸å¯å»¶è¿Ÿ
         * - volatileå†™ï¼šstore-writeè¿ç»­æ‰§è¡Œï¼Œä¸å¯å»¶è¿Ÿ
         * 
         * è§„åˆ™4ï¼šlock-unlockäº’æ–¥
         * - åŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹lockæŸä¸ªå˜é‡
         * - lockå’Œunlockå¿…é¡»æˆå¯¹å‡ºç°
         */
    }
}
```

**Q3ï¼šJMMå¦‚ä½•ä¿è¯happens-beforeå…³ç³»ï¼Ÿ**

**A3ï¼šhappens-beforeå®ç°æœºåˆ¶**
```java
/**
 * happens-beforeå…³ç³»çš„å†…å­˜æ“ä½œå®ç°
 */
public class HappensBeforeImplementation {
    private int data = 0;
    private volatile boolean ready = false;
    
    /**
     * ç¨‹åºæ¬¡åºè§„åˆ™çš„å®ç°
     */
    public void programOrderRule() {
        int a = 1;    // æ“ä½œ1
        int b = 2;    // æ“ä½œ2  
        int c = 3;    // æ“ä½œ3
        
        /*
         * JMMä¿è¯ï¼šåœ¨å•çº¿ç¨‹å†…ï¼Œæ“ä½œ1 happens-before æ“ä½œ2 happens-before æ“ä½œ3
         * å®ç°ï¼šç¼–è¯‘å™¨ä¸ä¼šå°†åé¢çš„æ“ä½œé‡æ’åºåˆ°å‰é¢
         */
    }
    
    /**
     * volatileè§„åˆ™çš„å®ç°
     */
    public void volatileRule() {
        // å†™çº¿ç¨‹
        data = 42;        // æ™®é€šå†™æ“ä½œ
        ready = true;     // volatileå†™æ“ä½œ
        
        /*
         * JMMä¿è¯ï¼šdataå†™ happens-before readyå†™
         * å®ç°ï¼švolatileå†™ä¼šæ’å…¥StoreStoreå±éšœï¼Œ
         *      ç¡®ä¿å‰é¢çš„å†™æ“ä½œä¸ä¼šé‡æ’åºåˆ°volatileå†™ä¹‹å
         */
    }
    
    public void volatileRuleReader() {
        // è¯»çº¿ç¨‹
        if (ready) {      // volatileè¯»æ“ä½œ
            System.out.println(data); // æ™®é€šè¯»æ“ä½œ
        }
        
        /*
         * JMMä¿è¯ï¼šreadyè¯» happens-before dataè¯»
         * å®ç°ï¼švolatileè¯»ä¼šæ’å…¥LoadLoadå±éšœï¼Œ
         *      ç¡®ä¿åé¢çš„è¯»æ“ä½œä¸ä¼šé‡æ’åºåˆ°volatileè¯»ä¹‹å‰
         */
    }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ä¸æ³¨æ„äº‹é¡¹

### æ€§èƒ½è€ƒè™‘å› ç´ 

**1. å†…å­˜æ“ä½œçš„æˆæœ¬**
```java
/**
 * ä¸åŒå†…å­˜æ“ä½œçš„æ€§èƒ½å¯¹æ¯”
 */
public class MemoryOperationPerformance {
    private int normalVar = 0;
    private volatile int volatileVar = 0;
    private final Object lock = new Object();
    
    /**
     * æ€§èƒ½æµ‹è¯•ï¼šæ™®é€šå˜é‡è¯»å†™
     */
    public void normalOperation() {
        // æœ€å¿«ï¼šå¯èƒ½åªæ¶‰åŠCPUç¼“å­˜
        normalVar = 42;      // assignæ“ä½œï¼Œå¯èƒ½å»¶è¿Ÿstore/write
        int value = normalVar; // useæ“ä½œï¼Œå¯èƒ½ä»ç¼“å­˜è¯»å–
    }
    
    /**
     * æ€§èƒ½æµ‹è¯•ï¼švolatileå˜é‡è¯»å†™
     */
    public void volatileOperation() {
        // ä¸­ç­‰ï¼šå¼ºåˆ¶å†…å­˜åŒæ­¥
        volatileVar = 42;      // ç«‹å³store/writeåˆ°ä¸»å†…å­˜
        int value = volatileVar; // å¼ºåˆ¶read/loadä»ä¸»å†…å­˜
    }
    
    /**
     * æ€§èƒ½æµ‹è¯•ï¼šsynchronizedæ“ä½œ
     */
    public void synchronizedOperation() {
        // æœ€æ…¢ï¼šæ¶‰åŠé”ç«äº‰å’Œå®Œæ•´å†…å­˜åŒæ­¥
        synchronized (lock) {
            normalVar = 42;    // lock â†’ assign â†’ store â†’ write â†’ unlock
        }
    }
}
```

**2. å†…å­˜å±éšœçš„å¼€é”€**
```java
/**
 * å†…å­˜å±éšœå¯¹æ€§èƒ½çš„å½±å“
 */
public class MemoryBarrierOverhead {
    private volatile boolean flag1 = false;
    private volatile boolean flag2 = false;
    private volatile boolean flag3 = false;
    
    /**
     * é¿å…è¿‡å¤šçš„volatileå˜é‡
     */
    public void inefficientPattern() {
        // âŒ ä½æ•ˆï¼šæ¯ä¸ªvolatileå†™éƒ½ä¼šæ’å…¥å†…å­˜å±éšœ
        flag1 = true;  // StoreStore + StoreLoadå±éšœ
        flag2 = true;  // StoreStore + StoreLoadå±éšœ  
        flag3 = true;  // StoreStore + StoreLoadå±éšœ
    }
    
    /**
     * ä¼˜åŒ–ï¼šå‡å°‘volatileå˜é‡æ•°é‡
     */
    private volatile int state = 0;
    
    public void efficientPattern() {
        // âœ… é«˜æ•ˆï¼šä½¿ç”¨å•ä¸ªvolatileå˜é‡è¡¨ç¤ºçŠ¶æ€
        state = 7; // äºŒè¿›åˆ¶111è¡¨ç¤ºä¸‰ä¸ªæ ‡å¿—éƒ½ä¸ºtrue
        // åªéœ€è¦ä¸€æ¬¡å†…å­˜å±éšœå¼€é”€
    }
}
```

### æœ€ä½³å®è·µå»ºè®®

**1. åˆç†é€‰æ‹©åŒæ­¥æœºåˆ¶**
```java
/**
 * æ ¹æ®åœºæ™¯é€‰æ‹©åˆé€‚çš„åŒæ­¥æœºåˆ¶
 */
public class SynchronizationChoice {
    
    // åœºæ™¯1ï¼šç®€å•çŠ¶æ€æ ‡å¿—
    private volatile boolean initialized = false;
    
    public void simpleFlag() {
        // âœ… ä½¿ç”¨volatileï¼šè½»é‡çº§ï¼Œé€‚åˆç®€å•æ ‡å¿—
        if (!initialized) {
            doInitialization();
            initialized = true;
        }
    }
    
    // åœºæ™¯2ï¼šå¤åˆæ“ä½œ
    private int counter = 0;
    private final Object counterLock = new Object();
    
    public void complexOperation() {
        // âœ… ä½¿ç”¨synchronizedï¼šä¿è¯åŸå­æ€§
        synchronized (counterLock) {
            counter++; // å¤åˆæ“ä½œéœ€è¦åŸå­æ€§ä¿è¯
        }
    }
    
    // åœºæ™¯3ï¼šé«˜é¢‘è¯»å–ï¼Œä½é¢‘å†™å…¥
    private volatile String cachedValue = null;
    
    public String getCachedValue() {
        // âœ… ä½¿ç”¨volatileï¼šè¯»å–æ€§èƒ½ä¼˜äºsynchronized
        return cachedValue;
    }
    
    public void updateCache(String newValue) {
        cachedValue = newValue; // å†™å…¥é¢‘ç‡ä½ï¼Œvolatileå¼€é”€å¯æ¥å—
    }
}
```

**2. é¿å…å¸¸è§é™·é˜±**
```java
/**
 * JMMä½¿ç”¨ä¸­çš„å¸¸è§é™·é˜±
 */
public class CommonPitfalls {
    
    /**
     * é™·é˜±1ï¼šè¯¯ä»¥ä¸ºvolatileä¿è¯åŸå­æ€§
     */
    private volatile int counter = 0;
    
    public void incorrectIncrement() {
        // âŒ é”™è¯¯ï¼švolatileä¸ä¿è¯å¤åˆæ“ä½œçš„åŸå­æ€§
        counter++; // ä»ç„¶æ˜¯read-modify-writeï¼Œå­˜åœ¨ç«äº‰æ¡ä»¶
    }
    
    /**
     * é™·é˜±2ï¼šè¿‡åº¦ä¾èµ–volatile
     */
    private volatile int x = 0;
    private volatile int y = 0;
    
    public void incorrectAtomicUpdate() {
        // âŒ é”™è¯¯ï¼šä¸¤ä¸ªvolatileå†™ä¸æ˜¯åŸå­çš„
        x = 1;
        y = 2;
        // å…¶ä»–çº¿ç¨‹å¯èƒ½çœ‹åˆ°x=1, y=0çš„ä¸­é—´çŠ¶æ€
    }
    
    /**
     * é™·é˜±3ï¼šå¿½ç•¥æ„é€ å‡½æ•°çš„å†…å­˜è¯­ä¹‰
     */
    private final int finalField;
    private int normalField;
    
    public CommonPitfalls(int value) {
        finalField = value;    // finalå­—æ®µçš„å†™å…¥æœ‰ç‰¹æ®Šå†…å­˜è¯­ä¹‰
        normalField = value;   // æ™®é€šå­—æ®µå¯èƒ½è¢«é‡æ’åºåˆ°æ„é€ å‡½æ•°å¤–
    }
}
```

## ğŸ“š æ€»ç»“ä¸æŠ€æœ¯å¯¹æ¯”

### æ ¸å¿ƒè¦ç‚¹æ€»ç»“

**JMMçš„æœ¬è´¨**ï¼š
1. **æŠ½è±¡æ¨¡å‹**ï¼šå®šä¹‰äº†çº¿ç¨‹ã€ä¸»å†…å­˜ã€å·¥ä½œå†…å­˜ä¹‹é—´çš„äº¤äº’è§„åˆ™
2. **æ“ä½œåŸè¯­**ï¼š8ç§åŸå­æ€§çš„å†…å­˜äº¤äº’æ“ä½œ
3. **é¡ºåºä¿è¯**ï¼šé€šè¿‡happens-beforeå…³ç³»ç¡®ä¿ç¨‹åºæ‰§è¡Œçš„æ­£ç¡®æ€§
4. **æ€§èƒ½å¹³è¡¡**ï¼šåœ¨æ­£ç¡®æ€§å’Œæ€§èƒ½ä¹‹é—´æ‰¾åˆ°æœ€ä½³å¹³è¡¡ç‚¹

**å…³é”®è®¾è®¡åŸåˆ™**ï¼š
- **æœ€å°æƒŠè®¶åŸåˆ™**ï¼šç¨‹åºçš„è¡Œä¸ºåº”è¯¥ç¬¦åˆå¼€å‘è€…çš„ç›´è§‰
- **æ€§èƒ½ä¼˜åŒ–ç©ºé—´**ï¼šå…è®¸ç¼–è¯‘å™¨å’ŒCPUè¿›è¡Œå¿…è¦çš„ä¼˜åŒ–
- **å¹³å°æ— å…³æ€§**ï¼šæä¾›ç»Ÿä¸€çš„å†…å­˜è¯­ä¹‰ï¼Œä¸ä¾èµ–å…·ä½“ç¡¬ä»¶

### ä¸å…¶ä»–å†…å­˜æ¨¡å‹å¯¹æ¯”

| ç‰¹æ€§ | Javaå†…å­˜æ¨¡å‹ | C++å†…å­˜æ¨¡å‹ | Goå†…å­˜æ¨¡å‹ | JavaScript |
|------|-------------|------------|-----------|------------|
| æŠ½è±¡å±‚æ¬¡ | é«˜å±‚æŠ½è±¡ | åº•å±‚æ§åˆ¶ | ä¸­ç­‰æŠ½è±¡ | å•çº¿ç¨‹æ¨¡å‹ |
| å†…å­˜æ“ä½œ | 8ç§æ“ä½œ | 6ç§æ’åº | happens-before | äº‹ä»¶å¾ªç¯ |
| åŒæ­¥åŸè¯­ | volatile/synchronized | atomic/mutex | channel/mutex | Promise/async |
| æ€§èƒ½å¼€é”€ | ä¸­ç­‰ | å¯æ§ | ä½ | æ— (å•çº¿ç¨‹) |
| æ˜“ç”¨æ€§ | è¾ƒå¥½ | å¤æ‚ | ç®€æ´ | ç®€å• |

### å®é™…åº”ç”¨æŒ‡å¯¼

**é€‰æ‹©åŒæ­¥æœºåˆ¶çš„å†³ç­–æ ‘**ï¼š
```java
/**
 * åŒæ­¥æœºåˆ¶é€‰æ‹©æŒ‡å—
 */
public class SynchronizationGuide {
    
    // 1. ç®€å•çŠ¶æ€æ ‡å¿— â†’ volatile
    private volatile boolean ready = false;
    
    // 2. åŸå­æ›´æ–° â†’ AtomicXxx
    private final AtomicInteger atomicCounter = new AtomicInteger(0);
    
    // 3. å¤åˆæ“ä½œ â†’ synchronized
    private final List<String> list = new ArrayList<>();
    
    public synchronized void addItem(String item) {
        list.add(item); // å¤åˆæ“ä½œéœ€è¦å®Œæ•´åŒæ­¥
    }
    
    // 4. é«˜æ€§èƒ½åœºæ™¯ â†’ Lockæ¥å£
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    
    public String readData() {
        rwLock.readLock().lock();
        try {
            // è¯»æ“ä½œï¼Œå…è®¸å¹¶å‘
            return getData();
        } finally {
            rwLock.readLock().unlock();
        }
    }
}
```

Javaå†…å­˜æ¨¡å‹ä½œä¸ºå¹¶å‘ç¼–ç¨‹çš„ç†è®ºåŸºç¡€ï¼Œä¸ºæˆ‘ä»¬æä¾›äº†ç†è§£å’Œæ„å»ºæ­£ç¡®å¹¶å‘ç¨‹åºçš„æ¡†æ¶ã€‚æ·±å…¥æŒæ¡JMMçš„åŸç†å’Œ8ç§å†…å­˜äº¤äº’æ“ä½œï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬æ›´å¥½åœ°ç†è§£volatileã€synchronizedç­‰å¹¶å‘æœºåˆ¶çš„å·¥ä½œåŸç†ï¼Œä»è€Œç¼–å†™å‡ºæ—¢æ­£ç¡®åˆé«˜æ•ˆçš„å¤šçº¿ç¨‹ç¨‹åºã€‚

é€šè¿‡æœ¬æ–‡çš„æ·±å…¥åˆ†æï¼Œæˆ‘ä»¬ä¸ä»…äº†è§£äº†JMMçš„æŠ½è±¡æ¨¡å‹ï¼Œæ›´é‡è¦çš„æ˜¯æŒæ¡äº†å¦‚ä½•åœ¨å®é™…é¡¹ç›®ä¸­æ­£ç¡®åº”ç”¨è¿™äº›çŸ¥è¯†ï¼Œé¿å…å¸¸è§çš„å¹¶å‘é™·é˜±ï¼Œæ„å»ºå¯é çš„å¹¶å‘ç³»ç»Ÿã€‚ 